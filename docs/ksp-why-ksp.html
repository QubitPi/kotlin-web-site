<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-15T17:12:00.690681333"><link rel="canonical" href="https://kotlinlang.org/docs/ksp-why-ksp.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Why KSP | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"ksp-makes-creating-lightweight-compiler-plugins-easier","level":0,"title":"KSP makes creating lightweight compiler plugins easier","anchor":"#ksp-makes-creating-lightweight-compiler-plugins-easier"},{"id":"comparison-to-kotlinc-compiler-plugins","level":0,"title":"Comparison to kotlinc compiler plugins","anchor":"#comparison-to-kotlinc-compiler-plugins"},{"id":"comparison-to-reflection","level":0,"title":"Comparison to reflection","anchor":"#comparison-to-reflection"},{"id":"comparison-to-kapt","level":0,"title":"Comparison to kapt","anchor":"#comparison-to-kapt"},{"id":"limitations","level":0,"title":"Limitations","anchor":"#limitations"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Why KSP | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/ksp-why-ksp.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Why KSP | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/ksp-why-ksp.html#webpage",
    "url": "https://kotlinlang.org/docs/ksp-why-ksp.html",
    "name": "Why KSP | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="ksp-why-ksp" data-main-title="Why KSP" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Compiler and plugins///Kotlin Symbol Processing API" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/ksp/ksp-why-ksp.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ksp-why-ksp" id="ksp-why-ksp.md">Why KSP</h1><p id="z5spp8v_2">Compiler plugins are powerful metaprogramming tools that can greatly enhance how you write code. Compiler plugins call compilers directly as libraries to analyze and edit input programs. These plugins can also generate output for various uses. For example, they can generate boilerplate code, and they can even generate full implementations for specially-marked program elements, such as <code class="code" id="z5spp8v_9">Parcelable</code>. Plugins have a variety of other uses and can even be used to implement and fine-tune features that are not provided directly in a language.</p><p id="z5spp8v_3">While compiler plugins are powerful, this power comes at a price. To write even the simplest plugin, you need to have some compiler background knowledge, as well as a certain level of familiarity with the implementation details of your specific compiler. Another practical issue is that plugins are often closely tied to specific compiler versions, meaning you might need to update your plugin each time you want to support a newer version of the compiler.</p><section class="chapter"><h2 id="ksp-makes-creating-lightweight-compiler-plugins-easier" data-toc="ksp-makes-creating-lightweight-compiler-plugins-easier">KSP makes creating lightweight compiler plugins easier</h2><p id="z5spp8v_10">KSP is designed to hide compiler changes, minimizing maintenance efforts for processors that use it. KSP is designed not to be tied to the JVM so that it can be adapted to other platforms more easily in the future. KSP is also designed to minimize build times. For some processors, such as <a href="https://github.com/bumptech/glide" id="z5spp8v_12" data-external="true" rel="noopener noreferrer" target="_blank">Glide</a>, KSP reduces full compilation times by up to 25% when compared to kapt.</p><p id="z5spp8v_11">KSP is itself implemented as a compiler plugin. There are prebuilt packages on Google's Maven repository that you can download and use without having to build the project yourself.</p></section><section class="chapter"><h2 id="comparison-to-kotlinc-compiler-plugins" data-toc="comparison-to-kotlinc-compiler-plugins">Comparison to kotlinc compiler plugins</h2><p id="z5spp8v_13"><code class="code" id="z5spp8v_17">kotlinc</code> compiler plugins have access to almost everything from the compiler and therefore have maximum power and flexibility. On the other hand, because these plugins can potentially depend on anything in the compiler, they are sensitive to compiler changes and need to be maintained frequently. These plugins also require a deep understanding of <code class="code" id="z5spp8v_18">kotlinc</code>'s implementation, so the learning curve can be steep.</p><p id="z5spp8v_14">KSP aims to hide most compiler changes through a well-defined API, though major changes in compiler or even the Kotlin language might still require to be exposed to API users.</p><p id="z5spp8v_15">KSP tries to fulfill common use cases by providing an API that trades power for simplicity. Its capability is a strict subset of a general <code class="code" id="z5spp8v_19">kotlinc</code> plugin. For example, while <code class="code" id="z5spp8v_20">kotlinc</code> can examine expressions and statements and can even modify code, KSP cannot.</p><p id="z5spp8v_16">While writing a <code class="code" id="z5spp8v_21">kotlinc</code> plugin can be a lot of fun, it can also take a lot of time. If you aren't in a position to learn <code class="code" id="z5spp8v_22">kotlinc</code>'s implementation and do not need to modify source code or read expressions, KSP might be a good fit.</p></section><section class="chapter"><h2 id="comparison-to-reflection" data-toc="comparison-to-reflection">Comparison to reflection</h2><p id="z5spp8v_23">KSP's API looks similar to <code class="code" id="z5spp8v_24">kotlin.reflect</code>. The major difference between them is that type references in KSP need to be resolved explicitly. This is one of the reasons why the interfaces are not shared.</p></section><section class="chapter"><h2 id="comparison-to-kapt" data-toc="comparison-to-kapt">Comparison to kapt</h2><p id="z5spp8v_25"><a href="kapt.html" id="z5spp8v_29">kapt</a> is a remarkable solution which makes a large amount of Java annotation processors work for Kotlin programs out-of-box. The major advantages of KSP over kapt are improved build performance, not tied to JVM, a more idiomatic Kotlin API, and the ability to understand Kotlin-only symbols.</p><p id="z5spp8v_26">To run Java annotation processors unmodified, kapt compiles Kotlin code into Java stubs that retain information that Java annotation processors care about. To create these stubs, kapt needs to resolve all symbols in the Kotlin program. The stub generation costs roughly 1/3 of a full <code class="code" id="z5spp8v_30">kotlinc</code> analysis and the same order of <code class="code" id="z5spp8v_31">kotlinc</code> code-generation. For many annotation processors, this is much longer than the time spent in the processors themselves. For example, Glide looks at a very limited number of classes with a predefined annotation, and its code generation is fairly quick. Almost all of the build overhead resides in the stub generation phase. Switching to KSP would immediately reduce the time spent in the compiler by 25%.</p><p id="z5spp8v_27">For performance evaluation, we implemented a <a href="https://github.com/google/ksp/releases/download/1.4.10-dev-experimental-20200924/miniGlide.zip" id="z5spp8v_32" data-external="true" rel="noopener noreferrer" target="_blank">simplified version</a> of <a href="https://github.com/bumptech/glide" id="z5spp8v_33" data-external="true" rel="noopener noreferrer" target="_blank">Glide</a> in KSP to make it generate code for the <a href="https://github.com/tachiyomiorg" id="z5spp8v_34" data-external="true" rel="noopener noreferrer" target="_blank">Tachiyomi</a> project. While the total Kotlin compilation time of the project is 21.55 seconds on our test device, it took 8.67 seconds for kapt to generate the code, and it took 1.15 seconds for our KSP implementation to generate the code.</p><p id="z5spp8v_28">Unlike kapt, processors in KSP do not see input programs from Java's point of view. The API is more natural to Kotlin, especially for Kotlin-specific features such as top-level functions. Because KSP doesn't delegate to <code class="code" id="z5spp8v_35">javac</code> like kapt, it doesn't assume JVM-specific behaviors and can be used with other platforms potentially.</p></section><section class="chapter"><h2 id="limitations" data-toc="limitations">Limitations</h2><p id="z5spp8v_36">While KSP tries to be a simple solution for most common use cases, it has made several trade-offs compared to other plugin solutions. The following are not goals of KSP:</p><ul class="list _bullet" id="z5spp8v_37"><li class="list__item" id="z5spp8v_38"><p id="z5spp8v_41">Examining expression-level information of source code.</p></li><li class="list__item" id="z5spp8v_39"><p id="z5spp8v_42">Modifying source code.</p></li><li class="list__item" id="z5spp8v_40"><p id="z5spp8v_43">100% compatibility with the Java Annotation Processing API.</p></li></ul></section><div class="last-modified">15 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ksp-quickstart.html" class="navigation-links__prev">KSP quickstart</a><a href="ksp-examples.html" class="navigation-links__next">KSP examples</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>