<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-18T18:58:26.436669547"><link rel="canonical" href="https://kotlinlang.org/docs/k2-compiler-migration-guide.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>K2 compiler migration guide | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"performance-improvements","level":0,"title":"Performance improvements","anchor":"#performance-improvements"},{"id":"language-feature-improvements","level":0,"title":"Language feature improvements","anchor":"#language-feature-improvements"},{"id":"smart-casts","level":1,"title":"Smart casts","anchor":"#smart-casts"},{"id":"kotlin-multiplatform","level":1,"title":"Kotlin Multiplatform","anchor":"#kotlin-multiplatform"},{"id":"how-to-enable-the-kotlin-k2-compiler","level":0,"title":"How to enable the Kotlin K2 compiler","anchor":"#how-to-enable-the-kotlin-k2-compiler"},{"id":"use-kotlin-build-reports-with-gradle","level":1,"title":"Use Kotlin build reports with Gradle","anchor":"#use-kotlin-build-reports-with-gradle"},{"id":"support-in-ides","level":0,"title":"Support in IDEs","anchor":"#support-in-ides"},{"id":"previous-ide-behavior","level":1,"title":"Previous IDE behavior","anchor":"#previous-ide-behavior"},{"id":"try-the-kotlin-k2-compiler-in-the-kotlin-playground","level":0,"title":"Try the Kotlin K2 compiler in the Kotlin Playground","anchor":"#try-the-kotlin-k2-compiler-in-the-kotlin-playground"},{"id":"how-to-roll-back-to-the-previous-compiler","level":0,"title":"How to roll back to the previous compiler","anchor":"#how-to-roll-back-to-the-previous-compiler"},{"id":"changes","level":0,"title":"Changes","anchor":"#changes"},{"id":"immediate-initialization-of-open-properties-with-backing-fields","level":1,"title":"Immediate initialization of open properties with backing fields","anchor":"#immediate-initialization-of-open-properties-with-backing-fields"},{"id":"deprecated-synthetics-setter-on-a-projected-receiver","level":1,"title":"Deprecated synthetics setter on a projected receiver","anchor":"#deprecated-synthetics-setter-on-a-projected-receiver"},{"id":"forbidden-use-of-inaccessible-generic-types","level":1,"title":"Forbidden use of inaccessible generic types","anchor":"#forbidden-use-of-inaccessible-generic-types"},{"id":"consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name","level":1,"title":"Consistent resolution order of Kotlin properties and Java fields with the same name","anchor":"#consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name"},{"id":"improved-null-safety-for-java-primitive-arrays","level":1,"title":"Improved null safety for Java primitive arrays","anchor":"#improved-null-safety-for-java-primitive-arrays"},{"id":"stricter-rules-for-abstract-members-in-expected-classes","level":1,"title":"Stricter rules for abstract members in expected classes","anchor":"#stricter-rules-for-abstract-members-in-expected-classes"},{"id":"per-subject-area","level":1,"title":"Per subject area","anchor":"#per-subject-area"},{"id":"compatibility-with-kotlin-releases","level":0,"title":"Compatibility with Kotlin releases","anchor":"#compatibility-with-kotlin-releases"},{"id":"compatibility-with-kotlin-libraries","level":0,"title":"Compatibility with Kotlin libraries","anchor":"#compatibility-with-kotlin-libraries"},{"id":"compiler-plugins-support","level":0,"title":"Compiler plugins support","anchor":"#compiler-plugins-support"},{"id":"upgrade-your-custom-compiler-plugins","level":1,"title":"Upgrade your custom compiler plugins","anchor":"#upgrade-your-custom-compiler-plugins"},{"id":"share-your-feedback-on-the-new-k2-compiler","level":0,"title":"Share your feedback on the new K2 compiler","anchor":"#share-your-feedback-on-the-new-k2-compiler"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="K2 compiler migration guide | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/k2-compiler-migration-guide.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="K2 compiler migration guide | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/k2-compiler-migration-guide.html#webpage",
    "url": "https://kotlinlang.org/docs/k2-compiler-migration-guide.html",
    "name": "K2 compiler migration guide | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="k2-compiler-migration-guide" data-main-title="K2 compiler migration guide" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Compiler and plugins///Kotlin compiler" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/k2-compiler-migration-guide.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="k2-compiler-migration-guide" id="k2-compiler-migration-guide.md">K2 compiler migration guide</h1><p id="-td61vq_2">As the Kotlin language and ecosystem have continued to evolve, so has the Kotlin compiler. The first step was the introduction of the new JVM and JS IR (Intermediate Representation) backends that share logic, simplifying code generation for targets on different platforms. Now, the next stage of its evolution brings a new frontend known as K2.</p><figure id="-td61vq_3"><img alt="Kotlin K2 compiler architecture" src="images/k2-compiler-architecture.svg" title="Kotlin K2 compiler architecture" width="700" height="394"></figure><p id="-td61vq_4">With the arrival of the K2 compiler, the Kotlin frontend has been completely rewritten and features a new, more efficient architecture. The fundamental change the new compiler brings is the use of one unified data structure that contains more semantic information. This frontend is responsible for performing semantic analysis, call resolution, and type inference.</p><p id="-td61vq_5">The new architecture and enriched data structure enables the K2 compiler to provide the following benefits:</p><ul class="list _bullet" id="-td61vq_6"><li class="list__item" id="-td61vq_21"><p id="-td61vq_25"><span class="control" id="-td61vq_26">Improved call resolution and type inference</span>. The compiler behaves more consistently and understands your code better.</p></li><li class="list__item" id="-td61vq_22"><p id="-td61vq_27"><span class="control" id="-td61vq_28">Easier introduction of syntactic sugar for new language features</span>. In the future, you'll be able to use more concise, readable code when new features are introduced.</p></li><li class="list__item" id="-td61vq_23"><p id="-td61vq_29"><span class="control" id="-td61vq_30">Faster compilation times</span>. Compilation times can be <a href="#performance-improvements" id="-td61vq_31">significantly faster</a>.</p></li><li class="list__item" id="-td61vq_24"><p id="-td61vq_32"><span class="control" id="-td61vq_33">Enhanced IDE performance</span>. Starting with 2025.1, IntelliJ IDEA uses K2 mode to analyze your Kotlin code, increasing stability and providing performance improvements. For more information, see <a href="#support-in-ides" id="-td61vq_34">Support in IDEs</a>.</p></li></ul><p id="-td61vq_7">This guide:</p><ul class="list _bullet" id="-td61vq_8"><li class="list__item" id="-td61vq_35"><p id="-td61vq_38">Explains the benefits of the new K2 compiler.</p></li><li class="list__item" id="-td61vq_36"><p id="-td61vq_39">Highlights changes you might encounter during migration and how to adapt your code accordingly.</p></li><li class="list__item" id="-td61vq_37"><p id="-td61vq_40">Describes how you can roll back to the previous version.</p></li></ul><aside class="prompt" data-type="note" data-title="" id="-td61vq_9"><p id="-td61vq_41">The new K2 compiler is enabled by default starting with 2.0.0. For more information on the new features provided in Kotlin 2.0.0, as well as the new K2 compiler, see <a href="whatsnew20.html" id="-td61vq_42">What's new in Kotlin 2.0.0</a>.</p></aside><section class="chapter"><h2 id="performance-improvements" data-toc="performance-improvements">Performance improvements</h2><p id="-td61vq_43">To evaluate the performance of the K2 compiler, we ran performance tests on two open-source projects: <a href="https://github.com/ankidroid/Anki-Android" id="-td61vq_46" data-external="true" rel="noopener noreferrer" target="_blank">Anki-Android</a> and <a href="https://github.com/JetBrains/Exposed" id="-td61vq_47" data-external="true" rel="noopener noreferrer" target="_blank">Exposed</a>. Here are the key performance improvements that we found:</p><ul class="list _bullet" id="-td61vq_44"><li class="list__item" id="-td61vq_48"><p id="-td61vq_51">The K2 compiler brings up to 94% compilation speed gains. For example, in the Anki-Android project, clean build times were reduced from 57.7 seconds in Kotlin 1.9.23 to 29.7 seconds in Kotlin 2.0.0.</p></li><li class="list__item" id="-td61vq_49"><p id="-td61vq_52">The initialization phase is up to 488% faster with the K2 compiler. For example, in the Anki-Android project, the initialization phase for incremental builds was cut from 0.126 seconds in Kotlin 1.9.23 to just 0.022 seconds in Kotlin 2.0.0.</p></li><li class="list__item" id="-td61vq_50"><p id="-td61vq_53">The Kotlin K2 compiler is up to 376% quicker in the analysis phase compared to the previous compiler. For example, in the Anki-Android project, analysis times for incremental builds were slashed from 0.581 seconds in Kotlin 1.9.23 to only 0.122 seconds in Kotlin 2.0.0.</p></li></ul><p id="-td61vq_45">For more details on these improvements and to learn more about how we analyzed the performance of the K2 compiler, see our <a href="https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks-and-how-to-measure-them-on-your-projects/" id="-td61vq_54" data-external="true" rel="noopener noreferrer" target="_blank">blog post</a>.</p></section><section class="chapter"><h2 id="language-feature-improvements" data-toc="language-feature-improvements">Language feature improvements</h2><p id="-td61vq_55">The Kotlin K2 compiler improves language features related to <a href="#smart-casts" id="-td61vq_58">smart-casting</a> and <a href="#kotlin-multiplatform" id="-td61vq_59">Kotlin Multiplatform</a>.</p><section class="chapter"><h3 id="smart-casts" data-toc="smart-casts">Smart casts</h3><p id="-td61vq_60">The Kotlin compiler can automatically cast an object to a type in specific cases, saving you the trouble of having to explicitly specify it yourself. This is called <a href="typecasts.html#smart-casts" id="-td61vq_69">smart-casting</a>. The Kotlin K2 compiler now performs smart casts in even more scenarios than before.</p><p id="-td61vq_61">In Kotlin 2.0.0, we've made improvements related to smart casts in the following areas:</p><ul class="list _bullet" id="-td61vq_62"><li class="list__item" id="-td61vq_70"><p id="-td61vq_76"><a href="#local-variables-and-further-scopes" id="-td61vq_77">Local variables and further scopes</a></p></li><li class="list__item" id="-td61vq_71"><p id="-td61vq_78"><a href="#type-checks-with-the-logical-or-operator" id="-td61vq_79">Type checks with the logical <code class="code" id="-td61vq_80">or</code> operator</a></p></li><li class="list__item" id="-td61vq_72"><p id="-td61vq_81"><a href="#inline-functions" id="-td61vq_82">Inline functions</a></p></li><li class="list__item" id="-td61vq_73"><p id="-td61vq_83"><a href="#properties-with-function-types" id="-td61vq_84">Properties with function types</a></p></li><li class="list__item" id="-td61vq_74"><p id="-td61vq_85"><a href="#exception-handling" id="-td61vq_86">Exception handling</a></p></li><li class="list__item" id="-td61vq_75"><p id="-td61vq_87"><a href="#increment-and-decrement-operators" id="-td61vq_88">Increment and decrement operators</a></p></li></ul><section class="chapter"><h4 id="local-variables-and-further-scopes" data-toc="local-variables-and-further-scopes">Local variables and further scopes</h4><p id="-td61vq_89">Previously, if a variable was evaluated as not <code class="code" id="-td61vq_94">null</code> within an <code class="code" id="-td61vq_95">if</code> condition, the variable would be smart-cast. Information about this variable would then be shared further within the scope of the <code class="code" id="-td61vq_96">if</code> block.</p><p id="-td61vq_90">However, if you declared the variable <span class="control" id="-td61vq_97">outside</span> the <code class="code" id="-td61vq_98">if</code> condition, no information about the variable would be available within the <code class="code" id="-td61vq_99">if</code> condition, so it couldn't be smart-cast. This behavior was also seen with <code class="code" id="-td61vq_100">when</code> expressions and <code class="code" id="-td61vq_101">while</code> loops.</p><p id="-td61vq_91">From Kotlin 2.0.0, if you declare a variable before using it in your <code class="code" id="-td61vq_102">if</code>, <code class="code" id="-td61vq_103">when</code>, or <code class="code" id="-td61vq_104">while</code> condition, then any information collected by the compiler about the variable will be accessible in the corresponding block for smart-casting.</p><p id="-td61vq_92">This can be useful when you want to do things like extract boolean conditions into variables. Then, you can give the variable a meaningful name, which will improve your code readability and make it possible to reuse the variable later in your code. For example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-local-variables">
class Cat {
    fun purr() {
        println(&quot;Purr purr&quot;)
    }
}

fun petAnimal(animal: Any) {
    val isCat = animal is Cat
    if (isCat) {
        // In Kotlin 2.0.0, the compiler can access
        // information about isCat, so it knows that
        // animal was smart-cast to the type Cat.
        // Therefore, the purr() function can be called.
        // In Kotlin 1.9.20, the compiler doesn't know
        // about the smart cast, so calling the purr()
        // function triggers an error.
        animal.purr()
    }
}

fun main(){
    val kitty = Cat()
    petAnimal(kitty)
    // Purr purr
}
</div></section><section class="chapter"><h4 id="type-checks-with-the-logical-or-operator" data-toc="type-checks-with-the-logical-or-operator">Type checks with the logical or operator</h4><p id="-td61vq_105">In Kotlin 2.0.0, if you combine type checks for objects with an <code class="code" id="-td61vq_109">or</code> operator (<code class="code" id="-td61vq_110">||</code>), a smart cast is made to their closest common supertype. Before this change, a smart cast was always made to the <code class="code" id="-td61vq_111">Any</code> type.</p><p id="-td61vq_106">In this case, you still had to manually check the object type afterward before you could access any of its properties or call its functions. For example:</p><div class="code-block" data-lang="kotlin">
interface Status {
    fun signal() {}
}

interface Ok : Status
interface Postponed : Status
interface Declined : Status

fun signalCheck(signalStatus: Any) {
    if (signalStatus is Postponed || signalStatus is Declined) {
        // signalStatus is smart-cast to a common supertype Status
        signalStatus.signal()
        // Prior to Kotlin 2.0.0, signalStatus is smart cast 
        // to type Any, so calling the signal() function triggered an
        // Unresolved reference error. The signal() function can only 
        // be called successfully after another type check:
        
        // check(signalStatus is Status)
        // signalStatus.signal()
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="-td61vq_108"><p id="-td61vq_112">The common supertype is an <span class="control" id="-td61vq_113">approximation</span> of a <a href="https://en.wikipedia.org/wiki/Union_type" id="-td61vq_114" data-external="true" rel="noopener noreferrer" target="_blank">union type</a>. Union types are <a href="https://youtrack.jetbrains.com/issue/KT-13108/Denotable-union-and-intersection-types" id="-td61vq_115" data-external="true" rel="noopener noreferrer" target="_blank">not currently supported in Kotlin</a>.</p></aside></section><section class="chapter"><h4 id="inline-functions" data-toc="inline-functions">Inline functions</h4><p id="-td61vq_116">In Kotlin 2.0.0, the K2 compiler treats inline functions differently, allowing it to determine in combination with other compiler analyses whether it's safe to smart-cast.</p><p id="-td61vq_117">Specifically, inline functions are now treated as having an implicit <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.contracts/-contract-builder/calls-in-place.html" id="-td61vq_120" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-td61vq_121">callsInPlace</code></a> contract. This means that any lambda functions passed to an inline function are called in place. Since lambda functions are called in place, the compiler knows that a lambda function can't leak references to any variables contained within its function body.</p><p id="-td61vq_118">The compiler uses this knowledge along with other compiler analyses to decide whether it's safe to smart-cast any of the captured variables. For example:</p><div class="code-block" data-lang="kotlin">
interface Processor {
    fun process()
}

inline fun inlineAction(f: () -&gt; Unit) = f()

fun nextProcessor(): Processor? = null

fun runProcessor(): Processor? {
    var processor: Processor? = null
    inlineAction {
        // In Kotlin 2.0.0, the compiler knows that processor 
        // is a local variable and inlineAction() is an inline function, so 
        // references to processor can't be leaked. Therefore, it's safe 
        // to smart-cast processor.
      
        // If processor isn't null, processor is smart-cast
        if (processor != null) {
            // The compiler knows that processor isn't null, so no safe call 
            // is needed
            processor.process()

            // In Kotlin 1.9.20, you have to perform a safe call:
            // processor?.process()
        }

        processor = nextProcessor()
    }

    return processor
}
</div></section><section class="chapter"><h4 id="properties-with-function-types" data-toc="properties-with-function-types">Properties with function types</h4><p id="-td61vq_122">In previous versions of Kotlin, there was a bug that meant that class properties with a function type weren't smart-cast. We fixed this behavior in Kotlin 2.0.0 and the K2 compiler. For example:</p><div class="code-block" data-lang="kotlin">
class Holder(val provider: (() -&gt; Unit)?) {
    fun process() {
        // In Kotlin 2.0.0, if provider isn't null,
        // it is smart-cast
        if (provider != null) {
            // The compiler knows that provider isn't null
            provider()

            // In 1.9.20, the compiler doesn't know that provider isn't 
            // null, so it triggers an error:
            // Reference has a nullable type '(() -&gt; Unit)?', use explicit '?.invoke()' to make a function-like call instead
        }
    }
}
</div><p id="-td61vq_124">This change also applies if you overload your <code class="code" id="-td61vq_126">invoke</code> operator. For example:</p><div class="code-block" data-lang="kotlin">
interface Provider {
    operator fun invoke()
}

interface Processor : () -&gt; String

class Holder(val provider: Provider?, val processor: Processor?) {
    fun process() {
        if (provider != null) {
            provider() 
            // In 1.9.20, the compiler triggers an error: 
            // Reference has a nullable type 'Provider?', use explicit '?.invoke()' to make a function-like call instead
        }
    }
}
</div></section><section class="chapter"><h4 id="exception-handling" data-toc="exception-handling">Exception handling</h4><p id="-td61vq_127">In Kotlin 2.0.0, we've made improvements to exception handling so that smart cast information can be passed on to <code class="code" id="-td61vq_129">catch</code> and <code class="code" id="-td61vq_130">finally</code> blocks. This change makes your code safer as the compiler keeps track of whether your object has a nullable type. For example:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-exception-handling">
//sampleStart
fun testString() {
    var stringInput: String? = null
    // stringInput is smart-cast to String type
    stringInput = &quot;&quot;
    try {
        // The compiler knows that stringInput isn't null
        println(stringInput.length)
        // 0

        // The compiler rejects previous smart cast information for 
        // stringInput. Now stringInput has the String? type.
        stringInput = null

        // Trigger an exception
        if (2 &gt; 1) throw Exception()
        stringInput = &quot;&quot;
    } catch (exception: Exception) {
        // In Kotlin 2.0.0, the compiler knows stringInput 
        // can be null, so stringInput stays nullable.
        println(stringInput?.length)
        // null

        // In Kotlin 1.9.20, the compiler says that a safe call isn't
        // needed, but this is incorrect.
    }
}
//sampleEnd
fun main() {
    testString()
}
</div></section><section class="chapter"><h4 id="increment-and-decrement-operators" data-toc="increment-and-decrement-operators">Increment and decrement operators</h4><p id="-td61vq_131">Prior to Kotlin 2.0.0, the compiler didn't understand that the type of an object can change after using an increment or decrement operator. As the compiler couldn't accurately track the object type, your code could lead to unresolved reference errors. In Kotlin 2.0.0, this has been fixed:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="2.0" id="kotlin-smart-casts-k2-increment-decrement-operators">
interface Rho {
    operator fun inc(): Sigma = TODO()
}

interface Sigma : Rho {
    fun sigma() = Unit
}

interface Tau {
    fun tau() = Unit
}

fun main(input: Rho) {
    var unknownObject: Rho = input

    // Check if unknownObject inherits from the Tau interface
    // Note, it's possible that unknownObject inherits from both
    // Rho and Tau interfaces.
    if (unknownObject is Tau) {

        // Use the overloaded inc() operator from interface Rho.
        // In Kotlin 2.0.0, the type of unknownObject is smart-cast to
        // Sigma.
        ++unknownObject

        // In Kotlin 2.0.0, the compiler knows unknownObject has type
        // Sigma, so the sigma() function can be called successfully.
        unknownObject.sigma()

        // In Kotlin 1.9.20, the compiler doesn't perform a smart cast
        // when inc() is called so the compiler still thinks that 
        // unknownObject has type Tau. Calling the sigma() function 
        // throws a compile-time error.
        
        // In Kotlin 2.0.0, the compiler knows unknownObject has type
        // Sigma, so calling the tau() function throws a compile-time 
        // error.
        unknownObject.tau()
        // Unresolved reference 'tau'

        // In Kotlin 1.9.20, since the compiler mistakenly thinks that 
        // unknownObject has type Tau, the tau() function can be called,
        // but it throws a ClassCastException.
    }
}
</div></section></section><section class="chapter"><h3 id="kotlin-multiplatform" data-toc="kotlin-multiplatform">Kotlin Multiplatform</h3><p id="-td61vq_133">There are improvements in the K2 compiler related to Kotlin Multiplatform in the following areas:</p><ul class="list _bullet" id="-td61vq_134"><li class="list__item" id="-td61vq_137"><p id="-td61vq_139"><a href="#separation-of-common-and-platform-sources-during-compilation" id="-td61vq_140">Separation of common and platform sources during compilation</a></p></li><li class="list__item" id="-td61vq_138"><p id="-td61vq_141"><a href="#different-visibility-levels-of-expected-and-actual-declarations" id="-td61vq_142">Different visibility levels of expected and actual declarations</a></p></li></ul><section class="chapter"><h4 id="separation-of-common-and-platform-sources-during-compilation" data-toc="separation-of-common-and-platform-sources-during-compilation">Separation of common and platform sources during compilation</h4><p id="-td61vq_143">Previously, the design of the Kotlin compiler prevented it from keeping common and platform source sets separate at compile time. As a consequence, common code could access platform code, which resulted in different behavior between platforms. In addition, some compiler settings and dependencies from common code used to leak into platform code.</p><p id="-td61vq_144">In Kotlin 2.0.0, our implementation of the new Kotlin K2 compiler included a redesign of the compilation scheme to ensure strict separation between common and platform source sets. This change is most noticeable when you use <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html#expected-and-actual-functions" id="-td61vq_154" data-external="true" rel="noopener noreferrer" target="_blank">expected and actual functions</a>. Previously, it was possible for a function call in your common code to resolve to a function in platform code. For example:</p><div class="table-wrapper"><table class="wide" id="-td61vq_145"><thead><tr class="ijRowHead" id="-td61vq_155"><th id="-td61vq_157"><p>Common code</p></th><th id="-td61vq_158"><p>Platform code</p></th></tr></thead><tbody><tr id="-td61vq_156"><td id="-td61vq_159"><div class="code-block" data-lang="kotlin">
fun foo(x: Any) = println(&quot;common foo&quot;)

fun exampleFunction() {
    foo(42)
}
</div></td><td id="-td61vq_160"><div class="code-block" data-lang="kotlin">
// JVM
fun foo(x: Int) = println(&quot;platform foo&quot;)

// JavaScript
// There is no foo() function overload on the JavaScript platform
</div></td></tr></tbody></table></div><p id="-td61vq_146">In this example, the common code has different behavior depending on which platform it is run on:</p><ul class="list _bullet" id="-td61vq_147"><li class="list__item" id="-td61vq_163"><p id="-td61vq_165">On the JVM platform, calling the <code class="code" id="-td61vq_166">foo()</code> function in the common code results in the <code class="code" id="-td61vq_167">foo()</code> function from the platform code being called as <code class="code" id="-td61vq_168">platform foo</code>.</p></li><li class="list__item" id="-td61vq_164"><p id="-td61vq_169">On the JavaScript platform, calling the <code class="code" id="-td61vq_170">foo()</code> function in the common code results in the <code class="code" id="-td61vq_171">foo()</code> function from the common code being called as <code class="code" id="-td61vq_172">common foo</code>, as there is no such function available in the platform code.</p></li></ul><p id="-td61vq_148">In Kotlin 2.0.0, common code doesn't have access to platform code, so both platforms successfully resolve the <code class="code" id="-td61vq_173">foo()</code> function to the <code class="code" id="-td61vq_174">foo()</code> function in the common code: <code class="code" id="-td61vq_175">common foo</code>.</p><p id="-td61vq_149">In addition to the improved consistency of behavior across platforms, we also worked hard to fix cases where there was conflicting behavior between IntelliJ IDEA or Android Studio and the compiler. For instance, when you used <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html#expected-and-actual-classes" id="-td61vq_176" data-external="true" rel="noopener noreferrer" target="_blank">expected and actual classes</a>, the following would happen:</p><div class="table-wrapper"><table class="wide" id="-td61vq_150"><thead><tr class="ijRowHead" id="-td61vq_177"><th id="-td61vq_179"><p>Common code</p></th><th id="-td61vq_180"><p>Platform code</p></th></tr></thead><tbody><tr id="-td61vq_178"><td id="-td61vq_181"><div class="code-block" data-lang="kotlin">
expect class Identity {
    fun confirmIdentity(): String
}

fun common() {
    // Before 2.0.0, it triggers an IDE-only error
    Identity().confirmIdentity()
    // RESOLUTION_TO_CLASSIFIER : Expected class Identity has no default constructor.
}
</div></td><td id="-td61vq_182"><div class="code-block" data-lang="kotlin">
actual class Identity {
    actual fun confirmIdentity() = &quot;expect class fun: jvm&quot;
}
</div></td></tr></tbody></table></div><p id="-td61vq_151">In this example, the expected class <code class="code" id="-td61vq_185">Identity</code> has no default constructor, so it can't be called successfully in common code. Previously, an error was only reported by the IDE, but the code still compiled successfully on the JVM. However, now the compiler correctly reports an error:</p><div class="code-block" data-lang="none">
Expected class 'expect class Identity : Any' does not have default constructor
</div><section class="chapter"><h5 id="when-resolution-behavior-doesn-t-change" data-toc="when-resolution-behavior-doesn-t-change">When resolution behavior doesn't change</h5><p id="-td61vq_186">We're still in the process of migrating to the new compilation scheme, so the resolution behavior is still the same when you call functions that aren't within the same source set. You'll notice this difference mainly when you use overloads from a multiplatform library in your common code.</p><p id="-td61vq_187">Suppose you have a library, which has two <code class="code" id="-td61vq_195">whichFun()</code> functions with different signatures:</p><div class="code-block" data-lang="kotlin">
// Example library

// MODULE: common
fun whichFun(x: Any) = println(&quot;common function&quot;) 

// MODULE: JVM
fun whichFun(x: Int) = println(&quot;platform function&quot;)
</div><p id="-td61vq_189">If you call the <code class="code" id="-td61vq_196">whichFun()</code> function in your common code, the function that has the most relevant argument type in the library will be resolved:</p><div class="code-block" data-lang="kotlin">
// A project that uses the example library for the JVM target

// MODULE: common
fun main(){
    whichFun(2) 
    // platform function
}
</div><p id="-td61vq_191">In comparison, if you declare the overloads for <code class="code" id="-td61vq_197">whichFun()</code> within the same source set, the function from the common code will be resolved because your code doesn't have access to the platform-specific version:</p><div class="code-block" data-lang="kotlin">
// Example library isn't used

// MODULE: common
fun whichFun(x: Any) = println(&quot;common function&quot;) 

fun main(){
    whichFun(2) 
    // common function
}

// MODULE: JVM
fun whichFun(x: Int) = println(&quot;platform function&quot;)
</div><p id="-td61vq_193">Similar to multiplatform libraries, since the <code class="code" id="-td61vq_198">commonTest</code> module is in a separate source set, it also still has access to platform-specific code. Therefore, the resolution of calls to functions in the <code class="code" id="-td61vq_199">commonTest</code> module exhibits the same behavior as in the old compilation scheme.</p><p id="-td61vq_194">In the future, these remaining cases will be more consistent with the new compilation scheme.</p></section></section><section class="chapter"><h4 id="different-visibility-levels-of-expected-and-actual-declarations" data-toc="different-visibility-levels-of-expected-and-actual-declarations">Different visibility levels of expected and actual declarations</h4><p id="-td61vq_200">Before Kotlin 2.0.0, if you used <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html" id="-td61vq_204" data-external="true" rel="noopener noreferrer" target="_blank">expected and actual declarations</a> in your Kotlin Multiplatform project, they had to have the same <a href="visibility-modifiers.html" id="-td61vq_205">visibility level</a>. Kotlin 2.0.0 now also supports different visibility levels but <span class="control" id="-td61vq_206">only</span> if the actual declaration is <span class="emphasis" id="-td61vq_207">more</span> permissive than the expected declaration. For example:</p><div class="code-block" data-lang="kotlin">
expect internal class Attribute // Visibility is internal
actual class Attribute          // Visibility is public by default,
                                // which is more permissive
</div><p id="-td61vq_202">Similarly, if you are using a <a href="type-aliases.html" id="-td61vq_208">type alias</a> in your actual declaration, the visibility of the <span class="control" id="-td61vq_209">underlying type</span> should be the same or more permissive than the expected declaration. For example:</p><div class="code-block" data-lang="kotlin">
expect internal class Attribute                 // Visibility is internal
internal actual typealias Attribute = Expanded

class Expanded                                  // Visibility is public by default,
                                                // which is more permissive
</div></section></section></section><section class="chapter"><h2 id="how-to-enable-the-kotlin-k2-compiler" data-toc="how-to-enable-the-kotlin-k2-compiler">How to enable the Kotlin K2 compiler</h2><p id="-td61vq_210">Starting with Kotlin 2.0.0, the Kotlin K2 compiler is enabled by default.</p><p id="-td61vq_211">To upgrade the Kotlin version, change it to 2.0.0 or a later release in your <a href="gradle-configure-project.html#apply-the-plugin" id="-td61vq_214">Gradle</a> and <a href="maven.html#configure-and-enable-the-plugin" id="-td61vq_215">Maven</a> build scripts.</p><p id="-td61vq_212">To have the best experience with IntelliJ IDEA or Android Studio, consider <a href="#support-in-ides" id="-td61vq_216">enabling K2 mode</a> in your IDE.</p><section class="chapter"><h3 id="use-kotlin-build-reports-with-gradle" data-toc="use-kotlin-build-reports-with-gradle">Use Kotlin build reports with Gradle</h3><p id="-td61vq_217">Kotlin <a href="gradle-compilation-and-caches.html#build-reports" id="-td61vq_219">build reports</a> provide information about the time spent in different compilation phases for Kotlin compiler tasks, as well as which compiler and Kotlin version were used, and whether the compilation was incremental. These build reports are useful for assessing your build performance. They offer more insight into the Kotlin compilation pipeline than <a href="https://scans.gradle.com/" id="-td61vq_220" data-external="true" rel="noopener noreferrer" target="_blank">Gradle build scans</a> do because they give you an overview of the performance of all Gradle tasks.</p><section class="chapter"><h4 id="how-to-enable-build-reports" data-toc="how-to-enable-build-reports">How to enable build reports</h4><p id="-td61vq_221">To enable build reports, declare where you'd like to save the build report output in your <code class="code" id="-td61vq_226">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.build.report.output=file
</div><p id="-td61vq_223">The following values and their combinations are available for the output:</p><div class="table-wrapper"><table class="wide" id="-td61vq_224"><thead><tr class="ijRowHead" id="-td61vq_227"><th id="-td61vq_233"><p>Option</p></th><th id="-td61vq_234"><p>Description</p></th></tr></thead><tbody><tr id="-td61vq_228"><td id="-td61vq_235"><p><code class="code" id="-td61vq_237">file</code></p></td><td id="-td61vq_236"><p>Saves build reports in a human-readable format to a local file. By default, it's <code class="code" id="-td61vq_238">${project_folder}/build/reports/kotlin-build/${project_name}-timestamp.txt</code></p></td></tr><tr id="-td61vq_229"><td id="-td61vq_239"><p><code class="code" id="-td61vq_241">single_file</code></p></td><td id="-td61vq_240"><p>Saves build reports in a format of an object to a specified local file.</p></td></tr><tr id="-td61vq_230"><td id="-td61vq_242"><p><code class="code" id="-td61vq_244">build_scan</code></p></td><td id="-td61vq_243"><p>Saves build reports in the <code class="code" id="-td61vq_245">custom values</code> section of the <a href="https://scans.gradle.com/" id="-td61vq_246" data-external="true" rel="noopener noreferrer" target="_blank">build scan</a>. Note that the Gradle Enterprise plugin limits the number of custom values and their length. In big projects, some values could be lost.</p></td></tr><tr id="-td61vq_231"><td id="-td61vq_247"><p><code class="code" id="-td61vq_249">http</code></p></td><td id="-td61vq_248"><p>Posts build reports using HTTP(S). The POST method sends metrics in JSON format. You can see the current version of the sent data in the <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/report/data/GradleCompileStatisticsData.kt" id="-td61vq_250" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin repository</a>. You can find samples of HTTP endpoints in <a href="https://blog.jetbrains.com/kotlin/2022/06/introducing-kotlin-build-reports/?_gl=1*1a7pghy*_ga*MTcxMjc1NzE5Ny4xNjY1NDAzNjkz*_ga_9J976DJZ68*MTcxNTA3NjA2NS4zNzcuMS4xNzE1MDc2MDc5LjQ2LjAuMA..&amp;_ga=2.265800911.1124071296.1714976764-1712757197.1665403693#enable_build_reports" id="-td61vq_251" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a></p></td></tr><tr id="-td61vq_232"><td id="-td61vq_252"><p><code class="code" id="-td61vq_254">json</code></p></td><td id="-td61vq_253"><p>Saves build reports in JSON format to a local file. Set the location for your build reports in <code class="code" id="-td61vq_255">kotlin.build.report.json.directory</code>. By default, it's name is <code class="code" id="-td61vq_256">${project_name}-build-&lt;date-time&gt;-&lt;index&gt;.json</code>.</p></td></tr></tbody></table></div><p id="-td61vq_225">For more information on what is possible with build reports, see <a href="gradle-compilation-and-caches.html#build-reports" id="-td61vq_257">Build reports</a>.</p></section></section></section><section class="chapter"><h2 id="support-in-ides" data-toc="support-in-ides">Support in IDEs</h2><p id="-td61vq_258">K2 mode in IntelliJ IDEA and Android Studio uses the K2 compiler to improve code analysis, code completion, and highlighting.</p><p id="-td61vq_259">Starting with IntelliJ IDEA 2025.1, K2 mode is <a href="https://blog.jetbrains.com/idea/2025/04/k2-mode-in-intellij-idea-2025-1-current-state-and-faq/" id="-td61vq_263" data-external="true" rel="noopener noreferrer" target="_blank">enabled by default</a>.</p><p id="-td61vq_260">In Android Studio, you can enable K2 mode starting with 2024.1 by following these steps:</p><ol class="list _decimal" id="-td61vq_261" type="1"><li class="list__item" id="-td61vq_264"><p id="-td61vq_266">Go to <span class="control" id="-td61vq_267">Settings</span> | <span class="control" id="-td61vq_268">Languages &amp; Frameworks</span> | <span class="control" id="-td61vq_269">Kotlin</span>.</p></li><li class="list__item" id="-td61vq_265"><p id="-td61vq_270">Select the <span class="control" id="-td61vq_271">Enable K2 mode</span> option.</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="previous-ide-behavior" data-toc="previous-ide-behavior">Previous IDE behavior</h3></div><div class="collapse__content"><p id="-td61vq_272">If you want to go back to the previous IDE behavior, you can disable K2 mode:</p><ol class="list _decimal" id="-td61vq_273" type="1"><li class="list__item" id="-td61vq_275"><p id="-td61vq_277">Go to <span class="control" id="-td61vq_278">Settings</span> | <span class="control" id="-td61vq_279">Languages &amp; Frameworks</span> | <span class="control" id="-td61vq_280">Kotlin</span>.</p></li><li class="list__item" id="-td61vq_276"><p id="-td61vq_281">Deselect the <span class="control" id="-td61vq_282">Enable K2 mode</span> option.</p></li></ol><aside class="prompt" data-type="note" data-title="" id="-td61vq_274"><p id="-td61vq_283">We plan to introduce <a href="components-stability.html#stability-levels-explained" id="-td61vq_284">Stable</a> language features after Kotlin 2.1.0. Until then, you can continue to use the previous IDE features for code analysis, and you won't encounter any code highlighting issues due to unrecognized language features.</p></aside></div></div></section></section><section class="chapter"><h2 id="try-the-kotlin-k2-compiler-in-the-kotlin-playground" data-toc="try-the-kotlin-k2-compiler-in-the-kotlin-playground">Try the Kotlin K2 compiler in the Kotlin Playground</h2><p id="-td61vq_285">The Kotlin Playground supports Kotlin 2.0.0 and later releases. <a href="https://pl.kotl.in/czuoQprce" id="-td61vq_286" data-external="true" rel="noopener noreferrer" target="_blank">Check it out!</a></p></section><section class="chapter"><h2 id="how-to-roll-back-to-the-previous-compiler" data-toc="how-to-roll-back-to-the-previous-compiler">How to roll back to the previous compiler</h2><p id="-td61vq_287">To use the previous compiler in Kotlin 2.0.0 and later releases, either:</p><ul class="list _bullet" id="-td61vq_288"><li class="list__item" id="-td61vq_289"><p id="-td61vq_291">In your <code class="code" id="-td61vq_293">build.gradle.kts</code> file, <a href="gradle-compiler-options.html#example-of-setting-languageversion" id="-td61vq_294">set your language version</a> to <code class="code" id="-td61vq_295">1.9</code>.</p><p id="-td61vq_292">OR</p></li><li class="list__item" id="-td61vq_290"><p id="-td61vq_296">Use the following compiler option: <code class="code" id="-td61vq_297">-language-version 1.9</code>.</p></li></ul></section><section class="chapter"><h2 id="changes" data-toc="changes">Changes</h2><p id="-td61vq_298">With the introduction of the new frontend, the Kotlin compiler has undergone several changes. Let's start by highlighting the most significant modifications affecting your code, explaining what has changed and detailing best practices going forward. If you'd like to learn more, we've organized these changes into <a href="#per-subject-area" id="-td61vq_308">subject areas</a> to facilitate your further reading.</p><p id="-td61vq_299">This section highlights the following modifications:</p><ul class="list _bullet" id="-td61vq_300"><li class="list__item" id="-td61vq_309"><p id="-td61vq_315"><a href="#immediate-initialization-of-open-properties-with-backing-fields" id="-td61vq_316">Immediate initialization of open properties with backing fields</a></p></li><li class="list__item" id="-td61vq_310"><p id="-td61vq_317"><a href="#deprecated-synthetics-setter-on-a-projected-receiver" id="-td61vq_318">Deprecated synthetic setters on a projected receiver</a></p></li><li class="list__item" id="-td61vq_311"><p id="-td61vq_319"><a href="#forbidden-use-of-inaccessible-generic-types" id="-td61vq_320">Forbidden use of inaccessible generic types</a></p></li><li class="list__item" id="-td61vq_312"><p id="-td61vq_321"><a href="#consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name" id="-td61vq_322">Consistent resolution order of Kotlin properties and Java fields with the same name</a></p></li><li class="list__item" id="-td61vq_313"><p id="-td61vq_323"><a href="#improved-null-safety-for-java-primitive-arrays" id="-td61vq_324">Improved null safety for Java primitive arrays</a></p></li><li class="list__item" id="-td61vq_314"><p id="-td61vq_325"><a href="#stricter-rules-for-abstract-members-in-expected-classes" id="-td61vq_326">Stricter rules for abstract members in expected classes</a></p></li></ul><section class="chapter"><h3 id="immediate-initialization-of-open-properties-with-backing-fields" data-toc="immediate-initialization-of-open-properties-with-backing-fields">Immediate initialization of open properties with backing fields</h3><p id="-td61vq_327"><span class="control" id="-td61vq_337">What's changed?</span></p><p id="-td61vq_328">In Kotlin 2.0, all <code class="code" id="-td61vq_338">open</code> properties with backing fields must be immediately initialized; otherwise, you'll get a compilation error. Previously, only <code class="code" id="-td61vq_339">open var</code> properties needed to be initialized right away, but now this extends to <code class="code" id="-td61vq_340">open val</code> properties with backing fields too:</p><div class="code-block" data-lang="kotlin">
open class Base {
    open val a: Int
    open var b: Int
    
    init {
        // Error starting with Kotlin 2.0 that earlier compiled successfully 
        this.a = 1 //Error: open val must have initializer
        // Always an error
        this.b = 1 // Error: open var must have initializer
    }
}

class Derived : Base() {
    override val a: Int = 2
    override var b = 2
}
</div><p id="-td61vq_330">This change makes the compiler's behavior more predictable. Consider an example where an <code class="code" id="-td61vq_341">open val</code> property is overridden by a <code class="code" id="-td61vq_342">var</code> property with a custom setter.</p><p id="-td61vq_331">If a custom setter is used, deferred initialization can lead to confusion because it's unclear whether you want to initialize the backing field or to invoke the setter. In the past, if you wanted to invoke the setter, the old compiler couldn't guarantee that the setter would then initialize the backing field.</p><p id="-td61vq_332"><span class="control" id="-td61vq_343">What's the best practice now?</span></p><p id="-td61vq_333">We encourage you to always initialize open properties with backing fields, as we believe this practice is both more efficient and less error-prone.</p><p id="-td61vq_334">However, if you don't want to immediately initialize a property, you can:</p><ul class="list _bullet" id="-td61vq_335"><li class="list__item" id="-td61vq_344"><p id="-td61vq_346">Make the property <code class="code" id="-td61vq_347">final</code>.</p></li><li class="list__item" id="-td61vq_345"><p id="-td61vq_348">Use a private backing property that allows for deferred initialization.</p></li></ul><p id="-td61vq_336">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-57555" id="-td61vq_349" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section><section class="chapter"><h3 id="deprecated-synthetics-setter-on-a-projected-receiver" data-toc="deprecated-synthetics-setter-on-a-projected-receiver">Deprecated synthetics setter on a projected receiver</h3><p id="-td61vq_350"><span class="control" id="-td61vq_359">What's changed?</span></p><p id="-td61vq_351">If you use the synthetic setter of a Java class to assign a type that conflicts with the class's projected type, an error is triggered.</p><p id="-td61vq_352">Suppose you have a Java class named <code class="code" id="-td61vq_360">Container</code> that contains the <code class="code" id="-td61vq_361">getFoo()</code> and <code class="code" id="-td61vq_362">setFoo()</code> methods:</p><div class="code-block" data-lang="java">
public class Container&lt;E&gt; {
    public E getFoo() {
        return null;
    }
    public void setFoo(E foo) {}
}
</div><p id="-td61vq_354">If you have the following Kotlin code, where instances of the <code class="code" id="-td61vq_363">Container</code> class have projected types, using the <code class="code" id="-td61vq_364">setFoo()</code> method will always generate an error. However, only from Kotlin 2.0.0 will the synthetic <code class="code" id="-td61vq_365">foo</code> property trigger an error:</p><div class="code-block" data-lang="kotlin">
fun exampleFunction(starProjected: Container&lt;*&gt;, inProjected: Container&lt;in Number&gt;, sampleString: String) {
    starProjected.setFoo(sampleString)
    // Error since Kotlin 1.0

    // Synthetic setter `foo` is resolved to the `setFoo()` method
    starProjected.foo = sampleString
    // Error since Kotlin 2.0.0

    inProjected.setFoo(sampleString)
    // Error since Kotlin 1.0

    // Synthetic setter `foo` is resolved to the `setFoo()` method
    inProjected.foo = sampleString
    // Error since Kotlin 2.0.0
}
</div><p id="-td61vq_356"><span class="control" id="-td61vq_366">What's the best practice now?</span></p><p id="-td61vq_357">If you see that this change introduces errors in your code, you might wish to reconsider how you structure your type declarations. It could be that you don't need to use type projections, or perhaps you need to remove any assignments from your code.</p><p id="-td61vq_358">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-54309" id="-td61vq_367" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section><section class="chapter"><h3 id="forbidden-use-of-inaccessible-generic-types" data-toc="forbidden-use-of-inaccessible-generic-types">Forbidden use of inaccessible generic types</h3><p id="-td61vq_368"><span class="control" id="-td61vq_390">What's changed?</span></p><p id="-td61vq_369">Due to the new architecture of our K2 compiler, we've changed how we handle inaccessible generic types. Generally, you should never rely on inaccessible generic types in your code because this indicates a misconfiguration in your project's build configuration, preventing the compiler from accessing the necessary information to compile. In Kotlin 2.0.0, you can't declare or call a function literal with an inaccessible generic type, nor use a generic type with inaccessible generic type arguments. This restriction helps you avoid compiler errors later in your code.</p><p id="-td61vq_370">For example, let's say that you declared a generic class in one module:</p><div class="code-block" data-lang="kotlin">
// Module one
class Node&lt;V&gt;(val value: V)
</div><p id="-td61vq_372">If you have another module (module two) with a dependency configured on module one, your code can access the <code class="code" id="-td61vq_391">Node&lt;V&gt;</code> class and use it as a type in function types:</p><div class="code-block" data-lang="kotlin">
// Module two
fun execute(func: (Node&lt;Int&gt;) -&gt; Unit) {}
// Function compiles successfully
</div><p id="-td61vq_374">However, if your project is misconfigured such that you have a third module (module three) that depends only on module two, the Kotlin compiler won't be able to access the <code class="code" id="-td61vq_392">Node&lt;V&gt;</code> class in <span class="control" id="-td61vq_393">module one</span> when compiling the third module. Now, any lambdas or anonymous functions in module three that use the <code class="code" id="-td61vq_394">Node&lt;V&gt;</code> type trigger errors in Kotlin 2.0.0, thus preventing avoidable compiler errors, crashes, and run-time exceptions later in your code:</p><div class="code-block" data-lang="kotlin">
// Module three
fun test() {
    // Triggers an error in Kotlin 2.0.0, as the type of the implicit 
    // lambda parameter (it) resolves to Node, which is inaccessible
    execute {}

    // Triggers an error in Kotlin 2.0.0, as the type of the unused 
    // lambda parameter (_) resolves to Node, which is inaccessible
    execute { _ -&gt; }

    // Triggers an error in Kotlin 2.0.0, as the type of the unused
    // anonymous function parameter (_) resolves to Node, which is inaccessible
    execute(fun (_) {})
}
</div><p id="-td61vq_376">In addition to function literals triggering errors when they contain value parameters of inaccessible generic types, errors also occur when a type has an inaccessible generic type argument.</p><p id="-td61vq_377">For example, you have the same generic class declaration in module one. In module two, you declare another generic class: <code class="code" id="-td61vq_395">Container&lt;C&gt;</code>. In addition, you declare functions in module two that use <code class="code" id="-td61vq_396">Container&lt;C&gt;</code> with generic class <code class="code" id="-td61vq_397">Node&lt;V&gt;</code> as a type argument:</p><div class="table-wrapper"><table class="wide" id="-td61vq_378"><thead><tr class="ijRowHead" id="-td61vq_398"><th id="-td61vq_400"><p>Module one</p></th><th id="-td61vq_401"><p>Module two</p></th></tr></thead><tbody><tr id="-td61vq_399"><td id="-td61vq_402"><div class="code-block" data-lang="kotlin">
// Module one
class Node&lt;V&gt;(val value: V)
</div></td><td id="-td61vq_403"><div class="code-block" data-lang="kotlin">
// Module two
class Container&lt;C&gt;(vararg val content: C)

// Functions with generic class type that
// also have a generic class type argument
fun produce(): Container&lt;Node&lt;Int&gt;&gt; = Container(Node(42))
fun consume(arg: Container&lt;Node&lt;Int&gt;&gt;) {}
</div></td></tr></tbody></table></div><p id="-td61vq_379">If you try to call these functions in module three, an error is triggered in Kotlin 2.0.0 because the generic class <code class="code" id="-td61vq_406">Node&lt;V&gt;</code> is inaccessible from module three:</p><div class="code-block" data-lang="kotlin">
// Module three
fun test() {
    // Triggers an error in Kotlin 2.0.0, as generic class Node&lt;V&gt; is 
    // inaccessible
    consume(produce())
}
</div><p id="-td61vq_381">In future releases we will continue to deprecate the use of inaccessible types in general. We have already started in Kotlin 2.0.0 by adding warnings for some scenarios with inaccessible types, including non-generic ones.</p><p id="-td61vq_382">For example, let's use the same module setup as the previous examples, but turn the generic class <code class="code" id="-td61vq_407">Node&lt;V&gt;</code> into a non-generic class <code class="code" id="-td61vq_408">IntNode</code>, with all functions declared in module two:</p><div class="table-wrapper"><table class="wide" id="-td61vq_383"><thead><tr class="ijRowHead" id="-td61vq_409"><th id="-td61vq_411"><p>Module one</p></th><th id="-td61vq_412"><p>Module two</p></th></tr></thead><tbody><tr id="-td61vq_410"><td id="-td61vq_413"><div class="code-block" data-lang="kotlin">
// Module one
class IntNode(val value: Int)
</div></td><td id="-td61vq_414"><div class="code-block" data-lang="kotlin">
// Module two
// A function that contains a lambda 
// parameter with `IntNode` type
fun execute(func: (IntNode) -&gt; Unit) {}

class Container&lt;C&gt;(vararg val content: C)

// Functions with generic class type
// that has `IntNode` as a type argument
fun produce(): Container&lt;IntNode&gt; = Container(IntNode(42))
fun consume(arg: Container&lt;IntNode&gt;) {}
</div></td></tr></tbody></table></div><p id="-td61vq_384">If you call these functions in module three, some warnings are triggered:</p><div class="code-block" data-lang="kotlin">
// Module three
fun test() {
    // Triggers warnings in Kotlin 2.0.0, as class IntNode is 
    // inaccessible.

    execute {}
    // Class 'IntNode' of the parameter 'it' is inaccessible.

    execute { _ -&gt; }
    execute(fun (_) {})
    // Class 'IntNode' of the parameter '_' is inaccessible.

    // Will trigger a warning in future Kotlin releases, as IntNode is
    // inaccessible.
    consume(produce())
}
</div><p id="-td61vq_386"><span class="control" id="-td61vq_417">What's the best practice now?</span></p><p id="-td61vq_387">If you encounter new warnings regarding inaccessible generic types, it's highly likely that there's an issue with your build system configuration. We recommend checking your build scripts and configuration.</p><p id="-td61vq_388">As a last resort, you can configure a direct dependency for module three on module one. Alternatively, you can modify your code to make the types accessible within the same module.</p><p id="-td61vq_389">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-64474" id="-td61vq_418" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section><section class="chapter"><h3 id="consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name" data-toc="consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name">Consistent resolution order of Kotlin properties and Java fields with the same name</h3><p id="-td61vq_419"><span class="control" id="-td61vq_437">What's changed?</span></p><p id="-td61vq_420">Before Kotlin 2.0.0, if you worked with Java and Kotlin classes that inherited from each other and contained Kotlin properties and Java fields with the same name, the resolution behavior of the duplicated name was inconsistent. There was also conflicting behavior between IntelliJ IDEA and the compiler. When developing the new resolution behavior for Kotlin 2.0.0, we aimed to cause the least impact to users.</p><p id="-td61vq_421">For example, suppose there is a Java class <code class="code" id="-td61vq_438">Base</code>:</p><div class="code-block" data-lang="java">
public class Base {
    public String a = &quot;a&quot;;

    public String b = &quot;b&quot;;
}
</div><p id="-td61vq_423">Let's say there is also a Kotlin class <code class="code" id="-td61vq_439">Derived</code> that inherits from the aforementioned <code class="code" id="-td61vq_440">Base</code> class:</p><div class="code-block" data-lang="kotlin">
class Derived : Base() {
    val a = &quot;aa&quot;

    // Declares custom get() function
    val b get() = &quot;bb&quot;
}

fun main() {
    // Resolves Derived.a
    println(a)
    // aa

    // Resolves Base.b
    println(b)
    // b
}
</div><p id="-td61vq_425">Prior to Kotlin 2.0.0, <code class="code" id="-td61vq_441">a</code> resolves to the Kotlin property within the <code class="code" id="-td61vq_442">Derived</code> Kotlin class, whereas <code class="code" id="-td61vq_443">b</code> resolves to the Java field in the <code class="code" id="-td61vq_444">Base</code> Java class.</p><p id="-td61vq_426">In Kotlin 2.0.0, the resolution behavior in the example is consistent, ensuring that the Kotlin property supersedes the Java field of the same name. Now, <code class="code" id="-td61vq_445">b</code> resolves to: <code class="code" id="-td61vq_446">Derived.b</code>.</p><aside class="prompt" data-type="note" data-title="" id="-td61vq_427"><p id="-td61vq_447">Prior to Kotlin 2.0.0, if you used IntelliJ IDEA to go to the declaration or usage of <code class="code" id="-td61vq_449">a</code>, it would incorrectly navigate to the Java field when it should have navigated to the Kotlin property.</p><p id="-td61vq_448">From Kotlin 2.0.0, IntelliJ IDEA correctly navigates to the same location as the compiler.</p></aside><p id="-td61vq_428">The general rule is that the subclass takes precedence. The previous example demonstrates this, as the Kotlin property <code class="code" id="-td61vq_450">a</code> from the <code class="code" id="-td61vq_451">Derived</code> class is resolved because <code class="code" id="-td61vq_452">Derived</code> is a subclass of the <code class="code" id="-td61vq_453">Base</code> Java class.</p><p id="-td61vq_429">In the event that the inheritance is reversed and a Java class inherits from a Kotlin class, the Java field in the subclass takes precedence over the Kotlin property with the same name.</p><p id="-td61vq_430">Consider this example:</p><div class="table-wrapper"><table class="wide" id="-td61vq_431"><thead><tr class="ijRowHead" id="-td61vq_454"><th id="-td61vq_456"><p>Kotlin</p></th><th id="-td61vq_457"><p>Java</p></th></tr></thead><tbody><tr id="-td61vq_455"><td id="-td61vq_458"><div class="code-block" data-lang="kotlin">
open class Base {
    val a = &quot;aa&quot;
}
</div></td><td id="-td61vq_459"><div class="code-block" data-lang="java">
public class Derived extends Base {
    public String a = &quot;a&quot;;
}
</div></td></tr></tbody></table></div><p id="-td61vq_432">Now in the following code:</p><div class="code-block" data-lang="kotlin">
fun main() {
    // Resolves Derived.a
    println(a)
    // a
}
</div><p id="-td61vq_434"><span class="control" id="-td61vq_462">What's the best practice now?</span></p><p id="-td61vq_435">If this change affects your code, consider whether you really need to use duplicate names. If you want to have Java or Kotlin classes that each contain a field or property with the same name and that each inherit from one another, keep in mind that the field or property in the subclass will take precedence.</p><p id="-td61vq_436">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-55017" id="-td61vq_463" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section><section class="chapter"><h3 id="improved-null-safety-for-java-primitive-arrays" data-toc="improved-null-safety-for-java-primitive-arrays">Improved null safety for Java primitive arrays</h3><p id="-td61vq_464"><span class="control" id="-td61vq_477">What's changed?</span></p><p id="-td61vq_465">Starting with Kotlin 2.0.0, the compiler correctly infers the nullability of Java primitive arrays imported to Kotlin. Now, it retains native nullability from the <code class="code" id="-td61vq_478">TYPE_USE</code> annotations used with Java primitive arrays and emits errors when their values are not used according to annotations.</p><p id="-td61vq_466">Usually, when Java types with <code class="code" id="-td61vq_479">@Nullable</code> and <code class="code" id="-td61vq_480">@NotNull</code> annotations are called from Kotlin, they receive the appropriate native nullability:</p><div class="code-block" data-lang="java">
interface DataService {
    @NotNull ResultContainer&lt;@Nullable String&gt; fetchData();
}
</div><div class="code-block" data-lang="kotlin">
val dataService: DataService = ... 
dataService.fetchData() // -&gt; ResultContainer&lt;String?&gt;
</div><p id="-td61vq_469">Previously, however, when Java primitive arrays were imported to Kotlin, all <code class="code" id="-td61vq_481">TYPE_USE</code> annotations were lost, resulting in platform nullability and possibly unsafe code:</p><div class="code-block" data-lang="java">
interface DataProvider {
    int @Nullable [] fetchData();
}
</div><div class="code-block" data-lang="kotlin">
val dataService: DataProvider = ...
dataService.fetchData() // -&gt; IntArray .. IntArray?
// No error, even though `dataService.fetchData()` might be `null` according to annotations
// This might result in a NullPointerException
dataService.fetchData()[0]
</div><p id="-td61vq_472">Note that this issue never affected nullability annotations on the declaration itself, only the <code class="code" id="-td61vq_482">TYPE_USE</code> ones.</p><p id="-td61vq_473"><span class="control" id="-td61vq_483">What's the best practice now?</span></p><p id="-td61vq_474">In Kotlin 2.0.0, null safety for Java primitive arrays is now standard in Kotlin, so check your code for new warnings and errors if you use them:</p><ul class="list _bullet" id="-td61vq_475"><li class="list__item" id="-td61vq_484"><p id="-td61vq_486">Any code that uses a <code class="code" id="-td61vq_487">@Nullable</code> Java primitive array without an explicit nullability check or attempts to pass <code class="code" id="-td61vq_488">null</code> to a Java method expecting a non-nullable primitive array will now fail to compile.</p></li><li class="list__item" id="-td61vq_485"><p id="-td61vq_489">Using a <code class="code" id="-td61vq_490">@NotNull</code> primitive array with a nullability check now emits &quot;Unnecessary safe call&quot; or &quot;Comparison with null always false&quot; warnings.</p></li></ul><p id="-td61vq_476">For more information, see the <a href="https://youtrack.jetbrains.com/issue/KT-54521" id="-td61vq_491" data-external="true" rel="noopener noreferrer" target="_blank">corresponding issue in YouTrack</a>.</p></section><section class="chapter"><h3 id="stricter-rules-for-abstract-members-in-expected-classes" data-toc="stricter-rules-for-abstract-members-in-expected-classes">Stricter rules for abstract members in expected classes</h3><aside class="prompt" data-type="warning" data-title="" id="-td61vq_492"><p id="-td61vq_503">Expected and actual classes are in <a href="components-stability.html#stability-levels-explained" id="-td61vq_504">Beta</a>. They are almost stable, but you may need to perform migration steps in the future. We'll do our best to minimize any further changes for you to make.</p></aside><p id="-td61vq_493"><span class="control" id="-td61vq_505">What's changed?</span></p><p id="-td61vq_494">Due to the separation of common and platform sources during compilation with the K2 compiler, we've implemented stricter rules for abstract members in expected classes.</p><p id="-td61vq_495">With the previous compiler, it was possible for an expected non-abstract class to inherit an abstract function without <a href="inheritance.html#overriding-rules" id="-td61vq_506">overriding the function</a>. Since the compiler could access both common and platform code at the same time, the compiler could see whether the abstract function had a corresponding override and definition in the actual class.</p><p id="-td61vq_496">Now that common and platform sources are compiled separately, the inherited function must be explicitly overridden in the expected class so that the compiler knows the function is not abstract. Otherwise, the compiler reports an <code class="code" id="-td61vq_507">ABSTRACT_MEMBER_NOT_IMPLEMENTED</code> error.</p><p id="-td61vq_497">For example, let's say you have a common source set where you declare an abstract class called <code class="code" id="-td61vq_508">FileSystem</code> that has an abstract function <code class="code" id="-td61vq_509">listFiles()</code>. You define the <code class="code" id="-td61vq_510">listFiles()</code> function in the platform source set as part of an actual declaration.</p><p id="-td61vq_498">In your common code, if you have an expected non-abstract class called <code class="code" id="-td61vq_511">PlatformFileSystem</code> that inherits from the <code class="code" id="-td61vq_512">FileSystem</code> class, the <code class="code" id="-td61vq_513">PlatformFileSystem</code> class inherits the abstract function <code class="code" id="-td61vq_514">listFiles()</code>. However, you can't have an abstract function in a non-abstract class in Kotlin. To make the <code class="code" id="-td61vq_515">listFiles()</code> function non-abstract, you must declare it as an override without the <code class="code" id="-td61vq_516">abstract</code> keyword:</p><div class="table-wrapper"><table class="wide" id="-td61vq_499"><thead><tr class="ijRowHead" id="-td61vq_517"><th id="-td61vq_519"><p>Common code</p></th><th id="-td61vq_520"><p>Platform code</p></th></tr></thead><tbody><tr id="-td61vq_518"><td id="-td61vq_521"><div class="code-block" data-lang="kotlin">
abstract class FileSystem {
    abstract fun listFiles()
}
expect open class PlatformFileSystem() : FileSystem {
    // In Kotlin 2.0.0, an explicit override is needed
    expect override fun listFiles()
    // Before Kotlin 2.0.0, an override wasn't needed
}
</div></td><td id="-td61vq_522"><div class="code-block" data-lang="kotlin">
actual open class PlatformFileSystem : FileSystem {
    actual override fun listFiles() {}
}
</div></td></tr></tbody></table></div><p id="-td61vq_500"><span class="control" id="-td61vq_525">What's the best practice now?</span></p><p id="-td61vq_501">If you inherit abstract functions in an expected non-abstract class, add a non-abstract override.</p><p id="-td61vq_502">For more information, see the corresponding issue in <a href="https://youtrack.jetbrains.com/issue/KT-59739/K2-MPP-reports-ABSTRACTMEMBERNOTIMPLEMENTED-for-inheritor-in-common-code-when-the-implementation-is-located-in-the-actual" id="-td61vq_526" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="per-subject-area" data-toc="per-subject-area">Per subject area</h3><p id="-td61vq_527">These subject areas list changes that are unlikely to affect your code but provide links to the relevant YouTrack issues for further reading. Changes listed with an asterisk (*) next to the Issue ID are explained at the beginning of the section.</p><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="type-inference" data-toc="type-inference">Type inference</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_541"><thead><tr class="ijRowHead" id="-td61vq_542"><th id="-td61vq_559"><p>Issue ID</p></th><th id="-td61vq_560"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_543"><td id="-td61vq_561"><p><a href="https://youtrack.jetbrains.com/issue/KT-64189" id="-td61vq_563" data-external="true" rel="noopener noreferrer" target="_blank">KT-64189</a></p></td><td id="-td61vq_562"><p>Incorrect type in compiled function signature of property reference if the type is Normal explicitly</p></td></tr><tr id="-td61vq_544"><td id="-td61vq_564"><p><a href="https://youtrack.jetbrains.com/issue/KT-47986" id="-td61vq_566" data-external="true" rel="noopener noreferrer" target="_blank">KT-47986</a></p></td><td id="-td61vq_565"><p>Forbid implicit inferring a type variable into an upper bound in the builder inference context</p></td></tr><tr id="-td61vq_545"><td id="-td61vq_567"><p><a href="https://youtrack.jetbrains.com/issue/KT-59275" id="-td61vq_569" data-external="true" rel="noopener noreferrer" target="_blank">KT-59275</a></p></td><td id="-td61vq_568"><p>K2: Require explicit type arguments for generic annotation calls in array literals</p></td></tr><tr id="-td61vq_546"><td id="-td61vq_570"><p><a href="https://youtrack.jetbrains.com/issue/KT-53752" id="-td61vq_572" data-external="true" rel="noopener noreferrer" target="_blank">KT-53752</a></p></td><td id="-td61vq_571"><p>Missed subtyping check for an intersection type</p></td></tr><tr id="-td61vq_547"><td id="-td61vq_573"><p><a href="https://youtrack.jetbrains.com/issue/KT-59138" id="-td61vq_575" data-external="true" rel="noopener noreferrer" target="_blank">KT-59138</a></p></td><td id="-td61vq_574"><p>Change Java type parameter based types default representation in Kotlin</p></td></tr><tr id="-td61vq_548"><td id="-td61vq_576"><p><a href="https://youtrack.jetbrains.com/issue/KT-57178" id="-td61vq_578" data-external="true" rel="noopener noreferrer" target="_blank">KT-57178</a></p></td><td id="-td61vq_577"><p>Change inferred type of prefix increment to return type of getter instead of return type of inc() operator</p></td></tr><tr id="-td61vq_549"><td id="-td61vq_579"><p><a href="https://youtrack.jetbrains.com/issue/KT-57609" id="-td61vq_581" data-external="true" rel="noopener noreferrer" target="_blank">KT-57609</a></p></td><td id="-td61vq_580"><p>K2: Stop relying on the presence of @UnsafeVariance using for contravariant parameters</p></td></tr><tr id="-td61vq_550"><td id="-td61vq_582"><p><a href="https://youtrack.jetbrains.com/issue/KT-57620" id="-td61vq_584" data-external="true" rel="noopener noreferrer" target="_blank">KT-57620</a></p></td><td id="-td61vq_583"><p>K2: Forbid resolution to subsumed members for raw types</p></td></tr><tr id="-td61vq_551"><td id="-td61vq_585"><p><a href="https://youtrack.jetbrains.com/issue/KT-64641" id="-td61vq_587" data-external="true" rel="noopener noreferrer" target="_blank">KT-64641</a></p></td><td id="-td61vq_586"><p>K2: Properly inferred type of callable reference to a callable with extension-function parameter</p></td></tr><tr id="-td61vq_552"><td id="-td61vq_588"><p><a href="https://youtrack.jetbrains.com/issue/KT-57011" id="-td61vq_590" data-external="true" rel="noopener noreferrer" target="_blank">KT-57011</a></p></td><td id="-td61vq_589"><p>Make real type of a destructuring variable consistent with explicit type when specified</p></td></tr><tr id="-td61vq_553"><td id="-td61vq_591"><p><a href="https://youtrack.jetbrains.com/issue/KT-38895" id="-td61vq_593" data-external="true" rel="noopener noreferrer" target="_blank">KT-38895</a></p></td><td id="-td61vq_592"><p>K2: Fix inconsistent behavior with integer literals overflow</p></td></tr><tr id="-td61vq_554"><td id="-td61vq_594"><p><a href="https://youtrack.jetbrains.com/issue/KT-54862" id="-td61vq_596" data-external="true" rel="noopener noreferrer" target="_blank">KT-54862</a></p></td><td id="-td61vq_595"><p>Anonymous type can be exposed from anonymous function from type argument</p></td></tr><tr id="-td61vq_555"><td id="-td61vq_597"><p><a href="https://youtrack.jetbrains.com/issue/KT-22379" id="-td61vq_599" data-external="true" rel="noopener noreferrer" target="_blank">KT-22379</a></p></td><td id="-td61vq_598"><p>Condition of while-loop with break can produce unsound smartcast</p></td></tr><tr id="-td61vq_556"><td id="-td61vq_600"><p><a href="https://youtrack.jetbrains.com/issue/KT-62507" id="-td61vq_602" data-external="true" rel="noopener noreferrer" target="_blank">KT-62507</a></p></td><td id="-td61vq_601"><p>K2: Prohibit smart cast in common code for expect/actual top-level property</p></td></tr><tr id="-td61vq_557"><td id="-td61vq_603"><p><a href="https://youtrack.jetbrains.com/issue/KT-65750" id="-td61vq_605" data-external="true" rel="noopener noreferrer" target="_blank">KT-65750</a></p></td><td id="-td61vq_604"><p>Increment and plus operators that change return type must affect smart casts</p></td></tr><tr id="-td61vq_558"><td id="-td61vq_606"><p><a href="https://youtrack.jetbrains.com/issue/KT-65349" id="-td61vq_608" data-external="true" rel="noopener noreferrer" target="_blank">KT-65349</a></p></td><td id="-td61vq_607"><p>[LC] K2: specifying variable types explicitly breaks bound smart casts in some cases that worked in K1</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="generics" data-toc="generics">Generics</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_609"><thead><tr class="ijRowHead" id="-td61vq_610"><th id="-td61vq_624"><p>Issue ID</p></th><th id="-td61vq_625"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_611"><td id="-td61vq_626"><p><a href="https://youtrack.jetbrains.com/issue/KT-54309" id="-td61vq_628" data-external="true" rel="noopener noreferrer" target="_blank">KT-54309</a>*</p></td><td id="-td61vq_627"><p><a href="#deprecated-synthetics-setter-on-a-projected-receiver" id="-td61vq_629">Deprecate use of a synthetic setter on a projected receiver</a></p></td></tr><tr id="-td61vq_612"><td id="-td61vq_630"><p><a href="https://youtrack.jetbrains.com/issue/KT-57600" id="-td61vq_632" data-external="true" rel="noopener noreferrer" target="_blank">KT-57600</a></p></td><td id="-td61vq_631"><p>Forbid overriding of Java method with raw-typed parameter with generic typed parameter</p></td></tr><tr id="-td61vq_613"><td id="-td61vq_633"><p><a href="https://youtrack.jetbrains.com/issue/KT-54663" id="-td61vq_635" data-external="true" rel="noopener noreferrer" target="_blank">KT-54663</a></p></td><td id="-td61vq_634"><p>Forbid passing possibly nullable type parameter to `in` projected DNN parameter</p></td></tr><tr id="-td61vq_614"><td id="-td61vq_636"><p><a href="https://youtrack.jetbrains.com/issue/KT-54066" id="-td61vq_638" data-external="true" rel="noopener noreferrer" target="_blank">KT-54066</a></p></td><td id="-td61vq_637"><p>Deprecate upper bound violation in typealias constructors</p></td></tr><tr id="-td61vq_615"><td id="-td61vq_639"><p><a href="https://youtrack.jetbrains.com/issue/KT-49404" id="-td61vq_641" data-external="true" rel="noopener noreferrer" target="_blank">KT-49404</a></p></td><td id="-td61vq_640"><p>Fix type unsoundness for contravariant captured type based on Java class</p></td></tr><tr id="-td61vq_616"><td id="-td61vq_642"><p><a href="https://youtrack.jetbrains.com/issue/KT-61718" id="-td61vq_644" data-external="true" rel="noopener noreferrer" target="_blank">KT-61718</a></p></td><td id="-td61vq_643"><p>Forbid unsound code with self upper bounds and captured types</p></td></tr><tr id="-td61vq_617"><td id="-td61vq_645"><p><a href="https://youtrack.jetbrains.com/issue/KT-61749" id="-td61vq_647" data-external="true" rel="noopener noreferrer" target="_blank">KT-61749</a></p></td><td id="-td61vq_646"><p>Forbid unsound bound violation in generic inner class of generic outer class</p></td></tr><tr id="-td61vq_618"><td id="-td61vq_648"><p><a href="https://youtrack.jetbrains.com/issue/KT-62923" id="-td61vq_650" data-external="true" rel="noopener noreferrer" target="_blank">KT-62923</a></p></td><td id="-td61vq_649"><p>K2: Introduce PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE for projections of outer super types of inner class</p></td></tr><tr id="-td61vq_619"><td id="-td61vq_651"><p><a href="https://youtrack.jetbrains.com/issue/KT-63243" id="-td61vq_653" data-external="true" rel="noopener noreferrer" target="_blank">KT-63243</a></p></td><td id="-td61vq_652"><p>Report MANY_IMPL_MEMBER_NOT_IMPLEMENTED when inheriting from collection of primitives with an extra specialized implementation from another supertype</p></td></tr><tr id="-td61vq_620"><td id="-td61vq_654"><p><a href="https://youtrack.jetbrains.com/issue/KT-60305" id="-td61vq_656" data-external="true" rel="noopener noreferrer" target="_blank">KT-60305</a></p></td><td id="-td61vq_655"><p>K2: Prohibit constructor call and inheritance on type alias that has variance modifiers in expanded type</p></td></tr><tr id="-td61vq_621"><td id="-td61vq_657"><p><a href="https://youtrack.jetbrains.com/issue/KT-64965" id="-td61vq_659" data-external="true" rel="noopener noreferrer" target="_blank">KT-64965</a></p></td><td id="-td61vq_658"><p>Fix type hole caused by improper handling of captured types with self-upper bounds</p></td></tr><tr id="-td61vq_622"><td id="-td61vq_660"><p><a href="https://youtrack.jetbrains.com/issue/KT-64966" id="-td61vq_662" data-external="true" rel="noopener noreferrer" target="_blank">KT-64966</a></p></td><td id="-td61vq_661"><p>Forbid generic delegating constructor calls with wrong type for generic parameter</p></td></tr><tr id="-td61vq_623"><td id="-td61vq_663"><p><a href="https://youtrack.jetbrains.com/issue/KT-65712" id="-td61vq_665" data-external="true" rel="noopener noreferrer" target="_blank">KT-65712</a></p></td><td id="-td61vq_664"><p>Report missing upper bound violation when upper bound is captured type</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="resolution" data-toc="resolution">Resolution</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_666"><thead><tr class="ijRowHead" id="-td61vq_667"><th id="-td61vq_679"><p>Issue ID</p></th><th id="-td61vq_680"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_668"><td id="-td61vq_681"><p><a href="https://youtrack.jetbrains.com/issue/KT-55017" id="-td61vq_683" data-external="true" rel="noopener noreferrer" target="_blank">KT-55017</a>*</p></td><td id="-td61vq_682"><p><a href="#consistent-resolution-order-of-kotlin-properties-and-java-fields-with-the-same-name" id="-td61vq_684">Choose Kotlin property from derived class during overload resolution with Java field from base class</a></p></td></tr><tr id="-td61vq_669"><td id="-td61vq_685"><p><a href="https://youtrack.jetbrains.com/issue/KT-58260" id="-td61vq_687" data-external="true" rel="noopener noreferrer" target="_blank">KT-58260</a></p></td><td id="-td61vq_686"><p>Make invoke convention works consistently with expected desugaring</p></td></tr><tr id="-td61vq_670"><td id="-td61vq_688"><p><a href="https://youtrack.jetbrains.com/issue/KT-62866" id="-td61vq_690" data-external="true" rel="noopener noreferrer" target="_blank">KT-62866</a></p></td><td id="-td61vq_689"><p>K2: Change qualifier resolution behavior when companion object is preferred against static scope</p></td></tr><tr id="-td61vq_671"><td id="-td61vq_691"><p><a href="https://youtrack.jetbrains.com/issue/KT-57750" id="-td61vq_693" data-external="true" rel="noopener noreferrer" target="_blank">KT-57750</a></p></td><td id="-td61vq_692"><p>Report ambiguity error when resolving types and having the same-named classes star imported</p></td></tr><tr id="-td61vq_672"><td id="-td61vq_694"><p><a href="https://youtrack.jetbrains.com/issue/KT-63558" id="-td61vq_696" data-external="true" rel="noopener noreferrer" target="_blank">KT-63558</a></p></td><td id="-td61vq_695"><p>K2: migrate resolution around COMPATIBILITY_WARNING</p></td></tr><tr id="-td61vq_673"><td id="-td61vq_697"><p><a href="https://youtrack.jetbrains.com/issue/KT-51194" id="-td61vq_699" data-external="true" rel="noopener noreferrer" target="_blank">KT-51194</a></p></td><td id="-td61vq_698"><p>False negative CONFLICTING_INHERITED_MEMBERS when dependency class contained in two different versions of the same dependency</p></td></tr><tr id="-td61vq_674"><td id="-td61vq_700"><p><a href="https://youtrack.jetbrains.com/issue/KT-37592" id="-td61vq_702" data-external="true" rel="noopener noreferrer" target="_blank">KT-37592</a></p></td><td id="-td61vq_701"><p>Property invoke of a functional type with receiver is preferred over extension function invoke</p></td></tr><tr id="-td61vq_675"><td id="-td61vq_703"><p><a href="https://youtrack.jetbrains.com/issue/KT-51666" id="-td61vq_705" data-external="true" rel="noopener noreferrer" target="_blank">KT-51666</a></p></td><td id="-td61vq_704"><p>Qualified this: introduce/prioritize this qualified with type case</p></td></tr><tr id="-td61vq_676"><td id="-td61vq_706"><p><a href="https://youtrack.jetbrains.com/issue/KT-54166" id="-td61vq_708" data-external="true" rel="noopener noreferrer" target="_blank">KT-54166</a></p></td><td id="-td61vq_707"><p>Confirm unspecified behavior in case of FQ name conflicts in classpath</p></td></tr><tr id="-td61vq_677"><td id="-td61vq_709"><p><a href="https://youtrack.jetbrains.com/issue/KT-64431" id="-td61vq_711" data-external="true" rel="noopener noreferrer" target="_blank">KT-64431</a></p></td><td id="-td61vq_710"><p>K2: forbid using typealiases as qualifier in imports</p></td></tr><tr id="-td61vq_678"><td id="-td61vq_712"><p><a href="https://youtrack.jetbrains.com/issue/KT-56520" id="-td61vq_714" data-external="true" rel="noopener noreferrer" target="_blank">KT-56520</a></p></td><td id="-td61vq_713"><p>K1/K2: incorrect work of resolve tower for type references with ambiguity at lower level</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="visibility" data-toc="visibility">Visibility</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_715"><thead><tr class="ijRowHead" id="-td61vq_716"><th id="-td61vq_727"><p>Issue ID</p></th><th id="-td61vq_728"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_717"><td id="-td61vq_729"><p><a href="https://youtrack.jetbrains.com/issue/KT-64474/" id="-td61vq_731" data-external="true" rel="noopener noreferrer" target="_blank">KT-64474</a>*</p></td><td id="-td61vq_730"><p><a href="#forbidden-use-of-inaccessible-generic-types" id="-td61vq_732">Declare usages of inaccessible types as unspecified behavior</a></p></td></tr><tr id="-td61vq_718"><td id="-td61vq_733"><p><a href="https://youtrack.jetbrains.com/issue/KT-55179" id="-td61vq_735" data-external="true" rel="noopener noreferrer" target="_blank">KT-55179</a></p></td><td id="-td61vq_734"><p>False negative PRIVATE_CLASS_MEMBER_FROM_INLINE on calling private class companion object member from internal inline function</p></td></tr><tr id="-td61vq_719"><td id="-td61vq_736"><p><a href="https://youtrack.jetbrains.com/issue/KT-58042" id="-td61vq_738" data-external="true" rel="noopener noreferrer" target="_blank">KT-58042</a></p></td><td id="-td61vq_737"><p>Make synthetic property invisible if equivalent getter is invisible even when overridden declaration is visible</p></td></tr><tr id="-td61vq_720"><td id="-td61vq_739"><p><a href="https://youtrack.jetbrains.com/issue/KT-64255" id="-td61vq_741" data-external="true" rel="noopener noreferrer" target="_blank">KT-64255</a></p></td><td id="-td61vq_740"><p>Forbid accessing internal setter from a derived class in another module</p></td></tr><tr id="-td61vq_721"><td id="-td61vq_742"><p><a href="https://youtrack.jetbrains.com/issue/KT-33917" id="-td61vq_744" data-external="true" rel="noopener noreferrer" target="_blank">KT-33917</a></p></td><td id="-td61vq_743"><p>Prohibit to expose anonymous types from private inline functions</p></td></tr><tr id="-td61vq_722"><td id="-td61vq_745"><p><a href="https://youtrack.jetbrains.com/issue/KT-54997" id="-td61vq_747" data-external="true" rel="noopener noreferrer" target="_blank">KT-54997</a></p></td><td id="-td61vq_746"><p>Forbid implicit non-public-API accesses from public-API inline function</p></td></tr><tr id="-td61vq_723"><td id="-td61vq_748"><p><a href="https://youtrack.jetbrains.com/issue/KT-56310" id="-td61vq_750" data-external="true" rel="noopener noreferrer" target="_blank">KT-56310</a></p></td><td id="-td61vq_749"><p>Smart casts should not affect visibility of protected members</p></td></tr><tr id="-td61vq_724"><td id="-td61vq_751"><p><a href="https://youtrack.jetbrains.com/issue/KT-65494" id="-td61vq_753" data-external="true" rel="noopener noreferrer" target="_blank">KT-65494</a></p></td><td id="-td61vq_752"><p>Forbid access to overlooked private operator functions from public inline function</p></td></tr><tr id="-td61vq_725"><td id="-td61vq_754"><p><a href="https://youtrack.jetbrains.com/issue/KT-65004" id="-td61vq_756" data-external="true" rel="noopener noreferrer" target="_blank">KT-65004</a></p></td><td id="-td61vq_755"><p>K1: Setter of var, which overrides protected val, is generates as public</p></td></tr><tr id="-td61vq_726"><td id="-td61vq_757"><p><a href="https://youtrack.jetbrains.com/issue/KT-64972" id="-td61vq_759" data-external="true" rel="noopener noreferrer" target="_blank">KT-64972</a></p></td><td id="-td61vq_758"><p>Forbid overriding by private members in link-time for Kotlin/Native</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="annotations" data-toc="annotations">Annotations</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_760"><thead><tr class="ijRowHead" id="-td61vq_761"><th id="-td61vq_771"><p>Issue ID</p></th><th id="-td61vq_772"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_762"><td id="-td61vq_773"><p><a href="https://youtrack.jetbrains.com/issue/KT-58723" id="-td61vq_775" data-external="true" rel="noopener noreferrer" target="_blank">KT-58723</a></p></td><td id="-td61vq_774"><p>Forbid annotating statements with an annotation if it has no EXPRESSION target</p></td></tr><tr id="-td61vq_763"><td id="-td61vq_776"><p><a href="https://youtrack.jetbrains.com/issue/KT-49930" id="-td61vq_778" data-external="true" rel="noopener noreferrer" target="_blank">KT-49930</a></p></td><td id="-td61vq_777"><p>Ignore parentheses expression during `REPEATED_ANNOTATION` checking</p></td></tr><tr id="-td61vq_764"><td id="-td61vq_779"><p><a href="https://youtrack.jetbrains.com/issue/KT-57422" id="-td61vq_781" data-external="true" rel="noopener noreferrer" target="_blank">KT-57422</a></p></td><td id="-td61vq_780"><p>K2: Prohibit use-site 'get' targeted annotations on property getters</p></td></tr><tr id="-td61vq_765"><td id="-td61vq_782"><p><a href="https://youtrack.jetbrains.com/issue/KT-46483" id="-td61vq_784" data-external="true" rel="noopener noreferrer" target="_blank">KT-46483</a></p></td><td id="-td61vq_783"><p>Prohibit annotation on type parameter in where clause</p></td></tr><tr id="-td61vq_766"><td id="-td61vq_785"><p><a href="https://youtrack.jetbrains.com/issue/KT-64299" id="-td61vq_787" data-external="true" rel="noopener noreferrer" target="_blank">KT-64299</a></p></td><td id="-td61vq_786"><p>Companion scope is ignored for resolution of annotations on companion object</p></td></tr><tr id="-td61vq_767"><td id="-td61vq_788"><p><a href="https://youtrack.jetbrains.com/issue/KT-64654" id="-td61vq_790" data-external="true" rel="noopener noreferrer" target="_blank">KT-64654</a></p></td><td id="-td61vq_789"><p>K2: Introduced ambiguity between user and compiler-required annotations</p></td></tr><tr id="-td61vq_768"><td id="-td61vq_791"><p><a href="https://youtrack.jetbrains.com/issue/KT-64527" id="-td61vq_793" data-external="true" rel="noopener noreferrer" target="_blank">KT-64527</a></p></td><td id="-td61vq_792"><p>Annotations on enum values shouldn't be copied to enum value classes</p></td></tr><tr id="-td61vq_769"><td id="-td61vq_794"><p><a href="https://youtrack.jetbrains.com/issue/KT-63389" id="-td61vq_796" data-external="true" rel="noopener noreferrer" target="_blank">KT-63389</a></p></td><td id="-td61vq_795"><p>K2: `WRONG_ANNOTATION_TARGET` is reported on incompatible annotations of a type wrapped into `()?`</p></td></tr><tr id="-td61vq_770"><td id="-td61vq_797"><p><a href="https://youtrack.jetbrains.com/issue/KT-63388" id="-td61vq_799" data-external="true" rel="noopener noreferrer" target="_blank">KT-63388</a></p></td><td id="-td61vq_798"><p>K2: `WRONG_ANNOTATION_TARGET` is reported on catch parameter type's annotations</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="null-safety" data-toc="null-safety">Null safety</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_800"><thead><tr class="ijRowHead" id="-td61vq_801"><th id="-td61vq_808"><p>Issue ID</p></th><th id="-td61vq_809"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_802"><td id="-td61vq_810"><p><a href="https://youtrack.jetbrains.com/issue/KT-54521" id="-td61vq_812" data-external="true" rel="noopener noreferrer" target="_blank">KT-54521</a>*</p></td><td id="-td61vq_811"><p><a href="#improved-null-safety-for-java-primitive-arrays" id="-td61vq_813">Deprecate unsafe usages of array types annotated as Nullable in Java</a></p></td></tr><tr id="-td61vq_803"><td id="-td61vq_814"><p><a href="https://youtrack.jetbrains.com/issue/KT-41034" id="-td61vq_816" data-external="true" rel="noopener noreferrer" target="_blank">KT-41034</a></p></td><td id="-td61vq_815"><p>K2: Change evaluation semantics for combination of safe calls and convention operators</p></td></tr><tr id="-td61vq_804"><td id="-td61vq_817"><p><a href="https://youtrack.jetbrains.com/issue/KT-50850" id="-td61vq_819" data-external="true" rel="noopener noreferrer" target="_blank">KT-50850</a></p></td><td id="-td61vq_818"><p>Order of supertypes defines nullability parameters of inherited functions</p></td></tr><tr id="-td61vq_805"><td id="-td61vq_820"><p><a href="https://youtrack.jetbrains.com/issue/KT-53982" id="-td61vq_822" data-external="true" rel="noopener noreferrer" target="_blank">KT-53982</a></p></td><td id="-td61vq_821"><p>Keep nullability when approximating local types in public signatures</p></td></tr><tr id="-td61vq_806"><td id="-td61vq_823"><p><a href="https://youtrack.jetbrains.com/issue/KT-62998" id="-td61vq_825" data-external="true" rel="noopener noreferrer" target="_blank">KT-62998</a></p></td><td id="-td61vq_824"><p>Forbid assignment of a nullable to a not-null Java field as a selector of unsafe assignment</p></td></tr><tr id="-td61vq_807"><td id="-td61vq_826"><p><a href="https://youtrack.jetbrains.com/issue/KT-63209" id="-td61vq_828" data-external="true" rel="noopener noreferrer" target="_blank">KT-63209</a></p></td><td id="-td61vq_827"><p>Report missing errors for error-level nullable arguments of warning-level Java types</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="java-interoperability" data-toc="java-interoperability">Java interoperability</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_829"><thead><tr class="ijRowHead" id="-td61vq_830"><th id="-td61vq_836"><p>Issue ID</p></th><th id="-td61vq_837"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_831"><td id="-td61vq_838"><p><a href="https://youtrack.jetbrains.com/issue/KT-53061" id="-td61vq_840" data-external="true" rel="noopener noreferrer" target="_blank">KT-53061</a></p></td><td id="-td61vq_839"><p>Forbid Java and Kotlin classes with the same FQ name in sources</p></td></tr><tr id="-td61vq_832"><td id="-td61vq_841"><p><a href="https://youtrack.jetbrains.com/issue/KT-49882" id="-td61vq_843" data-external="true" rel="noopener noreferrer" target="_blank">KT-49882</a></p></td><td id="-td61vq_842"><p>Classes inherited from Java collections have inconsistent behavior depending on order of supertypes</p></td></tr><tr id="-td61vq_833"><td id="-td61vq_844"><p><a href="https://youtrack.jetbrains.com/issue/KT-66324" id="-td61vq_846" data-external="true" rel="noopener noreferrer" target="_blank">KT-66324</a></p></td><td id="-td61vq_845"><p>K2: unspecified behavior in case of Java class inheritance from a Kotlin private class</p></td></tr><tr id="-td61vq_834"><td id="-td61vq_847"><p><a href="https://youtrack.jetbrains.com/issue/KT-66220" id="-td61vq_849" data-external="true" rel="noopener noreferrer" target="_blank">KT-66220</a></p></td><td id="-td61vq_848"><p>Passing java vararg method to inline function leads to array of arrays in runtime instead of just an array</p></td></tr><tr id="-td61vq_835"><td id="-td61vq_850"><p><a href="https://youtrack.jetbrains.com/issue/KT-66204" id="-td61vq_852" data-external="true" rel="noopener noreferrer" target="_blank">KT-66204</a></p></td><td id="-td61vq_851"><p>Allow to override internal members in K-J-K hierarchy</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="properties" data-toc="properties">Properties</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_853"><thead><tr class="ijRowHead" id="-td61vq_854"><th id="-td61vq_860"><p>Issue ID</p></th><th id="-td61vq_861"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_855"><td id="-td61vq_862"><p><a href="https://youtrack.jetbrains.com/issue/KT-57555" id="-td61vq_864" data-external="true" rel="noopener noreferrer" target="_blank">KT-57555</a>*</p></td><td id="-td61vq_863"><p><a href="#immediate-initialization-of-open-properties-with-backing-fields" id="-td61vq_865">[LC] Forbid deferred initialization of open properties with backing field</a></p></td></tr><tr id="-td61vq_856"><td id="-td61vq_866"><p><a href="https://youtrack.jetbrains.com/issue/KT-58589" id="-td61vq_868" data-external="true" rel="noopener noreferrer" target="_blank">KT-58589</a></p></td><td id="-td61vq_867"><p>Deprecate missed MUST_BE_INITIALIZED when no primary constructor is presented or when class is local</p></td></tr><tr id="-td61vq_857"><td id="-td61vq_869"><p><a href="https://youtrack.jetbrains.com/issue/KT-64295" id="-td61vq_871" data-external="true" rel="noopener noreferrer" target="_blank">KT-64295</a></p></td><td id="-td61vq_870"><p>Forbid recursive resolve in case of potential invoke calls on properties</p></td></tr><tr id="-td61vq_858"><td id="-td61vq_872"><p><a href="https://youtrack.jetbrains.com/issue/KT-57290" id="-td61vq_874" data-external="true" rel="noopener noreferrer" target="_blank">KT-57290</a></p></td><td id="-td61vq_873"><p>Deprecate smart cast on base class property from invisible derived class if base class is from another module</p></td></tr><tr id="-td61vq_859"><td id="-td61vq_875"><p><a href="https://youtrack.jetbrains.com/issue/KT-62661" id="-td61vq_877" data-external="true" rel="noopener noreferrer" target="_blank">KT-62661</a></p></td><td id="-td61vq_876"><p>K2: Missed OPT_IN_USAGE_ERROR for data class properties</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="control-flow" data-toc="control-flow">Control flow</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_878"><thead><tr class="ijRowHead" id="-td61vq_879"><th id="-td61vq_884"><p>Issue ID</p></th><th id="-td61vq_885"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_880"><td id="-td61vq_886"><p><a href="https://youtrack.jetbrains.com/issue/KT-56408" id="-td61vq_888" data-external="true" rel="noopener noreferrer" target="_blank">KT-56408</a></p></td><td id="-td61vq_887"><p>Inconsistent rules of CFA in class initialization block between K1 and K2</p></td></tr><tr id="-td61vq_881"><td id="-td61vq_889"><p><a href="https://youtrack.jetbrains.com/issue/KT-57871" id="-td61vq_891" data-external="true" rel="noopener noreferrer" target="_blank">KT-57871</a></p></td><td id="-td61vq_890"><p>K1/K2 inconsistency on if-conditional without else-branch in parenthesis</p></td></tr><tr id="-td61vq_882"><td id="-td61vq_892"><p><a href="https://youtrack.jetbrains.com/issue/KT-42995" id="-td61vq_894" data-external="true" rel="noopener noreferrer" target="_blank">KT-42995</a></p></td><td id="-td61vq_893"><p>False negative &quot;VAL_REASSIGNMENT&quot; in try/catch block with initialization in scope function</p></td></tr><tr id="-td61vq_883"><td id="-td61vq_895"><p><a href="https://youtrack.jetbrains.com/issue/KT-65724" id="-td61vq_897" data-external="true" rel="noopener noreferrer" target="_blank">KT-65724</a></p></td><td id="-td61vq_896"><p>Propagate data flow information from try block to catch and finally blocks</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="enum-classes" data-toc="enum-classes">Enum classes</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_898"><thead><tr class="ijRowHead" id="-td61vq_899"><th id="-td61vq_904"><p>Issue ID</p></th><th id="-td61vq_905"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_900"><td id="-td61vq_906"><p><a href="https://youtrack.jetbrains.com/issue/KT-57608" id="-td61vq_908" data-external="true" rel="noopener noreferrer" target="_blank">KT-57608</a></p></td><td id="-td61vq_907"><p>Prohibit access to the companion object of enum class during initialization of enum entry</p></td></tr><tr id="-td61vq_901"><td id="-td61vq_909"><p><a href="https://youtrack.jetbrains.com/issue/KT-34372" id="-td61vq_911" data-external="true" rel="noopener noreferrer" target="_blank">KT-34372</a></p></td><td id="-td61vq_910"><p>Report missed error for virtual inline method in enum classes</p></td></tr><tr id="-td61vq_902"><td id="-td61vq_912"><p><a href="https://youtrack.jetbrains.com/issue/KT-52802" id="-td61vq_914" data-external="true" rel="noopener noreferrer" target="_blank">KT-52802</a></p></td><td id="-td61vq_913"><p>Report ambiguity resolving between property/field and enum entry</p></td></tr><tr id="-td61vq_903"><td id="-td61vq_915"><p><a href="https://youtrack.jetbrains.com/issue/KT-47310" id="-td61vq_917" data-external="true" rel="noopener noreferrer" target="_blank">KT-47310</a></p></td><td id="-td61vq_916"><p>Change qualifier resolution behavior when companion property is preferred against enum entry</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="functional-sam-interfaces" data-toc="functional-sam-interfaces">Functional (SAM) interfaces</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_918"><thead><tr class="ijRowHead" id="-td61vq_919"><th id="-td61vq_923"><p>Issue ID</p></th><th id="-td61vq_924"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_920"><td id="-td61vq_925"><p><a href="https://youtrack.jetbrains.com/issue/KT-52628" id="-td61vq_927" data-external="true" rel="noopener noreferrer" target="_blank">KT-52628</a></p></td><td id="-td61vq_926"><p>Deprecate SAM constructor usages which require OptIn without annotation</p></td></tr><tr id="-td61vq_921"><td id="-td61vq_928"><p><a href="https://youtrack.jetbrains.com/issue/KT-57014" id="-td61vq_930" data-external="true" rel="noopener noreferrer" target="_blank">KT-57014</a></p></td><td id="-td61vq_929"><p>Prohibit returning values with incorrect nullability from lambda for SAM constructor of JDK function interfaces</p></td></tr><tr id="-td61vq_922"><td id="-td61vq_931"><p><a href="https://youtrack.jetbrains.com/issue/KT-64342" id="-td61vq_933" data-external="true" rel="noopener noreferrer" target="_blank">KT-64342</a></p></td><td id="-td61vq_932"><p>SAM conversion of parameter types of callable references leads to CCE</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="companion-object" data-toc="companion-object">Companion object</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_934"><thead><tr class="ijRowHead" id="-td61vq_935"><th id="-td61vq_938"><p>Issue ID</p></th><th id="-td61vq_939"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_936"><td id="-td61vq_940"><p><a href="https://youtrack.jetbrains.com/issue/KT-54316" id="-td61vq_942" data-external="true" rel="noopener noreferrer" target="_blank">KT-54316</a></p></td><td id="-td61vq_941"><p>Out-of-call reference to companion object's member has invalid signature</p></td></tr><tr id="-td61vq_937"><td id="-td61vq_943"><p><a href="https://youtrack.jetbrains.com/issue/KT-47313" id="-td61vq_945" data-external="true" rel="noopener noreferrer" target="_blank">KT-47313</a></p></td><td id="-td61vq_944"><p>Change (V)::foo reference resolution when V has a companion</p></td></tr></tbody></table></div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="miscellaneous" data-toc="miscellaneous">Miscellaneous</h4></div><div class="collapse__content"><div class="table-wrapper"><table class="wide" id="-td61vq_946"><thead><tr class="ijRowHead" id="-td61vq_947"><th id="-td61vq_958"><p>Issue ID</p></th><th id="-td61vq_959"><p>Title</p></th></tr></thead><tbody><tr id="-td61vq_948"><td id="-td61vq_960"><p><a href="https://youtrack.jetbrains.com/issue/KT-59739" id="-td61vq_962" data-external="true" rel="noopener noreferrer" target="_blank">KT-59739</a>*</p></td><td id="-td61vq_961"><p>K2/MPP reports [ABSTRACT_MEMBER_NOT_IMPLEMENTED] for inheritor in common code when the implementation is located in the actual counterpart</p></td></tr><tr id="-td61vq_949"><td id="-td61vq_963"><p><a href="https://youtrack.jetbrains.com/issue/KT-49015" id="-td61vq_965" data-external="true" rel="noopener noreferrer" target="_blank">KT-49015</a></p></td><td id="-td61vq_964"><p>Qualified this: change behavior in case of potential label conflicts</p></td></tr><tr id="-td61vq_950"><td id="-td61vq_966"><p><a href="https://youtrack.jetbrains.com/issue/KT-56545" id="-td61vq_968" data-external="true" rel="noopener noreferrer" target="_blank">KT-56545</a></p></td><td id="-td61vq_967"><p>Fix incorrect functions mangling in JVM backend in case of accidental clashing overload in a Java subclass</p></td></tr><tr id="-td61vq_951"><td id="-td61vq_969"><p><a href="https://youtrack.jetbrains.com/issue/KT-62019" id="-td61vq_971" data-external="true" rel="noopener noreferrer" target="_blank">KT-62019</a></p></td><td id="-td61vq_970"><p>[LC issue] Prohibit suspend-marked anonymous function declarations in statement positions</p></td></tr><tr id="-td61vq_952"><td id="-td61vq_972"><p><a href="https://youtrack.jetbrains.com/issue/KT-55111" id="-td61vq_974" data-external="true" rel="noopener noreferrer" target="_blank">KT-55111</a></p></td><td id="-td61vq_973"><p>OptIn: forbid constructor calls with default arguments (parameters with default values) under marker</p></td></tr><tr id="-td61vq_953"><td id="-td61vq_975"><p><a href="https://youtrack.jetbrains.com/issue/KT-61182" id="-td61vq_977" data-external="true" rel="noopener noreferrer" target="_blank">KT-61182</a></p></td><td id="-td61vq_976"><p>Unit conversion is accidentally allowed to be used for expressions on variables + invoke resolution</p></td></tr><tr id="-td61vq_954"><td id="-td61vq_978"><p><a href="https://youtrack.jetbrains.com/issue/KT-55199" id="-td61vq_980" data-external="true" rel="noopener noreferrer" target="_blank">KT-55199</a></p></td><td id="-td61vq_979"><p>Forbid promoting callable references with adaptations to KFunction</p></td></tr><tr id="-td61vq_955"><td id="-td61vq_981"><p><a href="https://youtrack.jetbrains.com/issue/KT-65776" id="-td61vq_983" data-external="true" rel="noopener noreferrer" target="_blank">KT-65776</a></p></td><td id="-td61vq_982"><p>[LC] K2 breaks `false &amp;&amp; ...` and `false || ...`</p></td></tr><tr id="-td61vq_956"><td id="-td61vq_984"><p><a href="https://youtrack.jetbrains.com/issue/KT-65682" id="-td61vq_986" data-external="true" rel="noopener noreferrer" target="_blank">KT-65682</a></p></td><td id="-td61vq_985"><p>[LC] Deprecate `header`/`impl` keywords</p></td></tr><tr id="-td61vq_957"><td id="-td61vq_987"><p><a href="https://youtrack.jetbrains.com/issue/KT-45375" id="-td61vq_989" data-external="true" rel="noopener noreferrer" target="_blank">KT-45375</a></p></td><td id="-td61vq_988"><p>Generate all Kotlin lambdas via invokedynamic + LambdaMetafactory by default</p></td></tr></tbody></table></div></div></div></section></section></section><section class="chapter"><h2 id="compatibility-with-kotlin-releases" data-toc="compatibility-with-kotlin-releases">Compatibility with Kotlin releases</h2><p id="-td61vq_990">The following Kotlin releases have support for the new K2 compiler:</p><div class="table-wrapper"><table class="wide" id="-td61vq_991"><thead><tr class="ijRowHead" id="-td61vq_992"><th id="-td61vq_997"><p>Kotlin release</p></th><th id="-td61vq_998"><p>Stability level</p></th></tr></thead><tbody><tr id="-td61vq_993"><td id="-td61vq_999"><p>2.0.0&ndash;2.2.0</p></td><td id="-td61vq_1000"><p>Stable</p></td></tr><tr id="-td61vq_994"><td id="-td61vq_1001"><p>1.9.20&ndash;1.9.25</p></td><td id="-td61vq_1002"><p>Beta</p></td></tr><tr id="-td61vq_995"><td id="-td61vq_1003"><p>1.9.0&ndash;1.9.10</p></td><td id="-td61vq_1004"><p>JVM is Beta</p></td></tr><tr id="-td61vq_996"><td id="-td61vq_1005"><p>1.7.0&ndash;1.8.22</p></td><td id="-td61vq_1006"><p>Alpha</p></td></tr></tbody></table></div></section><section class="chapter"><h2 id="compatibility-with-kotlin-libraries" data-toc="compatibility-with-kotlin-libraries">Compatibility with Kotlin libraries</h2><p id="-td61vq_1007">If you're working with Kotlin/JVM, the K2 compiler works with libraries compiled with any version of Kotlin.</p><p id="-td61vq_1008">If you're working with Kotlin Multiplatform, the K2 compiler is guaranteed to work with libraries compiled with Kotlin version 1.9.20 and onwards.</p></section><section class="chapter"><h2 id="compiler-plugins-support" data-toc="compiler-plugins-support">Compiler plugins support</h2><p id="-td61vq_1009">Currently, the Kotlin K2 compiler supports the following Kotlin compiler plugins:</p><ul class="list _bullet" id="-td61vq_1010"><li class="list__item" id="-td61vq_1015"><p id="-td61vq_1025"><a href="all-open-plugin.html" id="-td61vq_1026"><code class="code" id="-td61vq_1027">all-open</code></a></p></li><li class="list__item" id="-td61vq_1016"><p id="-td61vq_1028"><a href="https://github.com/Kotlin/kotlinx-atomicfu" id="-td61vq_1029" data-external="true" rel="noopener noreferrer" target="_blank">AtomicFU</a></p></li><li class="list__item" id="-td61vq_1017"><p id="-td61vq_1030"><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/jvm-abi-gen" id="-td61vq_1031" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-td61vq_1032">jvm-abi-gen</code></a></p></li><li class="list__item" id="-td61vq_1018"><p id="-td61vq_1033"><a href="https://github.com/JetBrains/kotlin/tree/master/plugins/js-plain-objects" id="-td61vq_1034" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-td61vq_1035">js-plain-objects</code></a></p></li><li class="list__item" id="-td61vq_1019"><p id="-td61vq_1036"><a href="whatsnew1920.html#preview-kapt-compiler-plugin-with-k2" id="-td61vq_1037">kapt</a></p></li><li class="list__item" id="-td61vq_1020"><p id="-td61vq_1038"><a href="lombok.html" id="-td61vq_1039">Lombok</a></p></li><li class="list__item" id="-td61vq_1021"><p id="-td61vq_1040"><a href="no-arg-plugin.html" id="-td61vq_1041"><code class="code" id="-td61vq_1042">no-arg</code></a></p></li><li class="list__item" id="-td61vq_1022"><p id="-td61vq_1043"><a href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.plugin.parcelize" id="-td61vq_1044" data-external="true" rel="noopener noreferrer" target="_blank">Parcelize</a></p></li><li class="list__item" id="-td61vq_1023"><p id="-td61vq_1045"><a href="sam-with-receiver-plugin.html" id="-td61vq_1046">SAM with receiver</a></p></li><li class="list__item" id="-td61vq_1024"><p id="-td61vq_1047"><a href="serialization.html" id="-td61vq_1048">Serialization</a></p></li></ul><p id="-td61vq_1011">In addition, the Kotlin K2 compiler supports:</p><ul class="list _bullet" id="-td61vq_1012"><li class="list__item" id="-td61vq_1049"><p id="-td61vq_1051">The <a href="https://developer.android.com/jetpack/compose" id="-td61vq_1052" data-external="true" rel="noopener noreferrer" target="_blank">Jetpack Compose</a> 1.5.0 compiler plugin and later versions.</p></li><li class="list__item" id="-td61vq_1050"><p id="-td61vq_1053"><a href="ksp-overview.html" id="-td61vq_1054">Kotlin Symbol Processing (KSP)</a> since <a href="https://android-developers.googleblog.com/2023/12/ksp2-preview-kotlin-k2-standalone.html" id="-td61vq_1055" data-external="true" rel="noopener noreferrer" target="_blank">KSP2</a>.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-td61vq_1013"><p id="-td61vq_1056">If you use any additional compiler plugins, check their documentation to see if they are compatible with K2.</p></aside><section class="chapter"><h3 id="upgrade-your-custom-compiler-plugins" data-toc="upgrade-your-custom-compiler-plugins">Upgrade your custom compiler plugins</h3><aside class="prompt" data-type="warning" data-title="" id="-td61vq_1057"><p id="-td61vq_1061">Custom compiler plugins use the plugin API, which is <a href="components-stability.html#stability-levels-explained" id="-td61vq_1062">Experimental</a>. As a result, the API may change at any time, so we can't guarantee backward compatibility.</p></aside><p id="-td61vq_1058">The upgrade process has two paths depending on the type of custom plugin you have.</p><section class="chapter"><h4 id="backend-only-compiler-plugins" data-toc="backend-only-compiler-plugins">Backend-only compiler plugins</h4><p id="-td61vq_1063">If your plugin implements only <code class="code" id="-td61vq_1064">IrGenerationExtension</code> extension points, the process is the same as for any other new compiler release. Check if there are any changes to the API that you use and make changes if necessary.</p></section><section class="chapter"><h4 id="backend-and-frontend-compiler-plugins" data-toc="backend-and-frontend-compiler-plugins">Backend and frontend compiler plugins</h4><p id="-td61vq_1065">If your plugin uses frontend-related extension points, you need to rewrite the plugin using the new K2 compiler API. For an introduction to the new API, see <a href="https://github.com/JetBrains/kotlin/blob/master/docs/fir/fir-plugins.md" id="-td61vq_1067" data-external="true" rel="noopener noreferrer" target="_blank">FIR Plugin API</a>.</p><aside class="prompt" data-type="note" data-title="" id="-td61vq_1066"><p id="-td61vq_1068">If you have questions about upgrading your custom compiler plugin, join our <a href="https://kotlinlang.slack.com/archives/C7L3JB43G" id="-td61vq_1069" data-external="true" rel="noopener noreferrer" target="_blank">#compiler</a> Slack channel, and we will do our best to help you.</p></aside></section></section></section><section class="chapter"><h2 id="share-your-feedback-on-the-new-k2-compiler" data-toc="share-your-feedback-on-the-new-k2-compiler">Share your feedback on the new K2 compiler</h2><p id="-td61vq_1070">We would appreciate any feedback you may have!</p><ul class="list _bullet" id="-td61vq_1071"><li class="list__item" id="-td61vq_1072"><p id="-td61vq_1074">Report any problems you face migrating to the new K2 compiler in <a href="https://youtrack.jetbrains.com/newIssue?project=KT&amp;summary=K2+release+migration+issue&amp;description=Describe+the+problem+you+encountered+here.&amp;c=tag+k2-release-migration" id="-td61vq_1075" data-external="true" rel="noopener noreferrer" target="_blank">our issue tracker</a>.</p></li><li class="list__item" id="-td61vq_1073"><p id="-td61vq_1076"><a href="https://www.jetbrains.com/help/idea/settings-usage-statistics.html" id="-td61vq_1077" data-external="true" rel="noopener noreferrer" target="_blank">Enable the Send usage statistics option</a> to allow JetBrains to collect anonymous data about K2 usage.</p></li></ul></section><div class="last-modified">18 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="kotlin-osgi.html" class="navigation-links__prev">Kotlin and OSGi</a><a href="command-line.html" class="navigation-links__next">Kotlin command-line compiler</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>