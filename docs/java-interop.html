<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-04T03:15:56.0612941"><link rel="canonical" href="https://kotlinlang.org/docs/java-interop.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Calling Java from Kotlin | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"getters-and-setters","level":0,"title":"Getters and setters","anchor":"#getters-and-setters"},{"id":"java-synthetic-property-references","level":0,"title":"Java synthetic property references","anchor":"#java-synthetic-property-references"},{"id":"how-to-enable-java-synthetic-property-references","level":1,"title":"How to enable Java synthetic property references","anchor":"#how-to-enable-java-synthetic-property-references"},{"id":"methods-returning-void","level":0,"title":"Methods returning void","anchor":"#methods-returning-void"},{"id":"escaping-for-java-identifiers-that-are-keywords-in-kotlin","level":0,"title":"Escaping for Java identifiers that are keywords in Kotlin","anchor":"#escaping-for-java-identifiers-that-are-keywords-in-kotlin"},{"id":"null-safety-and-platform-types","level":0,"title":"Null-safety and platform types","anchor":"#null-safety-and-platform-types"},{"id":"notation-for-platform-types","level":1,"title":"Notation for platform types","anchor":"#notation-for-platform-types"},{"id":"nullability-annotations","level":1,"title":"Nullability annotations","anchor":"#nullability-annotations"},{"id":"annotating-type-arguments-and-type-parameters","level":1,"title":"Annotating type arguments and type parameters","anchor":"#annotating-type-arguments-and-type-parameters"},{"id":"jsr-305-support","level":1,"title":"JSR-305 support","anchor":"#jsr-305-support"},{"id":"mapped-types","level":0,"title":"Mapped types","anchor":"#mapped-types"},{"id":"java-generics-in-kotlin","level":0,"title":"Java generics in Kotlin","anchor":"#java-generics-in-kotlin"},{"id":"java-arrays","level":0,"title":"Java arrays","anchor":"#java-arrays"},{"id":"java-varargs","level":0,"title":"Java varargs","anchor":"#java-varargs"},{"id":"operators","level":0,"title":"Operators","anchor":"#operators"},{"id":"checked-exceptions","level":0,"title":"Checked exceptions","anchor":"#checked-exceptions"},{"id":"object-methods","level":0,"title":"Object methods","anchor":"#object-methods"},{"id":"wait-notify","level":1,"title":"wait()/notify()","anchor":"#wait-notify"},{"id":"getclass","level":1,"title":"getClass()","anchor":"#getclass"},{"id":"clone","level":1,"title":"clone()","anchor":"#clone"},{"id":"finalize","level":1,"title":"finalize()","anchor":"#finalize"},{"id":"inheritance-from-java-classes","level":0,"title":"Inheritance from Java classes","anchor":"#inheritance-from-java-classes"},{"id":"accessing-static-members","level":0,"title":"Accessing static members","anchor":"#accessing-static-members"},{"id":"java-reflection","level":0,"title":"Java reflection","anchor":"#java-reflection"},{"id":"sam-conversions","level":0,"title":"SAM conversions","anchor":"#sam-conversions"},{"id":"using-jni-with-kotlin","level":0,"title":"Using JNI with Kotlin","anchor":"#using-jni-with-kotlin"},{"id":"using-lombok-generated-declarations-in-kotlin","level":0,"title":"Using Lombok-generated declarations in Kotlin","anchor":"#using-lombok-generated-declarations-in-kotlin"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Calling Java from Kotlin | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/java-interop.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Calling Java from Kotlin | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/java-interop.html#webpage",
    "url": "https://kotlinlang.org/docs/java-interop.html",
    "name": "Calling Java from Kotlin | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="java-interop" data-main-title="Calling Java from Kotlin" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///JVM" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/jvm/java-interop.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="java-interop" id="java-interop.md">Calling Java from Kotlin</h1><p id="z5qbxps_2">Kotlin is designed with Java interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section, we describe some details about calling Java code from Kotlin.</p><p id="z5qbxps_3">Pretty much all Java code can be used without any issues:</p><div class="code-block" data-lang="kotlin">
import java.util.*

fun demo(source: List&lt;Int&gt;) {
    val list = ArrayList&lt;Int&gt;()
    // 'for'-loops work for Java collections:
    for (item in source) {
        list.add(item)
    }
    // Operator conventions work as well:
    for (i in 0..source.size - 1) {
        list[i] = source[i] // get and set are called
    }
}
</div><section class="chapter"><h2 id="getters-and-setters" data-toc="getters-and-setters">Getters and setters</h2><p id="z5qbxps_23">Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with <code class="code" id="z5qbxps_27">get</code> and single-argument methods with names starting with <code class="code" id="z5qbxps_28">set</code>) are represented as properties in Kotlin. Such properties are also called <span class="emphasis" id="z5qbxps_29">synthetic properties</span>. <code class="code" id="z5qbxps_30">Boolean</code> accessor methods (where the name of the getter starts with <code class="code" id="z5qbxps_31">is</code> and the name of the setter starts with <code class="code" id="z5qbxps_32">set</code>) are represented as properties which have the same name as the getter method.</p><div class="code-block" data-lang="kotlin">
import java.util.Calendar

fun calendarDemo() {
    val calendar = Calendar.getInstance()
    if (calendar.firstDayOfWeek == Calendar.SUNDAY) { // call getFirstDayOfWeek()
        calendar.firstDayOfWeek = Calendar.MONDAY // call setFirstDayOfWeek()
    }
    if (!calendar.isLenient) { // call isLenient()
        calendar.isLenient = true // call setLenient()
    }
}
</div><p id="z5qbxps_25"><code class="code" id="z5qbxps_33">calendar.firstDayOfWeek</code> above is an example of a synthetic property.</p><p id="z5qbxps_26">Note that, if the Java class only has a setter, it isn't visible as a property in Kotlin because Kotlin doesn't support set-only properties.</p></section><section class="chapter"><h2 id="java-synthetic-property-references" data-toc="java-synthetic-property-references">Java synthetic property references</h2><aside class="prompt" data-type="warning" data-title="" id="z5qbxps_34"><p id="z5qbxps_40">This feature is <a href="components-stability.html#stability-levels-explained" id="z5qbxps_41">Experimental</a>. It may be dropped or changed at any time. We recommend that you use it only for evaluation purposes.</p></aside><p id="z5qbxps_35">Starting from Kotlin 1.8.20, you can create references to Java synthetic properties. Consider the following Java code:</p><div class="code-block" data-lang="java">
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
</div><p id="z5qbxps_37">Kotlin has always allowed you to write <code class="code" id="z5qbxps_42">person.age</code>, where <code class="code" id="z5qbxps_43">age</code> is a synthetic property. Now, you can also create references to <code class="code" id="z5qbxps_44">Person::age</code> and <code class="code" id="z5qbxps_45">person::age</code>. The same applies for <code class="code" id="z5qbxps_46">name</code>, as well.</p><div class="code-block" data-lang="kotlin">
val persons = listOf(Person(&quot;Jack&quot;, 11), Person(&quot;Sofie&quot;, 12), Person(&quot;Peter&quot;, 11))
    persons
         // Call a reference to Java synthetic property:
        .sortedBy(Person::age)
         // Call Java getter via the Kotlin property syntax:
        .forEach { person -&gt; println(person.name) }
</div><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="how-to-enable-java-synthetic-property-references" data-toc="how-to-enable-java-synthetic-property-references">How to enable Java synthetic property references</h3></div><div class="collapse__content"><p id="z5qbxps_47">To enable this feature, set the <code class="code" id="z5qbxps_50">-language-version 2.1</code> compiler option. In a Gradle project, you can do so by adding the following to your <code class="code" id="z5qbxps_51">build.gradle(.kts)</code>:</p><div class="tabs" id="z5qbxps_48" data-group="build-script" data-anchors="[z5qbxps_52,z5qbxps_53]"><div class="tabs__content" data-gtm="tab" id="z5qbxps_52" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
tasks
    .withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask&lt;*&gt;&gt;()
    .configureEach {
        compilerOptions
            .languageVersion
            .set(
                org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1
            )
    }
</div></div><div class="tabs__content" data-gtm="tab" id="z5qbxps_53" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
tasks
    .withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask.class)
    .configureEach {
        compilerOptions.languageVersion
            = org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_1
}
</div></div></div><aside class="prompt" data-type="note" data-title="" id="z5qbxps_49"><p id="z5qbxps_56">Prior to Kotlin 1.9.0, to enable this feature you had to set the <code class="code" id="z5qbxps_57">-language-version 1.9</code> compiler option.</p></aside></div></div></section></section><section class="chapter"><h2 id="methods-returning-void" data-toc="methods-returning-void">Methods returning void</h2><p id="z5qbxps_58">If a Java method returns <code class="code" id="z5qbxps_59">void</code>, it will return <code class="code" id="z5qbxps_60">Unit</code> when called from Kotlin. If by any chance someone uses that return value, it will be assigned at the call site by the Kotlin compiler since the value itself is known in advance (being <code class="code" id="z5qbxps_61">Unit</code>).</p></section><section class="chapter"><h2 id="escaping-for-java-identifiers-that-are-keywords-in-kotlin" data-toc="escaping-for-java-identifiers-that-are-keywords-in-kotlin">Escaping for Java identifiers that are keywords in Kotlin</h2><p id="z5qbxps_62">Some of the Kotlin keywords are valid identifiers in Java: <code class="code" id="z5qbxps_64">in</code>, <code class="code" id="z5qbxps_65">object</code>, <code class="code" id="z5qbxps_66">is</code>, and other. If a Java library uses a Kotlin keyword for a method, you can still call the method escaping it with the backtick (`) character:</p><div class="code-block" data-lang="kotlin">
foo.`is`(bar)
</div></section><section class="chapter"><h2 id="null-safety-and-platform-types" data-toc="null-safety-and-platform-types">Null-safety and platform types</h2><p id="z5qbxps_67">Any reference in Java may be <code class="code" id="z5qbxps_79">null</code>, which makes Kotlin's requirements of strict null-safety impractical for objects coming from Java. Types of Java declarations are treated in Kotlin in a specific manner and called <span class="emphasis" id="z5qbxps_80">platform types</span>. Null-checks are relaxed for such types, so that safety guarantees for them are the same as in Java (see more <a href="#mapped-types" id="z5qbxps_81">below</a>).</p><p id="z5qbxps_68">Consider the following examples:</p><div class="code-block" data-lang="kotlin">
val list = ArrayList&lt;String&gt;() // non-null (constructor result)
list.add(&quot;Item&quot;)
val size = list.size // non-null (primitive int)
val item = list[0] // platform type inferred (ordinary Java object)
</div><p id="z5qbxps_70">When you call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</p><div class="code-block" data-lang="kotlin">
item.substring(1) // allowed, throws an exception if item == null
</div><p id="z5qbxps_72">Platform types are <span class="emphasis" id="z5qbxps_82">non-denotable</span>, meaning that you can't write them down explicitly in the language. When a platform value is assigned to a Kotlin variable, you can rely on the type inference (the variable will have an inferred platform type then, as <code class="code" id="z5qbxps_83">item</code> has in the example above), or you can choose the type you expect (both nullable and non-nullable types are allowed):</p><div class="code-block" data-lang="kotlin">
val nullable: String? = item // allowed, always works
val notNull: String = item // allowed, may fail at runtime
</div><p id="z5qbxps_74">If you choose a non-nullable type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-nullable variables from holding nulls. Assertions are also emitted when you pass platform values to Kotlin functions expecting non-null values and in other cases. Overall, the compiler does its best to prevent nulls from propagating far through the program although sometimes this is impossible to eliminate entirely, because of generics.</p><section class="chapter"><h3 id="notation-for-platform-types" data-toc="notation-for-platform-types">Notation for platform types</h3><p id="z5qbxps_84">As mentioned above, platform types can't be mentioned explicitly in the program, so there's no syntax for them in the language. Nevertheless, the compiler and IDE need to display them sometimes (for example, in error messages or parameter info), so there is a mnemonic notation for them:</p><ul class="list _bullet" id="z5qbxps_85"><li class="list__item" id="z5qbxps_86"><p id="z5qbxps_89"><code class="code" id="z5qbxps_90">T!</code> means &quot; <code class="code" id="z5qbxps_91">T</code> or <code class="code" id="z5qbxps_92">T?</code> &quot;,</p></li><li class="list__item" id="z5qbxps_87"><p id="z5qbxps_93"><code class="code" id="z5qbxps_94">(Mutable)Collection&lt;T&gt;!</code> means &quot;Java collection of <code class="code" id="z5qbxps_95">T</code> may be mutable or not, may be nullable or not&quot;,</p></li><li class="list__item" id="z5qbxps_88"><p id="z5qbxps_96"><code class="code" id="z5qbxps_97">Array&lt;(out) T&gt;!</code> means &quot;Java array of <code class="code" id="z5qbxps_98">T</code> (or a subtype of <code class="code" id="z5qbxps_99">T</code>), nullable or not&quot;</p></li></ul></section><section class="chapter"><h3 id="nullability-annotations" data-toc="nullability-annotations">Nullability annotations</h3><p id="z5qbxps_100">Java types that have nullability annotations are represented not as platform types, but as actual nullable or non-nullable Kotlin types. The compiler supports several flavors of nullability annotations, including:</p><ul class="list _bullet" id="z5qbxps_101"><li class="list__item" id="z5qbxps_105"><p id="z5qbxps_113"><a href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" id="z5qbxps_114" data-external="true" rel="noopener noreferrer" target="_blank">JetBrains</a> (<code class="code" id="z5qbxps_115">@Nullable</code> and <code class="code" id="z5qbxps_116">@NotNull</code> from the <code class="code" id="z5qbxps_117">org.jetbrains.annotations</code> package)</p></li><li class="list__item" id="z5qbxps_106"><p id="z5qbxps_118"><a href="https://jspecify.dev/" id="z5qbxps_119" data-external="true" rel="noopener noreferrer" target="_blank">JSpecify</a> (<code class="code" id="z5qbxps_120">org.jspecify.annotations</code>)</p></li><li class="list__item" id="z5qbxps_107"><p id="z5qbxps_121">Android (<code class="code" id="z5qbxps_122">com.android.annotations</code> and <code class="code" id="z5qbxps_123">android.support.annotations</code>)</p></li><li class="list__item" id="z5qbxps_108"><p id="z5qbxps_124">JSR-305 (<code class="code" id="z5qbxps_125">javax.annotation</code>, more details below)</p></li><li class="list__item" id="z5qbxps_109"><p id="z5qbxps_126">FindBugs (<code class="code" id="z5qbxps_127">edu.umd.cs.findbugs.annotations</code>)</p></li><li class="list__item" id="z5qbxps_110"><p id="z5qbxps_128">Eclipse (<code class="code" id="z5qbxps_129">org.eclipse.jdt.annotation</code>)</p></li><li class="list__item" id="z5qbxps_111"><p id="z5qbxps_130">Lombok (<code class="code" id="z5qbxps_131">lombok.NonNull</code>)</p></li><li class="list__item" id="z5qbxps_112"><p id="z5qbxps_132">RxJava 3 (<code class="code" id="z5qbxps_133">io.reactivex.rxjava3.annotations</code>)</p></li></ul><p id="z5qbxps_102">You can specify whether the compiler reports a nullability mismatch based on the information from specific types of nullability annotations. Use the compiler option <code class="code" id="z5qbxps_134">-Xnullability-annotations=@&lt;package-name&gt;:&lt;report-level&gt;</code>. In the argument, specify the fully qualified nullability annotations package and one of these report levels:</p><ul class="list _bullet" id="z5qbxps_103"><li class="list__item" id="z5qbxps_135"><p id="z5qbxps_138"><code class="code" id="z5qbxps_139">ignore</code> to ignore nullability mismatches</p></li><li class="list__item" id="z5qbxps_136"><p id="z5qbxps_140"><code class="code" id="z5qbxps_141">warn</code> to report warnings</p></li><li class="list__item" id="z5qbxps_137"><p id="z5qbxps_142"><code class="code" id="z5qbxps_143">strict</code> to report errors.</p></li></ul><p id="z5qbxps_104">See the full list of supported nullability annotations in the <a href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt" id="z5qbxps_144" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin compiler source code</a>.</p></section><section class="chapter"><h3 id="annotating-type-arguments-and-type-parameters" data-toc="annotating-type-arguments-and-type-parameters">Annotating type arguments and type parameters</h3><p id="z5qbxps_145">You can annotate the type arguments and type parameters of generic types to provide nullability information for them as well.</p><aside class="prompt" data-type="note" data-title="" id="z5qbxps_146"><p id="z5qbxps_149">All examples in the section use JetBrains nullability annotations from the <code class="code" id="z5qbxps_150">org.jetbrains.annotations</code> package.</p></aside><section class="chapter"><h4 id="type-arguments" data-toc="type-arguments">Type arguments</h4><p id="z5qbxps_151">Consider these annotations on a Java declaration:</p><div class="code-block" data-lang="java">
@NotNull
Set&lt;@NotNull String&gt; toSet(@NotNull Collection&lt;@NotNull String&gt; elements) { ... }
</div><p id="z5qbxps_153">They result in the following signature in Kotlin:</p><div class="code-block" data-lang="kotlin">
fun toSet(elements: (Mutable)Collection&lt;String&gt;) : (Mutable)Set&lt;String&gt; { ... }
</div><p id="z5qbxps_155">When the <code class="code" id="z5qbxps_164">@NotNull</code> annotation is missing from a type argument, you get a platform type instead:</p><div class="code-block" data-lang="kotlin">
fun toSet(elements: (Mutable)Collection&lt;String!&gt;) : (Mutable)Set&lt;String!&gt; { ... }
</div><p id="z5qbxps_157">Kotlin also takes into account nullability annotations on type arguments of base classes and interfaces. For example, there are two Java classes with the signatures provided below:</p><div class="code-block" data-lang="java">
public class Base&lt;T&gt; {}
</div><div class="code-block" data-lang="java">
public class Derived extends Base&lt;@Nullable String&gt; {}
</div><p id="z5qbxps_160">In the Kotlin code, passing the instance of <code class="code" id="z5qbxps_165">Derived</code> where the <code class="code" id="z5qbxps_166">Base&lt;String&gt;</code> is assumed produces the warning.</p><div class="code-block" data-lang="kotlin">
fun takeBaseOfNotNullStrings(x: Base&lt;String&gt;) {}

fun main() {
    takeBaseOfNotNullStrings(Derived()) // warning: nullability mismatch
}
</div><p id="z5qbxps_162">The upper bound of <code class="code" id="z5qbxps_167">Derived</code> is set to <code class="code" id="z5qbxps_168">Base&lt;String?&gt;</code>, which is different from <code class="code" id="z5qbxps_169">Base&lt;String&gt;</code>.</p><p id="z5qbxps_163">Learn more about <a href="#java-generics-in-kotlin" id="z5qbxps_170">Java generics in Kotlin</a>.</p></section><section class="chapter"><h4 id="type-parameters" data-toc="type-parameters">Type parameters</h4><p id="z5qbxps_171">By default, the nullability of plain type parameters in both Kotlin and Java is undefined. In Java, you can specify it using nullability annotations. Let's annotate the type parameter of the <code class="code" id="z5qbxps_183">Base</code> class:</p><div class="code-block" data-lang="java">
public class Base&lt;@NotNull T&gt; {}
</div><p id="z5qbxps_173">When inheriting from <code class="code" id="z5qbxps_184">Base</code>, Kotlin expects a non-nullable type argument or type parameter. Thus, the following Kotlin code produces a warning:</p><div class="code-block" data-lang="kotlin">
class Derived&lt;K&gt; : Base&lt;K&gt; {} // warning: K has undefined nullability
</div><p id="z5qbxps_175">You can fix it by specifying the upper bound <code class="code" id="z5qbxps_185">K : Any</code>.</p><p id="z5qbxps_176">Kotlin also supports nullability annotations on the bounds of Java type parameters. Let's add bounds to <code class="code" id="z5qbxps_186">Base</code>:</p><div class="code-block" data-lang="java">
public class BaseWithBound&lt;T extends @NotNull Number&gt; {}
</div><p id="z5qbxps_178">Kotlin translates this just as follows:</p><div class="code-block" data-lang="kotlin">
class BaseWithBound&lt;T : Number&gt; {}
</div><p id="z5qbxps_180">So passing nullable type as a type argument or type parameter produces a warning.</p><p id="z5qbxps_181">Annotating type arguments and type parameters works with the Java 8 target or higher. The feature requires that the nullability annotations support the <code class="code" id="z5qbxps_187">TYPE_USE</code> target (<code class="code" id="z5qbxps_188">org.jetbrains.annotations</code> supports this in version 15 and above).</p><aside class="prompt" data-type="note" data-title="" id="z5qbxps_182"><p id="z5qbxps_189">If a nullability annotation supports other targets that are applicable to a type in addition to the <code class="code" id="z5qbxps_190">TYPE_USE</code> target, <code class="code" id="z5qbxps_191">TYPE_USE</code> takes priority. For example, if <code class="code" id="z5qbxps_192">@Nullable</code> has both <code class="code" id="z5qbxps_193">TYPE_USE</code> and <code class="code" id="z5qbxps_194">METHOD</code> targets, the Java method signature <code class="code" id="z5qbxps_195">@Nullable String[] f()</code> becomes <code class="code" id="z5qbxps_196">fun f(): Array&lt;String?&gt;!</code> in Kotlin.</p></aside></section></section><section class="chapter"><h3 id="jsr-305-support" data-toc="jsr-305-support">JSR-305 support</h3><p id="z5qbxps_197">The <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" id="z5qbxps_205" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_207">@Nonnull</code></a> annotation defined in <a href="https://jcp.org/en/jsr/detail?id=305" id="z5qbxps_206" data-external="true" rel="noopener noreferrer" target="_blank">JSR-305</a> is supported for denoting nullability of Java types.</p><p id="z5qbxps_198">If the <code class="code" id="z5qbxps_208">@Nonnull(when = ...)</code> value is <code class="code" id="z5qbxps_209">When.ALWAYS</code>, the annotated type is treated as non-nullable; <code class="code" id="z5qbxps_210">When.MAYBE</code> and <code class="code" id="z5qbxps_211">When.NEVER</code> denote a nullable type; and <code class="code" id="z5qbxps_212">When.UNKNOWN</code> forces the type to be <a href="#null-safety-and-platform-types" id="z5qbxps_213">platform one</a>.</p><p id="z5qbxps_199">A library can be compiled against the JSR-305 annotations, but there's no need to make the annotations artifact (e.g. <code class="code" id="z5qbxps_214">jsr305.jar</code>) a compile dependency for the library consumers. The Kotlin compiler can read the JSR-305 annotations from a library without the annotations present on the classpath.</p><p id="z5qbxps_200"><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/jsr-305-custom-nullability-qualifiers.md" id="z5qbxps_215" data-external="true" rel="noopener noreferrer" target="_blank">Custom nullability qualifiers (KEEP-79)</a> are also supported (see below).</p><section class="chapter"><h4 id="type-qualifier-nicknames" data-toc="type-qualifier-nicknames">Type qualifier nicknames</h4><p id="z5qbxps_216">If an annotation type is annotated with both <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierNickname.html" id="z5qbxps_218" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_221">@TypeQualifierNickname</code></a> and JSR-305 <code class="code" id="z5qbxps_219">@Nonnull</code> (or its another nickname, such as <code class="code" id="z5qbxps_220">@CheckForNull</code>), then the annotation type is itself used for retrieving precise nullability and has the same meaning as that nullability annotation:</p><div class="code-block" data-lang="java">
@TypeQualifierNickname
@Nonnull(when = When.ALWAYS)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyNonnull {
}

@TypeQualifierNickname
@CheckForNull // a nickname to another type qualifier nickname
@Retention(RetentionPolicy.RUNTIME)
public @interface MyNullable {
}

interface A {
    @MyNullable String foo(@MyNonnull String x);
    // in Kotlin (strict mode): `fun foo(x: String): String?`

    String bar(List&lt;@MyNonnull String&gt; x);
    // in Kotlin (strict mode): `fun bar(x: List&lt;String&gt;!): String!`
}
</div></section><section class="chapter"><h4 id="type-qualifier-defaults" data-toc="type-qualifier-defaults">Type qualifier defaults</h4><p id="z5qbxps_222"><a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/meta/TypeQualifierDefault.html" id="z5qbxps_230" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_231">@TypeQualifierDefault</code></a> allows introducing annotations that, when being applied, define the default nullability within the scope of the annotated element.</p><p id="z5qbxps_223">Such annotation type should itself be annotated with both <code class="code" id="z5qbxps_232">@Nonnull</code> (or its nickname) and <code class="code" id="z5qbxps_233">@TypeQualifierDefault(...)</code> with one or more <code class="code" id="z5qbxps_234">ElementType</code> values:</p><ul class="list _bullet" id="z5qbxps_224"><li class="list__item" id="z5qbxps_235"><p id="z5qbxps_239"><code class="code" id="z5qbxps_240">ElementType.METHOD</code> for return types of methods</p></li><li class="list__item" id="z5qbxps_236"><p id="z5qbxps_241"><code class="code" id="z5qbxps_242">ElementType.PARAMETER</code> for value parameters</p></li><li class="list__item" id="z5qbxps_237"><p id="z5qbxps_243"><code class="code" id="z5qbxps_244">ElementType.FIELD</code> for fields</p></li><li class="list__item" id="z5qbxps_238"><p id="z5qbxps_245"><code class="code" id="z5qbxps_246">ElementType.TYPE_USE</code> for any type including type arguments, upper bounds of type parameters and wildcard types</p></li></ul><p id="z5qbxps_225">The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the <code class="code" id="z5qbxps_247">ElementType</code> matching the type usage.</p><div class="code-block" data-lang="java">
@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
public @interface NonNullApi {
}

@Nonnull(when = When.MAYBE)
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})
public @interface NullableApi {
}

@NullableApi
interface A {
    String foo(String x); // fun foo(x: String?): String?

    @NotNullApi // overriding default from the interface
    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String

    // The List&lt;String&gt; type argument is seen as nullable because of `@NullableApi`
    // having the `TYPE_USE` element type:
    String baz(List&lt;String&gt; x); // fun baz(List&lt;String?&gt;?): String?

    // The type of `x` parameter remains platform because there's an explicit
    // UNKNOWN-marked nullability annotation:
    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?
}
</div><aside class="prompt" data-type="note" data-title="" id="z5qbxps_227"><p id="z5qbxps_248">The types in this example only take place with the strict mode enabled; otherwise, the platform types remain. See the <a href="#undermigration-annotation" id="z5qbxps_249"><code class="code" id="z5qbxps_251">@UnderMigration</code> annotation</a> and <a href="#compiler-configuration" id="z5qbxps_250">Compiler configuration</a> sections.</p></aside><p id="z5qbxps_228">Package-level default nullability is also supported:</p><div class="code-block" data-lang="java">
// FILE: test/package-info.java
@NonNullApi // declaring all types in package 'test' as non-nullable by default
package test;
</div></section><section class="chapter"><h4 id="undermigration-annotation" data-toc="undermigration-annotation">@UnderMigration annotation</h4><p id="z5qbxps_252">The <code class="code" id="z5qbxps_259">@UnderMigration</code> annotation (provided in a separate artifact <code class="code" id="z5qbxps_260">kotlin-annotations-jvm</code>) can be used by library maintainers to define the migration status for the nullability type qualifiers.</p><p id="z5qbxps_253">The status value in <code class="code" id="z5qbxps_261">@UnderMigration(status = ...)</code> specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a <code class="code" id="z5qbxps_262">@MyNullable</code>-annotated type value as non-null):</p><ul class="list _bullet" id="z5qbxps_254"><li class="list__item" id="z5qbxps_263"><p id="z5qbxps_266"><code class="code" id="z5qbxps_267">MigrationStatus.STRICT</code> makes annotation work as any plain nullability annotation, i.e. report errors for the inappropriate usages and affect the types in the annotated declarations as they are seen in Kotlin</p></li><li class="list__item" id="z5qbxps_264"><p id="z5qbxps_268"><code class="code" id="z5qbxps_269">MigrationStatus.WARN</code>: the inappropriate usages are reported as compilation warnings instead of errors, but the types in the annotated declarations remain platform</p></li><li class="list__item" id="z5qbxps_265"><p id="z5qbxps_270"><code class="code" id="z5qbxps_271">MigrationStatus.IGNORE</code> makes the compiler ignore the nullability annotation completely</p></li></ul><p id="z5qbxps_255">A library maintainer can add <code class="code" id="z5qbxps_272">@UnderMigration</code> status to both type qualifier nicknames and type qualifier defaults:</p><div class="code-block" data-lang="java">
@Nonnull(when = When.ALWAYS)
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
@UnderMigration(status = MigrationStatus.WARN)
public @interface NonNullApi {
}

// The types in the class are non-nullable, but only warnings are reported
// because `@NonNullApi` is annotated `@UnderMigration(status = MigrationStatus.WARN)`
@NonNullApi
public class Test {}
</div><aside class="prompt" data-type="note" data-title="" id="z5qbxps_257"><p id="z5qbxps_273">The migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</p></aside><p id="z5qbxps_258">If a default type qualifier uses a type qualifier nickname and they are both <code class="code" id="z5qbxps_274">@UnderMigration</code>, the status from the default type qualifier is used.</p></section><section class="chapter"><h4 id="compiler-configuration" data-toc="compiler-configuration">Compiler configuration</h4><p id="z5qbxps_275">The JSR-305 checks can be configured by adding the <code class="code" id="z5qbxps_281">-Xjsr305</code> compiler flag with the following options (and their combination):</p><ul class="list _bullet" id="z5qbxps_276"><li class="list__item" id="z5qbxps_282"><p id="z5qbxps_285"><code class="code" id="z5qbxps_286">-Xjsr305={strict|warn|ignore}</code> to set up the behavior for non-<code class="code" id="z5qbxps_287">@UnderMigration</code> annotations. Custom nullability qualifiers, especially <code class="code" id="z5qbxps_288">@TypeQualifierDefault</code>, are already spread among many well-known libraries, and users may need to migrate smoothly when updating to the Kotlin version containing JSR-305 support. Since Kotlin 1.1.60, this flag only affects non-<code class="code" id="z5qbxps_289">@UnderMigration</code> annotations.</p></li><li class="list__item" id="z5qbxps_283"><p id="z5qbxps_290"><code class="code" id="z5qbxps_291">-Xjsr305=under-migration:{strict|warn|ignore}</code> to override the behavior for the <code class="code" id="z5qbxps_292">@UnderMigration</code> annotations. Users may have different view on the migration status for the libraries: they may want to have errors while the official migration status is <code class="code" id="z5qbxps_293">WARN</code>, or vice versa, they may wish to postpone errors reporting for some until they complete their migration.</p></li><li class="list__item" id="z5qbxps_284"><p id="z5qbxps_294"><code class="code" id="z5qbxps_295">-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code> to override the behavior for a single annotation, where <code class="code" id="z5qbxps_296">&lt;fq.name&gt;</code> is the fully qualified class name of the annotation. May appear several times for different annotations. This is useful for managing the migration state for a particular library.</p></li></ul><p id="z5qbxps_277">The <code class="code" id="z5qbxps_297">strict</code>, <code class="code" id="z5qbxps_298">warn</code> and <code class="code" id="z5qbxps_299">ignore</code> values have the same meaning as those of <code class="code" id="z5qbxps_300">MigrationStatus</code>, and only the <code class="code" id="z5qbxps_301">strict</code> mode affects the types in the annotated declarations as they are seen in Kotlin.</p><aside class="prompt" data-type="note" data-title="" id="z5qbxps_278"><p id="z5qbxps_302">Note: the built-in JSR-305 annotations <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/Nonnull.html" id="z5qbxps_303" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_307">@Nonnull</code></a>, <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/Nullable.html" id="z5qbxps_304" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_308">@Nullable</code></a> and <a href="https://www.javadoc.io/doc/com.google.code.findbugs/jsr305/latest/javax/annotation/CheckForNull.html" id="z5qbxps_305" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="z5qbxps_309">@CheckForNull</code></a> are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the <code class="code" id="z5qbxps_306">-Xjsr305</code> flag.</p></aside><p id="z5qbxps_279">For example, adding <code class="code" id="z5qbxps_310">-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code> to the compiler arguments makes the compiler generate warnings for inappropriate usages of types annotated by <code class="code" id="z5qbxps_311">@org.library.MyNullable</code> and ignore all other JSR-305 annotations.</p><p id="z5qbxps_280">The default behavior is the same to <code class="code" id="z5qbxps_312">-Xjsr305=warn</code>. The <code class="code" id="z5qbxps_313">strict</code> value should be considered experimental (more checks may be added to it in the future).</p></section></section></section><section class="chapter"><h2 id="mapped-types" data-toc="mapped-types">Mapped types</h2><p id="z5qbxps_314">Kotlin treats some Java types specifically. Such types are not loaded from Java &quot;as is&quot;, but are <span class="emphasis" id="z5qbxps_326">mapped</span> to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping <a href="#null-safety-and-platform-types" id="z5qbxps_327">platform types</a> in mind):</p><div class="table-wrapper"><table class="wide" id="z5qbxps_315"><thead><tr class="ijRowHead" id="z5qbxps_328"><th id="z5qbxps_337"><p><span class="control" id="z5qbxps_339">Java type</span></p></th><th id="z5qbxps_338"><p><span class="control" id="z5qbxps_340">Kotlin type</span></p></th></tr></thead><tbody><tr id="z5qbxps_329"><td id="z5qbxps_341"><p><code class="code" id="z5qbxps_343">byte</code></p></td><td id="z5qbxps_342"><p><code class="code" id="z5qbxps_344">kotlin.Byte</code></p></td></tr><tr id="z5qbxps_330"><td id="z5qbxps_345"><p><code class="code" id="z5qbxps_347">short</code></p></td><td id="z5qbxps_346"><p><code class="code" id="z5qbxps_348">kotlin.Short</code></p></td></tr><tr id="z5qbxps_331"><td id="z5qbxps_349"><p><code class="code" id="z5qbxps_351">int</code></p></td><td id="z5qbxps_350"><p><code class="code" id="z5qbxps_352">kotlin.Int</code></p></td></tr><tr id="z5qbxps_332"><td id="z5qbxps_353"><p><code class="code" id="z5qbxps_355">long</code></p></td><td id="z5qbxps_354"><p><code class="code" id="z5qbxps_356">kotlin.Long</code></p></td></tr><tr id="z5qbxps_333"><td id="z5qbxps_357"><p><code class="code" id="z5qbxps_359">char</code></p></td><td id="z5qbxps_358"><p><code class="code" id="z5qbxps_360">kotlin.Char</code></p></td></tr><tr id="z5qbxps_334"><td id="z5qbxps_361"><p><code class="code" id="z5qbxps_363">float</code></p></td><td id="z5qbxps_362"><p><code class="code" id="z5qbxps_364">kotlin.Float</code></p></td></tr><tr id="z5qbxps_335"><td id="z5qbxps_365"><p><code class="code" id="z5qbxps_367">double</code></p></td><td id="z5qbxps_366"><p><code class="code" id="z5qbxps_368">kotlin.Double</code></p></td></tr><tr id="z5qbxps_336"><td id="z5qbxps_369"><p><code class="code" id="z5qbxps_371">boolean</code></p></td><td id="z5qbxps_370"><p><code class="code" id="z5qbxps_372">kotlin.Boolean</code></p></td></tr></tbody></table></div><p id="z5qbxps_316">Some non-primitive built-in classes are also mapped:</p><div class="table-wrapper"><table class="wide" id="z5qbxps_317"><thead><tr class="ijRowHead" id="z5qbxps_373"><th id="z5qbxps_383"><p><span class="control" id="z5qbxps_385">Java type</span></p></th><th id="z5qbxps_384"><p><span class="control" id="z5qbxps_386">Kotlin type</span></p></th></tr></thead><tbody><tr id="z5qbxps_374"><td id="z5qbxps_387"><p><code class="code" id="z5qbxps_389">java.lang.Object</code></p></td><td id="z5qbxps_388"><p><code class="code" id="z5qbxps_390">kotlin.Any!</code></p></td></tr><tr id="z5qbxps_375"><td id="z5qbxps_391"><p><code class="code" id="z5qbxps_393">java.lang.Cloneable</code></p></td><td id="z5qbxps_392"><p><code class="code" id="z5qbxps_394">kotlin.Cloneable!</code></p></td></tr><tr id="z5qbxps_376"><td id="z5qbxps_395"><p><code class="code" id="z5qbxps_397">java.lang.Comparable</code></p></td><td id="z5qbxps_396"><p><code class="code" id="z5qbxps_398">kotlin.Comparable!</code></p></td></tr><tr id="z5qbxps_377"><td id="z5qbxps_399"><p><code class="code" id="z5qbxps_401">java.lang.Enum</code></p></td><td id="z5qbxps_400"><p><code class="code" id="z5qbxps_402">kotlin.Enum!</code></p></td></tr><tr id="z5qbxps_378"><td id="z5qbxps_403"><p><code class="code" id="z5qbxps_405">java.lang.annotation.Annotation</code></p></td><td id="z5qbxps_404"><p><code class="code" id="z5qbxps_406">kotlin.Annotation!</code></p></td></tr><tr id="z5qbxps_379"><td id="z5qbxps_407"><p><code class="code" id="z5qbxps_409">java.lang.CharSequence</code></p></td><td id="z5qbxps_408"><p><code class="code" id="z5qbxps_410">kotlin.CharSequence!</code></p></td></tr><tr id="z5qbxps_380"><td id="z5qbxps_411"><p><code class="code" id="z5qbxps_413">java.lang.String</code></p></td><td id="z5qbxps_412"><p><code class="code" id="z5qbxps_414">kotlin.String!</code></p></td></tr><tr id="z5qbxps_381"><td id="z5qbxps_415"><p><code class="code" id="z5qbxps_417">java.lang.Number</code></p></td><td id="z5qbxps_416"><p><code class="code" id="z5qbxps_418">kotlin.Number!</code></p></td></tr><tr id="z5qbxps_382"><td id="z5qbxps_419"><p><code class="code" id="z5qbxps_421">java.lang.Throwable</code></p></td><td id="z5qbxps_420"><p><code class="code" id="z5qbxps_422">kotlin.Throwable!</code></p></td></tr></tbody></table></div><p id="z5qbxps_318">Java's boxed primitive types are mapped to nullable Kotlin types:</p><div class="table-wrapper"><table class="wide" id="z5qbxps_319"><thead><tr class="ijRowHead" id="z5qbxps_423"><th id="z5qbxps_432"><p><span class="control" id="z5qbxps_434">Java type</span></p></th><th id="z5qbxps_433"><p><span class="control" id="z5qbxps_435">Kotlin type</span></p></th></tr></thead><tbody><tr id="z5qbxps_424"><td id="z5qbxps_436"><p><code class="code" id="z5qbxps_438">java.lang.Byte</code></p></td><td id="z5qbxps_437"><p><code class="code" id="z5qbxps_439">kotlin.Byte?</code></p></td></tr><tr id="z5qbxps_425"><td id="z5qbxps_440"><p><code class="code" id="z5qbxps_442">java.lang.Short</code></p></td><td id="z5qbxps_441"><p><code class="code" id="z5qbxps_443">kotlin.Short?</code></p></td></tr><tr id="z5qbxps_426"><td id="z5qbxps_444"><p><code class="code" id="z5qbxps_446">java.lang.Integer</code></p></td><td id="z5qbxps_445"><p><code class="code" id="z5qbxps_447">kotlin.Int?</code></p></td></tr><tr id="z5qbxps_427"><td id="z5qbxps_448"><p><code class="code" id="z5qbxps_450">java.lang.Long</code></p></td><td id="z5qbxps_449"><p><code class="code" id="z5qbxps_451">kotlin.Long?</code></p></td></tr><tr id="z5qbxps_428"><td id="z5qbxps_452"><p><code class="code" id="z5qbxps_454">java.lang.Character</code></p></td><td id="z5qbxps_453"><p><code class="code" id="z5qbxps_455">kotlin.Char?</code></p></td></tr><tr id="z5qbxps_429"><td id="z5qbxps_456"><p><code class="code" id="z5qbxps_458">java.lang.Float</code></p></td><td id="z5qbxps_457"><p><code class="code" id="z5qbxps_459">kotlin.Float?</code></p></td></tr><tr id="z5qbxps_430"><td id="z5qbxps_460"><p><code class="code" id="z5qbxps_462">java.lang.Double</code></p></td><td id="z5qbxps_461"><p><code class="code" id="z5qbxps_463">kotlin.Double?</code></p></td></tr><tr id="z5qbxps_431"><td id="z5qbxps_464"><p><code class="code" id="z5qbxps_466">java.lang.Boolean</code></p></td><td id="z5qbxps_465"><p><code class="code" id="z5qbxps_467">kotlin.Boolean?</code></p></td></tr></tbody></table></div><p id="z5qbxps_320">Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, <code class="code" id="z5qbxps_468">List&lt;java.lang.Integer&gt;</code> becomes a <code class="code" id="z5qbxps_469">List&lt;Int!&gt;</code> in Kotlin.</p><p id="z5qbxps_321">Collection types may be read-only or mutable in Kotlin, so Java's collections are mapped as follows (all Kotlin types in this table reside in the package <code class="code" id="z5qbxps_470">kotlin.collections</code>):</p><div class="table-wrapper"><table class="wide" id="z5qbxps_322"><thead><tr class="ijRowHead" id="z5qbxps_471"><th id="z5qbxps_480"><p><span class="control" id="z5qbxps_484">Java type</span></p></th><th id="z5qbxps_481"><p><span class="control" id="z5qbxps_485">Kotlin read-only type</span></p></th><th id="z5qbxps_482"><p><span class="control" id="z5qbxps_486">Kotlin mutable type</span></p></th><th id="z5qbxps_483"><p><span class="control" id="z5qbxps_487">Loaded platform type</span></p></th></tr></thead><tbody><tr id="z5qbxps_472"><td id="z5qbxps_488"><p><code class="code" id="z5qbxps_492">Iterator&lt;T&gt;</code></p></td><td id="z5qbxps_489"><p><code class="code" id="z5qbxps_493">Iterator&lt;T&gt;</code></p></td><td id="z5qbxps_490"><p><code class="code" id="z5qbxps_494">MutableIterator&lt;T&gt;</code></p></td><td id="z5qbxps_491"><p><code class="code" id="z5qbxps_495">(Mutable)Iterator&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_473"><td id="z5qbxps_496"><p><code class="code" id="z5qbxps_500">Iterable&lt;T&gt;</code></p></td><td id="z5qbxps_497"><p><code class="code" id="z5qbxps_501">Iterable&lt;T&gt;</code></p></td><td id="z5qbxps_498"><p><code class="code" id="z5qbxps_502">MutableIterable&lt;T&gt;</code></p></td><td id="z5qbxps_499"><p><code class="code" id="z5qbxps_503">(Mutable)Iterable&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_474"><td id="z5qbxps_504"><p><code class="code" id="z5qbxps_508">Collection&lt;T&gt;</code></p></td><td id="z5qbxps_505"><p><code class="code" id="z5qbxps_509">Collection&lt;T&gt;</code></p></td><td id="z5qbxps_506"><p><code class="code" id="z5qbxps_510">MutableCollection&lt;T&gt;</code></p></td><td id="z5qbxps_507"><p><code class="code" id="z5qbxps_511">(Mutable)Collection&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_475"><td id="z5qbxps_512"><p><code class="code" id="z5qbxps_516">Set&lt;T&gt;</code></p></td><td id="z5qbxps_513"><p><code class="code" id="z5qbxps_517">Set&lt;T&gt;</code></p></td><td id="z5qbxps_514"><p><code class="code" id="z5qbxps_518">MutableSet&lt;T&gt;</code></p></td><td id="z5qbxps_515"><p><code class="code" id="z5qbxps_519">(Mutable)Set&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_476"><td id="z5qbxps_520"><p><code class="code" id="z5qbxps_524">List&lt;T&gt;</code></p></td><td id="z5qbxps_521"><p><code class="code" id="z5qbxps_525">List&lt;T&gt;</code></p></td><td id="z5qbxps_522"><p><code class="code" id="z5qbxps_526">MutableList&lt;T&gt;</code></p></td><td id="z5qbxps_523"><p><code class="code" id="z5qbxps_527">(Mutable)List&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_477"><td id="z5qbxps_528"><p><code class="code" id="z5qbxps_532">ListIterator&lt;T&gt;</code></p></td><td id="z5qbxps_529"><p><code class="code" id="z5qbxps_533">ListIterator&lt;T&gt;</code></p></td><td id="z5qbxps_530"><p><code class="code" id="z5qbxps_534">MutableListIterator&lt;T&gt;</code></p></td><td id="z5qbxps_531"><p><code class="code" id="z5qbxps_535">(Mutable)ListIterator&lt;T&gt;!</code></p></td></tr><tr id="z5qbxps_478"><td id="z5qbxps_536"><p><code class="code" id="z5qbxps_540">Map&lt;K, V&gt;</code></p></td><td id="z5qbxps_537"><p><code class="code" id="z5qbxps_541">Map&lt;K, V&gt;</code></p></td><td id="z5qbxps_538"><p><code class="code" id="z5qbxps_542">MutableMap&lt;K, V&gt;</code></p></td><td id="z5qbxps_539"><p><code class="code" id="z5qbxps_543">(Mutable)Map&lt;K, V&gt;!</code></p></td></tr><tr id="z5qbxps_479"><td id="z5qbxps_544"><p><code class="code" id="z5qbxps_548">Map.Entry&lt;K, V&gt;</code></p></td><td id="z5qbxps_545"><p><code class="code" id="z5qbxps_549">Map.Entry&lt;K, V&gt;</code></p></td><td id="z5qbxps_546"><p><code class="code" id="z5qbxps_550">MutableMap.MutableEntry&lt;K,V&gt;</code></p></td><td id="z5qbxps_547"><p><code class="code" id="z5qbxps_551">(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></p></td></tr></tbody></table></div><p id="z5qbxps_323">Java's arrays are mapped as mentioned <a href="#java-arrays" id="z5qbxps_552">below</a>:</p><div class="table-wrapper"><table class="wide" id="z5qbxps_324"><thead><tr class="ijRowHead" id="z5qbxps_553"><th id="z5qbxps_556"><p><span class="control" id="z5qbxps_558">Java type</span></p></th><th id="z5qbxps_557"><p><span class="control" id="z5qbxps_559">Kotlin type</span></p></th></tr></thead><tbody><tr id="z5qbxps_554"><td id="z5qbxps_560"><p><code class="code" id="z5qbxps_562">int[]</code></p></td><td id="z5qbxps_561"><p><code class="code" id="z5qbxps_563">kotlin.IntArray!</code></p></td></tr><tr id="z5qbxps_555"><td id="z5qbxps_564"><p><code class="code" id="z5qbxps_566">String[]</code></p></td><td id="z5qbxps_565"><p><code class="code" id="z5qbxps_567">kotlin.Array&lt;(out) String!&gt;!</code></p></td></tr></tbody></table></div><aside class="prompt" data-type="note" data-title="" id="z5qbxps_325"><p id="z5qbxps_568">The static members of these Java types are not directly accessible on the <a href="object-declarations.html#companion-objects" id="z5qbxps_569">companion objects</a> of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. <code class="code" id="z5qbxps_570">java.lang.Integer.toHexString(foo)</code>.</p></aside></section><section class="chapter"><h2 id="java-generics-in-kotlin" data-toc="java-generics-in-kotlin">Java generics in Kotlin</h2><p id="z5qbxps_571">Kotlin's generics are a little different from Java's (see <a href="generics.html" id="z5qbxps_575">Generics</a>). When importing Java types to Kotlin, the following conversions are done:</p><ul class="list _bullet" id="z5qbxps_572"><li class="list__item" id="z5qbxps_576"><p id="z5qbxps_578">Java's wildcards are converted into type projections:</p><ul class="list _bullet" id="z5qbxps_579"><li class="list__item" id="z5qbxps_580"><p id="z5qbxps_582"><code class="code" id="z5qbxps_583">Foo&lt;? extends Bar&gt;</code> becomes <code class="code" id="z5qbxps_584">Foo&lt;out Bar!&gt;!</code></p></li><li class="list__item" id="z5qbxps_581"><p id="z5qbxps_585"><code class="code" id="z5qbxps_586">Foo&lt;? super Bar&gt;</code> becomes <code class="code" id="z5qbxps_587">Foo&lt;in Bar!&gt;!</code></p></li></ul></li><li class="list__item" id="z5qbxps_577"><p id="z5qbxps_588">Java's raw types are converted into star projections:</p><ul class="list _bullet" id="z5qbxps_589"><li class="list__item" id="z5qbxps_590"><p id="z5qbxps_591"><code class="code" id="z5qbxps_592">List</code> becomes <code class="code" id="z5qbxps_593">List&lt;*&gt;!</code> that is <code class="code" id="z5qbxps_594">List&lt;out Any?&gt;!</code></p></li></ul></li></ul><p id="z5qbxps_573">Like Java's, Kotlin's generics are not retained at runtime: objects do not carry information about actual type arguments passed to their constructors. For example, <code class="code" id="z5qbxps_595">ArrayList&lt;Integer&gt;()</code> is indistinguishable from <code class="code" id="z5qbxps_596">ArrayList&lt;Character&gt;()</code>. This makes it impossible to perform <code class="code" id="z5qbxps_597">is</code>-checks that take generics into account. Kotlin only allows <code class="code" id="z5qbxps_598">is</code>-checks for star-projected generic types:</p><div class="code-block" data-lang="kotlin">
if (a is List&lt;Int&gt;) // Error: cannot check if it is really a List of Ints
// but
if (a is List&lt;*&gt;) // OK: no guarantees about the contents of the list
</div></section><section class="chapter"><h2 id="java-arrays" data-toc="java-arrays">Java arrays</h2><p id="z5qbxps_599">Arrays in Kotlin are invariant, unlike Java. This means that Kotlin won't let you assign an <code class="code" id="z5qbxps_611">Array&lt;String&gt;</code> to an <code class="code" id="z5qbxps_612">Array&lt;Any&gt;</code>, which prevents a possible runtime failure. Passing an array of a subclass as an array of superclass to a Kotlin method is also prohibited, but for Java methods this is allowed through <a href="#null-safety-and-platform-types" id="z5qbxps_613">platform types</a> of the form <code class="code" id="z5qbxps_614">Array&lt;(out) String&gt;!</code>.</p><p id="z5qbxps_600">Arrays are used with primitive datatypes on the Java platform to avoid the cost of boxing/unboxing operations. As Kotlin hides those implementation details, a workaround is required to interface with Java code. There are specialized classes for every type of primitive array (<code class="code" id="z5qbxps_615">IntArray</code>, <code class="code" id="z5qbxps_616">DoubleArray</code>, <code class="code" id="z5qbxps_617">CharArray</code>, and so on) to handle this case. They are not related to the <code class="code" id="z5qbxps_618">Array</code> class and are compiled down to Java's primitive arrays for maximum performance.</p><p id="z5qbxps_601">Suppose there is a Java method that accepts an int array of indices:</p><div class="code-block" data-lang="java">
public class JavaArrayExample {
    public void removeIndices(int[] indices) {
        // code here...
    }
}
</div><p id="z5qbxps_603">To pass an array of primitive values, you can do the following in Kotlin:</p><div class="code-block" data-lang="kotlin">
val javaObj = JavaArrayExample()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndices(array)  // passes int[] to method
</div><p id="z5qbxps_605">When compiling to the JVM bytecode, the compiler optimizes access to arrays so that there's no overhead introduced:</p><div class="code-block" data-lang="kotlin">
val array = arrayOf(1, 2, 3, 4)
array[1] = array[1] * 2 // no actual calls to get() and set() generated
for (x in array) { // no iterator created
    print(x)
}
</div><p id="z5qbxps_607">Even when you navigate with an index, it does not introduce any overhead:</p><div class="code-block" data-lang="kotlin">
for (i in array.indices) { // no iterator created
    array[i] += 2
}
</div><p id="z5qbxps_609">Finally, <code class="code" id="z5qbxps_619">in</code>-checks have no overhead either:</p><div class="code-block" data-lang="kotlin">
if (i in array.indices) { // same as (i &gt;= 0 &amp;&amp; i &lt; array.size)
    print(array[i])
}
</div></section><section class="chapter"><h2 id="java-varargs" data-toc="java-varargs">Java varargs</h2><p id="z5qbxps_620">Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</p><div class="code-block" data-lang="java">
public class JavaArrayExample {

    public void removeIndicesVarArg(int... indices) {
        // code here...
    }
}
</div><p id="z5qbxps_622">In that case you need to use the spread operator <code class="code" id="z5qbxps_624">*</code> to pass the <code class="code" id="z5qbxps_625">IntArray</code>:</p><div class="code-block" data-lang="kotlin">
val javaObj = JavaArrayExample()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndicesVarArg(*array)
</div></section><section class="chapter"><h2 id="operators" data-toc="operators">Operators</h2><p id="z5qbxps_626">Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any Java methods with the right name and signature as operator overloads and other conventions (<code class="code" id="z5qbxps_627">invoke()</code> etc.) Calling Java methods using the infix call syntax is not allowed.</p></section><section class="chapter"><h2 id="checked-exceptions" data-toc="checked-exceptions">Checked exceptions</h2><p id="z5qbxps_628">In Kotlin, all <a href="exceptions.html" id="z5qbxps_630">exceptions are unchecked</a>, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</p><div class="code-block" data-lang="kotlin">
fun render(list: List&lt;*&gt;, to: Appendable) {
    for (item in list) {
        to.append(item.toString()) // Java would require us to catch IOException here
    }
}
</div></section><section class="chapter"><h2 id="object-methods" data-toc="object-methods">Object methods</h2><p id="z5qbxps_631">When Java types are imported into Kotlin, all the references of the type <code class="code" id="z5qbxps_636">java.lang.Object</code> are turned into <code class="code" id="z5qbxps_637">Any</code>. Since <code class="code" id="z5qbxps_638">Any</code> is not platform-specific, it only declares <code class="code" id="z5qbxps_639">toString()</code>, <code class="code" id="z5qbxps_640">hashCode()</code> and <code class="code" id="z5qbxps_641">equals()</code> as its members, so to make other members of <code class="code" id="z5qbxps_642">java.lang.Object</code> available, Kotlin uses <a href="extensions.html" id="z5qbxps_643">extension functions</a>.</p><section class="chapter"><h3 id="wait-notify" data-toc="wait-notify">wait()/notify()</h3><p id="z5qbxps_644">Methods <code class="code" id="z5qbxps_646">wait()</code> and <code class="code" id="z5qbxps_647">notify()</code> are not available on references of type <code class="code" id="z5qbxps_648">Any</code>. Their usage is generally discouraged in favor of <code class="code" id="z5qbxps_649">java.util.concurrent</code>. If you really need to call these methods, you can cast to <code class="code" id="z5qbxps_650">java.lang.Object</code>:</p><div class="code-block" data-lang="kotlin">
(foo as java.lang.Object).wait()
</div></section><section class="chapter"><h3 id="getclass" data-toc="getclass">getClass()</h3><p id="z5qbxps_651">To retrieve the Java class of an object, use the <code class="code" id="z5qbxps_655">java</code> extension property on a <a href="reflection.html#class-references" id="z5qbxps_656">class reference</a>:</p><div class="code-block" data-lang="kotlin">
val fooClass = foo::class.java
</div><p id="z5qbxps_653">The code above uses a <a href="reflection.html#bound-class-references" id="z5qbxps_657">bound class reference</a>. You can also use the <code class="code" id="z5qbxps_658">javaClass</code> extension property:</p><div class="code-block" data-lang="kotlin">
val fooClass = foo.javaClass
</div></section><section class="chapter"><h3 id="clone" data-toc="clone">clone()</h3><p id="z5qbxps_659">To override <code class="code" id="z5qbxps_662">clone()</code>, your class needs to extend <code class="code" id="z5qbxps_663">kotlin.Cloneable</code>:</p><div class="code-block" data-lang="kotlin">
class Example : Cloneable {
    override fun clone(): Any { ... }
}
</div><p id="z5qbxps_661">Don't forget about <a href="https://www.oracle.com/technetwork/java/effectivejava-136174.html" id="z5qbxps_664" data-external="true" rel="noopener noreferrer" target="_blank">Effective Java, 3rd Edition</a>, Item 13: <span class="emphasis" id="z5qbxps_665">Override clone judiciously</span>.</p></section><section class="chapter"><h3 id="finalize" data-toc="finalize">finalize()</h3><p id="z5qbxps_666">To override <code class="code" id="z5qbxps_669">finalize()</code>, all you need to do is simply declare it, without using the <code class="code" id="z5qbxps_670">override</code> keyword:</p><div class="code-block" data-lang="kotlin">
class C {
    protected fun finalize() {
        // finalization logic
    }
}
</div><p id="z5qbxps_668">According to Java's rules, <code class="code" id="z5qbxps_671">finalize()</code> must not be <code class="code" id="z5qbxps_672">private</code>.</p></section></section><section class="chapter"><h2 id="inheritance-from-java-classes" data-toc="inheritance-from-java-classes">Inheritance from Java classes</h2><p id="z5qbxps_673">At most one Java class (and as many Java interfaces as you like) can be a supertype for a class in Kotlin.</p></section><section class="chapter"><h2 id="accessing-static-members" data-toc="accessing-static-members">Accessing static members</h2><p id="z5qbxps_674">Static members of Java classes form &quot;companion objects&quot; for these classes. You can't pass such a &quot;companion object&quot; around as a value but can access the members explicitly, for example:</p><div class="code-block" data-lang="kotlin">
if (Character.isLetter(a)) { ... }
</div><p id="z5qbxps_676">To access static members of a Java type that is <a href="#mapped-types" id="z5qbxps_677">mapped</a> to a Kotlin type, use the full qualified name of the Java type: <code class="code" id="z5qbxps_678">java.lang.Integer.bitCount(foo)</code>.</p></section><section class="chapter"><h2 id="java-reflection" data-toc="java-reflection">Java reflection</h2><p id="z5qbxps_679">Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use <code class="code" id="z5qbxps_682">instance::class.java</code>, <code class="code" id="z5qbxps_683">ClassName::class.java</code> or <code class="code" id="z5qbxps_684">instance.javaClass</code> to enter Java reflection through <code class="code" id="z5qbxps_685">java.lang.Class</code>. Do not use <code class="code" id="z5qbxps_686">ClassName.javaClass</code> for this purpose because it refers to <code class="code" id="z5qbxps_687">ClassName</code>'s companion object class, which is the same as <code class="code" id="z5qbxps_688">ClassName.Companion::class.java</code> and not <code class="code" id="z5qbxps_689">ClassName::class.java</code>.</p><p id="z5qbxps_680">For each primitive type, there are two different Java classes, and Kotlin provides ways to get both. For example, <code class="code" id="z5qbxps_690">Int::class.java</code> will return the class instance representing the primitive type itself, corresponding to <code class="code" id="z5qbxps_691">Integer.TYPE</code> in Java. To get the class of the corresponding wrapper type, use <code class="code" id="z5qbxps_692">Int::class.javaObjectType</code>, which is equivalent of Java's <code class="code" id="z5qbxps_693">Integer.class</code>.</p><p id="z5qbxps_681">Other supported cases include acquiring a Java getter/setter method or a backing field for a Kotlin property, a <code class="code" id="z5qbxps_694">KProperty</code> for a Java field, a Java method or constructor for a <code class="code" id="z5qbxps_695">KFunction</code> and vice versa.</p></section><section class="chapter"><h2 id="sam-conversions" data-toc="sam-conversions">SAM conversions</h2><p id="z5qbxps_696">Kotlin supports SAM conversions for both Java and <a href="fun-interfaces.html" id="z5qbxps_704">Kotlin interfaces</a>. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</p><p id="z5qbxps_697">You can use this for creating instances of SAM interfaces:</p><div class="code-block" data-lang="kotlin">
val runnable = Runnable { println(&quot;This runs in a runnable&quot;) }
</div><p id="z5qbxps_699">...and in method calls:</p><div class="code-block" data-lang="kotlin">
val executor = ThreadPoolExecutor()
// Java signature: void execute(Runnable command)
executor.execute { println(&quot;This runs in a thread pool&quot;) }
</div><p id="z5qbxps_701">If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed:</p><div class="code-block" data-lang="kotlin">
executor.execute(Runnable { println(&quot;This runs in a thread pool&quot;) })
</div><aside class="prompt" data-type="note" data-title="" id="z5qbxps_703"><p id="z5qbxps_705">SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</p></aside></section><section class="chapter"><h2 id="using-jni-with-kotlin" data-toc="using-jni-with-kotlin">Using JNI with Kotlin</h2><p id="z5qbxps_706">To declare a function that is implemented in native (C or C++) code, you need to mark it with the <code class="code" id="z5qbxps_712">external</code> modifier:</p><div class="code-block" data-lang="kotlin">
external fun foo(x: Int): Double
</div><p id="z5qbxps_708">The rest of the procedure works in exactly the same way as in Java.</p><p id="z5qbxps_709">You can also mark property getters and setters as <code class="code" id="z5qbxps_713">external</code>:</p><div class="code-block" data-lang="kotlin">
var myProperty: String
    external get
    external set
</div><p id="z5qbxps_711">Behind the scenes, this will create two functions <code class="code" id="z5qbxps_714">getMyProperty</code> and <code class="code" id="z5qbxps_715">setMyProperty</code>, both marked as <code class="code" id="z5qbxps_716">external</code>.</p></section><section class="chapter"><h2 id="using-lombok-generated-declarations-in-kotlin" data-toc="using-lombok-generated-declarations-in-kotlin">Using Lombok-generated declarations in Kotlin</h2><p id="z5qbxps_717">You can use Java's Lombok-generated declarations in Kotlin code. If you need to generate and use these declarations in the same mixed Java/Kotlin module, you can learn how to do this on the <a href="lombok.html" id="z5qbxps_718">Lombok compiler plugin's page</a>. If you call such declarations from another module, then you don't need to use this plugin to compile that module.</p></section><div class="last-modified">04 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="comparison-to-java.html" class="navigation-links__prev">Comparison to Java</a><a href="java-to-kotlin-interop.html" class="navigation-links__next">Calling Kotlin from Java</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>