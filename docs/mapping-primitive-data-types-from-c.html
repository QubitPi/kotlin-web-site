<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-27T02:41:36.554396139"><link rel="canonical" href="https://kotlinlang.org/docs/mapping-primitive-data-types-from-c.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Mapping primitive data types from C &ndash; tutorial | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"types-in-c-language","level":0,"title":"Types in C language","anchor":"#types-in-c-language"},{"id":"create-a-c-library","level":0,"title":"Create a C library","anchor":"#create-a-c-library"},{"id":"create-a-kotlin-native-project","level":0,"title":"Create a Kotlin/Native project","anchor":"#create-a-kotlin-native-project"},{"id":"inspect-generated-kotlin-apis-for-a-c-library","level":0,"title":"Inspect generated Kotlin APIs for a C library","anchor":"#inspect-generated-kotlin-apis-for-a-c-library"},{"id":"update-kotlin-code","level":0,"title":"Update Kotlin code","anchor":"#update-kotlin-code"},{"id":"next-step","level":0,"title":"Next step","anchor":"#next-step"},{"id":"see-also","level":1,"title":"See also","anchor":"#see-also"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Mapping primitive data types from C &ndash; tutorial | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/mapping-primitive-data-types-from-c.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Mapping primitive data types from C &ndash; tutorial | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/mapping-primitive-data-types-from-c.html#webpage",
    "url": "https://kotlinlang.org/docs/mapping-primitive-data-types-from-c.html",
    "name": "Mapping primitive data types from C &ndash; tutorial | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="mapping-primitive-data-types-from-c" data-main-title="Mapping primitive data types from C – tutorial" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///Native///C interop" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/native/mapping-primitive-data-types-from-c.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="mapping-primitive-data-types-from-c" id="mapping-primitive-data-types-from-c.md">Mapping primitive data types from C – tutorial</h1><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-9l263w_14\&quot;\u003eThis is the first part of the \u003cb id\u003d\&quot;-9l263w_16\&quot;\u003eMapping Kotlin and C\u003c/b\u003e tutorial series.\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-9l263w_15\&quot;\u003e\u003cimg alt\u003d\&quot;First step\&quot; src\u003d\&quot;images/icon-1.svg\&quot; class\u003d\&quot;inline-icon-\&quot; title\u003d\&quot;First step\&quot; id\u003d\&quot;-9l263w_17\&quot; width\u003d\&quot;20\&quot; height\u003d\&quot;20\&quot;\u003e \u003cb id\u003d\&quot;-9l263w_18\&quot;\u003eMapping primitive data types from C\u003c/b\u003e\u003cbr\u003e \u003cimg alt\u003d\&quot;Second step\&quot; src\u003d\&quot;images/icon-2-todo.svg\&quot; class\u003d\&quot;inline-icon-\&quot; title\u003d\&quot;Second step\&quot; id\u003d\&quot;-9l263w_20\&quot; width\u003d\&quot;20\&quot; height\u003d\&quot;20\&quot;\u003e \u003ca href\u003d\&quot;mapping-struct-union-types-from-c.html\&quot; id\u003d\&quot;-9l263w_21\&quot;\u003eMapping struct and union types from C\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\&quot;Third step\&quot; src\u003d\&quot;images/icon-3-todo.svg\&quot; class\u003d\&quot;inline-icon-\&quot; title\u003d\&quot;Third step\&quot; id\u003d\&quot;-9l263w_23\&quot; width\u003d\&quot;20\&quot; height\u003d\&quot;20\&quot;\u003e \u003ca href\u003d\&quot;mapping-function-pointers-from-c.html\&quot; id\u003d\&quot;-9l263w_24\&quot;\u003eMapping function pointers\u003c/a\u003e\u003cbr\u003e \u003cimg alt\u003d\&quot;Fourth step\&quot; src\u003d\&quot;images/icon-4-todo.svg\&quot; class\u003d\&quot;inline-icon-\&quot; title\u003d\&quot;Fourth step\&quot; id\u003d\&quot;-9l263w_26\&quot; width\u003d\&quot;20\&quot; height\u003d\&quot;20\&quot;\u003e \u003ca href\u003d\&quot;mapping-strings-from-c.html\&quot; id\u003d\&quot;-9l263w_27\&quot;\u003eMapping strings from C\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e&quot;]}"></div><aside class="prompt" data-type="warning" data-title="" id="-9l263w_3"><p id="-9l263w_29">The C libraries import is <a href="components-stability.html#stability-levels-explained" id="-9l263w_31">Experimental</a>. All Kotlin declarations generated by the cinterop tool from C libraries should have the <code class="code" id="-9l263w_32">@ExperimentalForeignApi</code> annotation.</p><p id="-9l263w_30">Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.</p></aside><p id="-9l263w_4">Let's explore which C data types are visible in Kotlin/Native and vice versa and examine advanced C interop-related use cases of Kotlin/Native and <a href="gradle-configure-project.html#targeting-multiple-platforms" id="-9l263w_33">multiplatform</a> Gradle builds.</p><p id="-9l263w_5">In this tutorial, you'll:</p><ul class="list _bullet" id="-9l263w_6"><li class="list__item" id="-9l263w_34"><p id="-9l263w_37"><a href="#types-in-c-language" id="-9l263w_38">Learn about data types in the C language</a></p></li><li class="list__item" id="-9l263w_35"><p id="-9l263w_39"><a href="#create-a-c-library" id="-9l263w_40">Create a C Library that uses those types in exports</a></p></li><li class="list__item" id="-9l263w_36"><p id="-9l263w_41"><a href="#inspect-generated-kotlin-apis-for-a-c-library" id="-9l263w_42">Inspect generated Kotlin APIs from a C library</a></p></li></ul><p id="-9l263w_7">You can use the command line to generate a Kotlin library, either directly or with a script file (such as <code class="code" id="-9l263w_43">.sh</code> or <code class="code" id="-9l263w_44">.bat</code> file). However, this approach doesn't scale well for larger projects that have hundreds of files and libraries. Using a build system simplifies the process by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, as well as by running the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="-9l263w_45" data-external="true" rel="noopener noreferrer" target="_blank">Gradle</a> build system through the <a href="gradle-configure-project.html#targeting-multiple-platforms" id="-9l263w_46">Kotlin Multiplatform plugin</a>.</p><section class="chapter"><h2 id="types-in-c-language" data-toc="types-in-c-language">Types in C language</h2><p id="-9l263w_47">The C programming language has the following <a href="https://en.wikipedia.org/wiki/C_data_types" id="-9l263w_53" data-external="true" rel="noopener noreferrer" target="_blank">data types</a>:</p><ul class="list _bullet" id="-9l263w_48"><li class="list__item" id="-9l263w_54"><p id="-9l263w_58">Basic types: <code class="code" id="-9l263w_59">char, int, float, double</code> with modifiers <code class="code" id="-9l263w_60">signed, unsigned, short, long</code></p></li><li class="list__item" id="-9l263w_55"><p id="-9l263w_61">Structures, unions, arrays</p></li><li class="list__item" id="-9l263w_56"><p id="-9l263w_62">Pointers</p></li><li class="list__item" id="-9l263w_57"><p id="-9l263w_63">Function pointers</p></li></ul><p id="-9l263w_49">There are also more specific types:</p><ul class="list _bullet" id="-9l263w_50"><li class="list__item" id="-9l263w_64"><p id="-9l263w_67">Boolean type (from <a href="https://en.wikipedia.org/wiki/C99" id="-9l263w_68" data-external="true" rel="noopener noreferrer" target="_blank">C99</a>)</p></li><li class="list__item" id="-9l263w_65"><p id="-9l263w_69"><code class="code" id="-9l263w_70">size_t</code> and <code class="code" id="-9l263w_71">ptrdiff_t</code> (also <code class="code" id="-9l263w_72">ssize_t</code>)</p></li><li class="list__item" id="-9l263w_66"><p id="-9l263w_73">Fixed width integer types, such as <code class="code" id="-9l263w_74">int32_t</code> or <code class="code" id="-9l263w_75">uint64_t</code> (from <a href="https://en.wikipedia.org/wiki/C99" id="-9l263w_76" data-external="true" rel="noopener noreferrer" target="_blank">C99</a>)</p></li></ul><p id="-9l263w_51">There are also the following type qualifiers in the C language: <code class="code" id="-9l263w_77">const</code>, <code class="code" id="-9l263w_78">volatile</code>, <code class="code" id="-9l263w_79">restrict</code>, <code class="code" id="-9l263w_80">atomic</code>.</p><p id="-9l263w_52">Let's see which C data types are visible in Kotlin.</p></section><section class="chapter"><h2 id="create-a-c-library" data-toc="create-a-c-library">Create a C library</h2><p id="-9l263w_81">In this tutorial, you won't create a <code class="code" id="-9l263w_86">lib.c</code> source file, which is only necessary if you want to compile and run your C library. For this setup, you'll only need a <code class="code" id="-9l263w_87">.h</code> header file that is required for running the <a href="native-c-interop.html" id="-9l263w_88">cinterop tool</a>.</p><p id="-9l263w_82">The cinterop tool generates a Kotlin/Native library (a <code class="code" id="-9l263w_89">.klib</code> file) for each set of <code class="code" id="-9l263w_90">.h</code> files. The generated library helps bridge calls from Kotlin/Native to C. It includes Kotlin declarations that correspond to the definitions from the <code class="code" id="-9l263w_91">.h</code> files.</p><p id="-9l263w_83">To create a C library:</p><ol class="list _decimal" id="-9l263w_84" type="1"><li class="list__item" id="-9l263w_92"><p id="-9l263w_96">Create an empty folder for your future project.</p></li><li class="list__item" id="-9l263w_93"><p id="-9l263w_97">Inside, create a <code class="code" id="-9l263w_100">lib.h</code> file with the following content to see how C functions are mapped into Kotlin:</p><div class="code-block" data-lang="c">
#ifndef LIB2_H_INCLUDED
#define LIB2_H_INCLUDED

void ints(char c, short d, int e, long f);
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f);
void doubles(float a, double b);

#endif
</div><p id="-9l263w_99">The file doesn't have the <code class="code" id="-9l263w_101">extern &quot;C&quot;</code> block, which is not needed for this example but may be necessary if you use C++ and overloaded functions. See this <a href="https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c" id="-9l263w_102" data-external="true" rel="noopener noreferrer" target="_blank">Stackoverflow thread</a> for more details.</p></li><li class="list__item" id="-9l263w_94"><p id="-9l263w_103">Create the <code class="code" id="-9l263w_105">lib.def</code> <a href="native-definition-file.html" id="-9l263w_106">definition file</a> with the following content:</p><div class="code-block" data-lang="c">
headers = lib.h
</div></li><li class="list__item" id="-9l263w_95"><p id="-9l263w_107">It can be helpful to include macros or other C definitions in the code generated by the cinterop tool. This way, method bodies are also compiled and fully included in the binary. With this feature, you can create a runnable example without needing a C compiler.</p><p id="-9l263w_108">To do that, add implementations to the C functions from the <code class="code" id="-9l263w_110">lib.h</code> file to a new <code class="code" id="-9l263w_111">interop.def</code> file after the <code class="code" id="-9l263w_112">---</code> separator:</p><div class="code-block" data-lang="c">

---

void ints(char c, short d, int e, long f) { }
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f) { }
void doubles(float a, double b) { }
</div></li></ol><p id="-9l263w_85">The <code class="code" id="-9l263w_113">interop.def</code> file provides everything necessary to compile, run, or open the application in an IDE.</p></section><section class="chapter"><h2 id="create-a-kotlin-native-project" data-toc="create-a-kotlin-native-project">Create a Kotlin/Native project</h2><aside class="prompt" data-type="tip" data-title="" id="-9l263w_114"><p id="-9l263w_118">See the <a href="native-get-started.html#using-gradle" id="-9l263w_119">Get started with Kotlin/Native</a> tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.</p></aside><p id="-9l263w_115">To create project files:</p><ol class="list _decimal" id="-9l263w_116" type="1"><li class="list__item" id="-9l263w_120"><p id="-9l263w_124">In your project folder, create a <code class="code" id="-9l263w_127">build.gradle(.kts)</code> Gradle build file with the following content:</p><div class="tabs" id="-9l263w_125" data-group="build-script" data-anchors="[-9l263w_128,-9l263w_129]"><div class="tabs__content" data-gtm="tab" id="-9l263w_128" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
plugins {
    kotlin(&quot;multiplatform&quot;) version &quot;2.2.0&quot;
}

repositories {
    mavenCentral()
}

kotlin {
    macosArm64(&quot;native&quot;) {    // macOS on Apple Silicon
    // macosX64(&quot;native&quot;) {   // macOS on x86_64 platforms
    // linuxArm64(&quot;native&quot;) { // Linux on ARM64 platforms 
    // linuxX64(&quot;native&quot;) {   // Linux on x86_64 platforms
    // mingwX64(&quot;native&quot;) {   // on Windows
        val main by compilations.getting
        val interop by main.cinterops.creating

        binaries {
            executable()
        }
    }
}

tasks.wrapper {
    gradleVersion = &quot;8.14&quot;
    distributionType = Wrapper.DistributionType.BIN
}
</div></div><div class="tabs__content" data-gtm="tab" id="-9l263w_129" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.2.0'
}

repositories {
    mavenCentral()
}

kotlin {
    macosArm64(&quot;native&quot;) {    // Apple Silicon macOS
    // macosX64(&quot;native&quot;) {   // macOS on x86_64 platforms
    // linuxArm64(&quot;native&quot;) { // Linux on ARM64 platforms
    // linuxX64(&quot;native&quot;) {   // Linux on x86_64 platforms
    // mingwX64(&quot;native&quot;) {   // Windows
        compilations.main.cinterops {
            interop 
        }

        binaries {
            executable()
        }
    }
}

wrapper {
    gradleVersion = '8.14'
    distributionType = 'BIN'
}
</div></div></div><p id="-9l263w_126">The project file configures the C interop as an additional build step. Check out the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html" id="-9l263w_132" data-external="true" rel="noopener noreferrer" target="_blank">Multiplatform Gradle DSL reference</a> to learn about different ways you can configure it.</p></li><li class="list__item" id="-9l263w_121"><p id="-9l263w_133">Move your <code class="code" id="-9l263w_134">interop.def</code>, <code class="code" id="-9l263w_135">lib.h</code>, and <code class="code" id="-9l263w_136">lib.def</code> files to the <code class="code" id="-9l263w_137">src/nativeInterop/cinterop</code> directory.</p></li><li class="list__item" id="-9l263w_122"><p id="-9l263w_138">Create a <code class="code" id="-9l263w_140">src/nativeMain/kotlin</code> directory. This is where you should place all the source files, following Gradle's recommendations on using conventions instead of configurations.</p><p id="-9l263w_139">By default, all the symbols from C are imported to the <code class="code" id="-9l263w_141">interop</code> package.</p></li><li class="list__item" id="-9l263w_123"><p id="-9l263w_142">In <code class="code" id="-9l263w_144">src/nativeMain/kotlin</code>, create a <code class="code" id="-9l263w_145">hello.kt</code> stub file with the following content:</p><div class="code-block" data-lang="kotlin">
import interop.*
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println(&quot;Hello Kotlin/Native!&quot;)

    ints(/* fix me*/)
    uints(/* fix me*/)
    doubles(/* fix me*/)
}
</div></li></ol><p id="-9l263w_117">You'll complete the code later as you learn how C primitive type declarations look from the Kotlin side.</p></section><section class="chapter"><h2 id="inspect-generated-kotlin-apis-for-a-c-library" data-toc="inspect-generated-kotlin-apis-for-a-c-library">Inspect generated Kotlin APIs for a C library</h2><p id="-9l263w_146">Let's see how C primitive types are mapped into Kotlin/Native and update the example project accordingly.</p><p id="-9l263w_147">Use IntelliJ IDEA's <a href="https://www.jetbrains.com/help/rider/Navigation_and_Search__Go_to_Declaration.html" id="-9l263w_151" data-external="true" rel="noopener noreferrer" target="_blank">Go to declaration</a> command (<kbd class="keystroke" id="-9l263w_152" data-bypass="true"><span class="keystroke__value">Cmd + B</span></kbd>/<kbd class="keystroke" id="-9l263w_153" data-bypass="true"><span class="keystroke__value">Ctrl + B</span></kbd>) to navigate to the following generated API for C functions:</p><div class="code-block" data-lang="kotlin">
fun ints(c: kotlin.Byte, d: kotlin.Short, e: kotlin.Int, f: kotlin.Long)
fun uints(c: kotlin.UByte, d: kotlin.UShort, e: kotlin.UInt, f: kotlin.ULong)
fun doubles(a: kotlin.Float, b: kotlin.Double)
</div><p id="-9l263w_149">C types are mapped directly, except for the <code class="code" id="-9l263w_154">char</code> type, which is mapped to <code class="code" id="-9l263w_155">kotlin.Byte</code> as it's usually an 8-bit signed value:</p><div class="table-wrapper"><table class="wide" id="-9l263w_150"><thead><tr class="ijRowHead" id="-9l263w_156"><th id="-9l263w_167"><p>C</p></th><th id="-9l263w_168"><p>Kotlin</p></th></tr></thead><tbody><tr id="-9l263w_157"><td id="-9l263w_169"><p>char</p></td><td id="-9l263w_170"><p>kotlin.Byte</p></td></tr><tr id="-9l263w_158"><td id="-9l263w_171"><p>unsigned char</p></td><td id="-9l263w_172"><p>kotlin.UByte</p></td></tr><tr id="-9l263w_159"><td id="-9l263w_173"><p>short</p></td><td id="-9l263w_174"><p>kotlin.Short</p></td></tr><tr id="-9l263w_160"><td id="-9l263w_175"><p>unsigned short</p></td><td id="-9l263w_176"><p>kotlin.UShort</p></td></tr><tr id="-9l263w_161"><td id="-9l263w_177"><p>int</p></td><td id="-9l263w_178"><p>kotlin.Int</p></td></tr><tr id="-9l263w_162"><td id="-9l263w_179"><p>unsigned int</p></td><td id="-9l263w_180"><p>kotlin.UInt</p></td></tr><tr id="-9l263w_163"><td id="-9l263w_181"><p>long long</p></td><td id="-9l263w_182"><p>kotlin.Long</p></td></tr><tr id="-9l263w_164"><td id="-9l263w_183"><p>unsigned long long</p></td><td id="-9l263w_184"><p>kotlin.ULong</p></td></tr><tr id="-9l263w_165"><td id="-9l263w_185"><p>float</p></td><td id="-9l263w_186"><p>kotlin.Float</p></td></tr><tr id="-9l263w_166"><td id="-9l263w_187"><p>double</p></td><td id="-9l263w_188"><p>kotlin.Double</p></td></tr></tbody></table></div></section><section class="chapter"><h2 id="update-kotlin-code" data-toc="update-kotlin-code">Update Kotlin code</h2><p id="-9l263w_189">Now that you've seen the C definitions, you can update your Kotlin code. The final code in the <code class="code" id="-9l263w_193">hello.kt</code> file may look like this:</p><div class="code-block" data-lang="kotlin">
import interop.*
import kotlinx.cinterop.ExperimentalForeignApi

@OptIn(ExperimentalForeignApi::class)
fun main() {
    println(&quot;Hello Kotlin/Native!&quot;)
  
    ints(1, 2, 3, 4)
    uints(5u, 6u, 7u, 8u)
    doubles(9.0f, 10.0)
}
</div><p id="-9l263w_191">To verify that everything works as expected, run the <code class="code" id="-9l263w_194">runDebugExecutableNative</code> Gradle task <a href="native-get-started.html#build-and-run-the-application" id="-9l263w_195">in your IDE</a> or use the following command to run the code:</p><div class="code-block" data-lang="bash">
./gradlew runDebugExecutableNative
</div></section><section class="chapter"><h2 id="next-step" data-toc="next-step">Next step</h2><p id="-9l263w_196">In the next part of the series, you'll learn how struct and union types are mapped between Kotlin and C:</p><p id="-9l263w_197"><span class="control" id="-9l263w_199"><a href="mapping-struct-union-types-from-c.html" id="-9l263w_200">Proceed to the next part</a></span></p><section class="chapter"><h3 id="see-also" data-toc="see-also">See also</h3><p id="-9l263w_201">Learn more in the <a href="native-c-interop.html" id="-9l263w_202">Interoperability with C</a> documentation that covers more advanced scenarios.</p></section></section><div class="last-modified">27 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="native-c-interop.html" class="navigation-links__prev">Interoperability with C</a><a href="mapping-struct-union-types-from-c.html" class="navigation-links__next">Mapping struct and union types from C &ndash; tutorial</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>