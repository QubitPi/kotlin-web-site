<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-05T00:45:41.582802548"><link rel="canonical" href="https://kotlinlang.org/docs/compatibility-guide-14.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Compatibility guide for Kotlin 1.4 | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"basic-terms","level":0,"title":"Basic terms","anchor":"#basic-terms"},{"id":"language-and-stdlib","level":0,"title":"Language and stdlib","anchor":"#language-and-stdlib"},{"id":"unexpected-behavior-with-in-infix-operator-and-concurrenthashmap","level":1,"title":"Unexpected behavior with in infix operator and ConcurrentHashMap","anchor":"#unexpected-behavior-with-in-infix-operator-and-concurrenthashmap"},{"id":"prohibit-access-to-protected-members-inside-public-inline-members","level":1,"title":"Prohibit access to protected members inside public inline members","anchor":"#prohibit-access-to-protected-members-inside-public-inline-members"},{"id":"contracts-on-calls-with-implicit-receivers","level":1,"title":"Contracts on calls with implicit receivers","anchor":"#contracts-on-calls-with-implicit-receivers"},{"id":"inconsistent-behavior-of-floating-point-number-comparisons","level":1,"title":"Inconsistent behavior of floating-point number comparisons","anchor":"#inconsistent-behavior-of-floating-point-number-comparisons"},{"id":"no-smart-cast-on-the-last-expression-in-a-generic-lambda","level":1,"title":"No smart cast on the last expression in a generic lambda","anchor":"#no-smart-cast-on-the-last-expression-in-a-generic-lambda"},{"id":"do-not-depend-on-the-order-of-lambda-arguments-to-coerce-result-to-unit","level":1,"title":"Do not depend on the order of lambda arguments to coerce result to Unit","anchor":"#do-not-depend-on-the-order-of-lambda-arguments-to-coerce-result-to-unit"},{"id":"wrong-common-supertype-between-raw-and-integer-literal-type-leads-to-unsound-code","level":1,"title":"Wrong common supertype between raw and integer literal type leads to unsound code","anchor":"#wrong-common-supertype-between-raw-and-integer-literal-type-leads-to-unsound-code"},{"id":"type-safety-problem-because-several-equal-type-variables-are-instantiated-with-a-different-types","level":1,"title":"Type safety problem because several equal type variables are instantiated with a different types","anchor":"#type-safety-problem-because-several-equal-type-variables-are-instantiated-with-a-different-types"},{"id":"type-safety-problem-because-of-incorrect-subtyping-for-intersection-types","level":1,"title":"Type safety problem because of incorrect subtyping for intersection types","anchor":"#type-safety-problem-because-of-incorrect-subtyping-for-intersection-types"},{"id":"no-type-mismatch-with-an-empty-when-expression-inside-lambda","level":1,"title":"No type mismatch with an empty when expression inside lambda","anchor":"#no-type-mismatch-with-an-empty-when-expression-inside-lambda"},{"id":"return-type-any-inferred-for-lambda-with-early-return-with-integer-literal-in-one-of-possible-return-values","level":1,"title":"Return type Any inferred for lambda with early return with integer literal in one of possible return values","anchor":"#return-type-any-inferred-for-lambda-with-early-return-with-integer-literal-in-one-of-possible-return-values"},{"id":"proper-capturing-of-star-projections-with-recursive-types","level":1,"title":"Proper capturing of star projections with recursive types","anchor":"#proper-capturing-of-star-projections-with-recursive-types"},{"id":"common-supertype-calculation-with-non-proper-type-and-flexible-one-leads-to-incorrect-results","level":1,"title":"Common supertype calculation with non-proper type and flexible one leads to incorrect results","anchor":"#common-supertype-calculation-with-non-proper-type-and-flexible-one-leads-to-incorrect-results"},{"id":"type-safety-problem-because-of-lack-of-captured-conversion-against-nullable-type-argument","level":1,"title":"Type safety problem because of lack of captured conversion against nullable type argument","anchor":"#type-safety-problem-because-of-lack-of-captured-conversion-against-nullable-type-argument"},{"id":"preserve-intersection-type-for-covariant-types-after-unchecked-cast","level":1,"title":"Preserve intersection type for covariant types after unchecked cast","anchor":"#preserve-intersection-type-for-covariant-types-after-unchecked-cast"},{"id":"type-variable-leaks-from-builder-inference-because-of-using-this-expression","level":1,"title":"Type variable leaks from builder inference because of using this expression","anchor":"#type-variable-leaks-from-builder-inference-because-of-using-this-expression"},{"id":"wrong-overload-resolution-for-contravariant-types-with-nullable-type-arguments","level":1,"title":"Wrong overload resolution for contravariant types with nullable type arguments","anchor":"#wrong-overload-resolution-for-contravariant-types-with-nullable-type-arguments"},{"id":"builder-inference-with-non-nested-recursive-constraints","level":1,"title":"Builder inference with non-nested recursive constraints","anchor":"#builder-inference-with-non-nested-recursive-constraints"},{"id":"eager-type-variable-fixation-leads-to-a-contradictory-constraint-system","level":1,"title":"Eager type variable fixation leads to a contradictory constraint system","anchor":"#eager-type-variable-fixation-leads-to-a-contradictory-constraint-system"},{"id":"prohibit-tailrec-modifier-on-open-functions","level":1,"title":"Prohibit tailrec modifier on open functions","anchor":"#prohibit-tailrec-modifier-on-open-functions"},{"id":"the-instance-field-of-a-companion-object-more-visible-than-the-companion-object-class-itself","level":1,"title":"The INSTANCE field of a companion object more visible than the companion object class itself","anchor":"#the-instance-field-of-a-companion-object-more-visible-than-the-companion-object-class-itself"},{"id":"outer-finally-block-inserted-before-return-is-not-excluded-from-the-catch-interval-of-the-inner-try-block-without-finally","level":1,"title":"Outer finally block inserted before return is not excluded from the catch interval of the inner try block without finally","anchor":"#outer-finally-block-inserted-before-return-is-not-excluded-from-the-catch-interval-of-the-inner-try-block-without-finally"},{"id":"use-the-boxed-version-of-an-inline-class-in-return-type-position-for-covariant-and-generic-specialized-overrides","level":1,"title":"Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides","anchor":"#use-the-boxed-version-of-an-inline-class-in-return-type-position-for-covariant-and-generic-specialized-overrides"},{"id":"do-not-declare-checked-exceptions-in-jvm-bytecode-when-using-delegation-to-kotlin-interfaces","level":1,"title":"Do not declare checked exceptions in JVM bytecode when using delegation to Kotlin interfaces","anchor":"#do-not-declare-checked-exceptions-in-jvm-bytecode-when-using-delegation-to-kotlin-interfaces"},{"id":"changed-behavior-of-signature-polymorphic-calls-to-methods-with-a-single-vararg-parameter-to-avoid-wrapping-the-argument-into-another-array","level":1,"title":"Changed behavior of signature-polymorphic calls to methods with a single vararg parameter to avoid wrapping the argument into another array","anchor":"#changed-behavior-of-signature-polymorphic-calls-to-methods-with-a-single-vararg-parameter-to-avoid-wrapping-the-argument-into-another-array"},{"id":"incorrect-generic-signature-in-annotations-when-kclass-is-used-as-a-generic-parameter","level":1,"title":"Incorrect generic signature in annotations when KClass is used as a generic parameter","anchor":"#incorrect-generic-signature-in-annotations-when-kclass-is-used-as-a-generic-parameter"},{"id":"forbid-spread-operator-in-signature-polymorphic-calls","level":1,"title":"Forbid spread operator in signature-polymorphic calls","anchor":"#forbid-spread-operator-in-signature-polymorphic-calls"},{"id":"change-initialization-order-of-default-values-for-tail-recursive-optimized-functions","level":1,"title":"Change initialization order of default values for tail-recursive optimized functions","anchor":"#change-initialization-order-of-default-values-for-tail-recursive-optimized-functions"},{"id":"do-not-generate-constantvalue-attribute-for-non-const-vals","level":1,"title":"Do not generate ConstantValue attribute for non-const vals","anchor":"#do-not-generate-constantvalue-attribute-for-non-const-vals"},{"id":"generated-overloads-for-jvmoverloads-on-open-methods-should-be-final","level":1,"title":"Generated overloads for @JvmOverloads on open methods should be final","anchor":"#generated-overloads-for-jvmoverloads-on-open-methods-should-be-final"},{"id":"lambdas-returning-kotlin-result-now-return-boxed-value-instead-of-unboxed","level":1,"title":"Lambdas returning kotlin.Result now return boxed value instead of unboxed","anchor":"#lambdas-returning-kotlin-result-now-return-boxed-value-instead-of-unboxed"},{"id":"unify-exceptions-from-null-checks","level":1,"title":"Unify exceptions from null checks","anchor":"#unify-exceptions-from-null-checks"},{"id":"comparing-floating-point-values-in-array-list-operations-contains-indexof-lastindexof-ieee-754-or-total-order","level":1,"title":"Comparing floating-point values in array/list operations contains, indexOf, lastIndexOf: IEEE 754 or total order","anchor":"#comparing-floating-point-values-in-array-list-operations-contains-indexof-lastindexof-ieee-754-or-total-order"},{"id":"gradually-change-the-return-type-of-collection-min-and-max-functions-to-non-nullable","level":1,"title":"Gradually change the return type of collection min and max functions to non-nullable","anchor":"#gradually-change-the-return-type-of-collection-min-and-max-functions-to-non-nullable"},{"id":"deprecate-appendln-in-favor-of-appendline","level":1,"title":"Deprecate appendln in favor of appendLine","anchor":"#deprecate-appendln-in-favor-of-appendline"},{"id":"deprecate-conversions-of-floating-point-types-to-short-and-byte","level":1,"title":"Deprecate conversions of floating-point types to Short and Byte","anchor":"#deprecate-conversions-of-floating-point-types-to-short-and-byte"},{"id":"fail-fast-in-regex-findall-on-an-invalid-startindex","level":1,"title":"Fail fast in Regex.findAll on an invalid startIndex","anchor":"#fail-fast-in-regex-findall-on-an-invalid-startindex"},{"id":"remove-deprecated-kotlin-coroutines-experimental","level":1,"title":"Remove deprecated kotlin.coroutines.experimental","anchor":"#remove-deprecated-kotlin-coroutines-experimental"},{"id":"remove-deprecated-mod-operator","level":1,"title":"Remove deprecated mod operator","anchor":"#remove-deprecated-mod-operator"},{"id":"hide-throwable-addsuppressed-member-and-prefer-extension-instead","level":1,"title":"Hide Throwable.addSuppressed member and prefer extension instead","anchor":"#hide-throwable-addsuppressed-member-and-prefer-extension-instead"},{"id":"capitalize-should-convert-digraphs-to-title-case","level":1,"title":"capitalize should convert digraphs to title case","anchor":"#capitalize-should-convert-digraphs-to-title-case"},{"id":"tools","level":0,"title":"Tools","anchor":"#tools"},{"id":"compiler-arguments-with-delimiter-characters-must-be-passed-in-double-quotes-on-windows","level":1,"title":"Compiler arguments with delimiter characters must be passed in double quotes on Windows","anchor":"#compiler-arguments-with-delimiter-characters-must-be-passed-in-double-quotes-on-windows"},{"id":"kapt-names-of-synthetic-annotations-methods-for-properties-have-changed","level":1,"title":"KAPT: Names of synthetic $annotations() methods for properties have changed","anchor":"#kapt-names-of-synthetic-annotations-methods-for-properties-have-changed"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Compatibility guide for Kotlin 1.4 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/compatibility-guide-14.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Compatibility guide for Kotlin 1.4 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/compatibility-guide-14.html#webpage",
    "url": "https://kotlinlang.org/docs/compatibility-guide-14.html",
    "name": "Compatibility guide for Kotlin 1.4 | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="compatibility-guide-14" data-main-title="Compatibility guide for Kotlin 1.4" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Other resources///Kotlin compatibility guides" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/compatibility-guides/compatibility-guide-14.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="compatibility-guide-14" id="compatibility-guide-14.md">Compatibility guide for Kotlin 1.4</h1><p id="rk8xnw_2"><span class="emphasis" id="rk8xnw_7"><a href="kotlin-evolution-principles.html" id="rk8xnw_9">Keeping the Language Modern</a></span> and <span class="emphasis" id="rk8xnw_8"><a href="kotlin-evolution-principles.html" id="rk8xnw_10">Comfortable Updates</a></span> are among the fundamental principles in Kotlin Language Design. The former says that constructs which obstruct language evolution should be removed, and the latter says that this removal should be well-communicated beforehand to make code migration as smooth as possible.</p><p id="rk8xnw_3">While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.3 to Kotlin 1.4.</p><section class="chapter"><h2 id="basic-terms" data-toc="basic-terms">Basic terms</h2><p id="rk8xnw_11">In this document we introduce several kinds of compatibility:</p><ul class="list _bullet" id="rk8xnw_12"><li class="list__item" id="rk8xnw_14"><p id="rk8xnw_17"><span class="emphasis" id="rk8xnw_18">source</span>: source-incompatible change stops code that used to compile fine (without errors or warnings) from compiling anymore</p></li><li class="list__item" id="rk8xnw_15"><p id="rk8xnw_19"><span class="emphasis" id="rk8xnw_20">binary</span>: two binary artifacts are said to be binary-compatible if interchanging them doesn't lead to loading or linkage errors</p></li><li class="list__item" id="rk8xnw_16"><p id="rk8xnw_21"><span class="emphasis" id="rk8xnw_22">behavioral</span>: a change is said to be behavioral-incompatible if the same program demonstrates different behavior before and after applying the change</p></li></ul><p id="rk8xnw_13">Remember that those definitions are given only for pure Kotlin. Compatibility of Kotlin code from the other languages perspective (for example, from Java) is out of the scope of this document.</p></section><section class="chapter"><h2 id="language-and-stdlib" data-toc="language-and-stdlib">Language and stdlib</h2><section class="chapter"><h3 id="unexpected-behavior-with-in-infix-operator-and-concurrenthashmap" data-toc="unexpected-behavior-with-in-infix-operator-and-concurrenthashmap">Unexpected behavior with in infix operator and ConcurrentHashMap</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_64"><p id="rk8xnw_65"><span class="control" id="rk8xnw_71">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-18053" id="rk8xnw_72" data-external="true" rel="noopener noreferrer" target="_blank">KT-18053</a></p><p id="rk8xnw_66"><span class="control" id="rk8xnw_73">Component</span>: Core language</p><p id="rk8xnw_67"><span class="control" id="rk8xnw_74">Incompatible change type</span>: source</p><p id="rk8xnw_68"><span class="control" id="rk8xnw_75">Short summary</span>: Kotlin 1.4 will outlaw auto operator <code class="code" id="rk8xnw_76">contains</code> coming from the implementors of <code class="code" id="rk8xnw_77">java.util.Map</code> written in Java</p><p id="rk8xnw_69"><span class="control" id="rk8xnw_78">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_70"><li class="list__item" id="rk8xnw_79"><p id="rk8xnw_81">&lt; 1.4: introduce warning for problematic operators at call-site</p></li><li class="list__item" id="rk8xnw_80"><p id="rk8xnw_82">&gt;= 1.4: raise this warning to an error, <code class="code" id="rk8xnw_83">-XXLanguage:-ProhibitConcurrentHashMapContains</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="prohibit-access-to-protected-members-inside-public-inline-members" data-toc="prohibit-access-to-protected-members-inside-public-inline-members">Prohibit access to protected members inside public inline members</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_84"><p id="rk8xnw_85"><span class="control" id="rk8xnw_91">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-21178" id="rk8xnw_92" data-external="true" rel="noopener noreferrer" target="_blank">KT-21178</a></p><p id="rk8xnw_86"><span class="control" id="rk8xnw_93">Component</span>: Core language</p><p id="rk8xnw_87"><span class="control" id="rk8xnw_94">Incompatible change type</span>: source</p><p id="rk8xnw_88"><span class="control" id="rk8xnw_95">Short summary</span>: Kotlin 1.4 will prohibit access to protected members from public inline members.</p><p id="rk8xnw_89"><span class="control" id="rk8xnw_96">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_90"><li class="list__item" id="rk8xnw_97"><p id="rk8xnw_99">&lt; 1.4: introduce warning at call-site for problematic cases</p></li><li class="list__item" id="rk8xnw_98"><p id="rk8xnw_100">1.4: raise this warning to an error, <code class="code" id="rk8xnw_101">-XXLanguage:-ProhibitProtectedCallFromInline</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="contracts-on-calls-with-implicit-receivers" data-toc="contracts-on-calls-with-implicit-receivers">Contracts on calls with implicit receivers</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_102"><p id="rk8xnw_103"><span class="control" id="rk8xnw_109">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-28672" id="rk8xnw_110" data-external="true" rel="noopener noreferrer" target="_blank">KT-28672</a></p><p id="rk8xnw_104"><span class="control" id="rk8xnw_111">Component</span>: Core Language</p><p id="rk8xnw_105"><span class="control" id="rk8xnw_112">Incompatible change type</span>: behavioral</p><p id="rk8xnw_106"><span class="control" id="rk8xnw_113">Short summary</span>: smart casts from contracts will be available on calls with implicit receivers in 1.4</p><p id="rk8xnw_107"><span class="control" id="rk8xnw_114">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_108"><li class="list__item" id="rk8xnw_115"><p id="rk8xnw_117">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_116"><p id="rk8xnw_118">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_119">-XXLanguage:-ContractsOnCallsWithImplicitReceiver</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="inconsistent-behavior-of-floating-point-number-comparisons" data-toc="inconsistent-behavior-of-floating-point-number-comparisons">Inconsistent behavior of floating-point number comparisons</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_120"><p id="rk8xnw_121"><span class="control" id="rk8xnw_127">Issues</span>: <a href="https://youtrack.jetbrains.com/issue/KT-22723" id="rk8xnw_128" data-external="true" rel="noopener noreferrer" target="_blank">KT-22723</a></p><p id="rk8xnw_122"><span class="control" id="rk8xnw_129">Component</span>: Core language</p><p id="rk8xnw_123"><span class="control" id="rk8xnw_130">Incompatible change type</span>: behavioral</p><p id="rk8xnw_124"><span class="control" id="rk8xnw_131">Short summary</span>: since Kotlin 1.4, Kotlin compiler will use IEEE 754 standard to compare floating-point numbers</p><p id="rk8xnw_125"><span class="control" id="rk8xnw_132">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_126"><li class="list__item" id="rk8xnw_133"><p id="rk8xnw_135">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_134"><p id="rk8xnw_136">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_137">-XXLanguage:-ProperIeee754Comparisons</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="no-smart-cast-on-the-last-expression-in-a-generic-lambda" data-toc="no-smart-cast-on-the-last-expression-in-a-generic-lambda">No smart cast on the last expression in a generic lambda</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_138"><p id="rk8xnw_139"><span class="control" id="rk8xnw_145">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-15020" id="rk8xnw_146" data-external="true" rel="noopener noreferrer" target="_blank">KT-15020</a></p><p id="rk8xnw_140"><span class="control" id="rk8xnw_147">Component</span>: Core Language</p><p id="rk8xnw_141"><span class="control" id="rk8xnw_148">Incompatible change type</span>: behavioral</p><p id="rk8xnw_142"><span class="control" id="rk8xnw_149">Short summary</span>: smart casts for last expressions in lambdas will be correctly applied since 1.4</p><p id="rk8xnw_143"><span class="control" id="rk8xnw_150">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_144"><li class="list__item" id="rk8xnw_151"><p id="rk8xnw_153">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_152"><p id="rk8xnw_154">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_155">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="do-not-depend-on-the-order-of-lambda-arguments-to-coerce-result-to-unit" data-toc="do-not-depend-on-the-order-of-lambda-arguments-to-coerce-result-to-unit">Do not depend on the order of lambda arguments to coerce result to Unit</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_156"><p id="rk8xnw_157"><span class="control" id="rk8xnw_163">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-36045" id="rk8xnw_164" data-external="true" rel="noopener noreferrer" target="_blank">KT-36045</a></p><p id="rk8xnw_158"><span class="control" id="rk8xnw_165">Component</span>: Core language</p><p id="rk8xnw_159"><span class="control" id="rk8xnw_166">Incompatible change type</span>: source</p><p id="rk8xnw_160"><span class="control" id="rk8xnw_167">Short summary</span>: since Kotlin 1.4, lambda arguments will be resolved independently without implicit coercion to <code class="code" id="rk8xnw_168">Unit</code></p><p id="rk8xnw_161"><span class="control" id="rk8xnw_169">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_162"><li class="list__item" id="rk8xnw_170"><p id="rk8xnw_172">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_171"><p id="rk8xnw_173">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_174">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="wrong-common-supertype-between-raw-and-integer-literal-type-leads-to-unsound-code" data-toc="wrong-common-supertype-between-raw-and-integer-literal-type-leads-to-unsound-code">Wrong common supertype between raw and integer literal type leads to unsound code</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_175"><p id="rk8xnw_176"><span class="control" id="rk8xnw_182">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35681" id="rk8xnw_183" data-external="true" rel="noopener noreferrer" target="_blank">KT-35681</a></p><p id="rk8xnw_177"><span class="control" id="rk8xnw_184">Components</span>: Core language</p><p id="rk8xnw_178"><span class="control" id="rk8xnw_185">Incompatible change type</span>: source</p><p id="rk8xnw_179"><span class="control" id="rk8xnw_186">Short summary</span>: since Kotlin 1.4, common supertype between raw <code class="code" id="rk8xnw_187">Comparable</code> type and integer literal type will be more specific</p><p id="rk8xnw_180"><span class="control" id="rk8xnw_188">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_181"><li class="list__item" id="rk8xnw_189"><p id="rk8xnw_191">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_190"><p id="rk8xnw_192">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_193">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="type-safety-problem-because-several-equal-type-variables-are-instantiated-with-a-different-types" data-toc="type-safety-problem-because-several-equal-type-variables-are-instantiated-with-a-different-types">Type safety problem because several equal type variables are instantiated with a different types</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_194"><p id="rk8xnw_195"><span class="control" id="rk8xnw_201">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35679" id="rk8xnw_202" data-external="true" rel="noopener noreferrer" target="_blank">KT-35679</a></p><p id="rk8xnw_196"><span class="control" id="rk8xnw_203">Component</span>: Core language</p><p id="rk8xnw_197"><span class="control" id="rk8xnw_204">Incompatible change type</span>: source</p><p id="rk8xnw_198"><span class="control" id="rk8xnw_205">Short summary</span>: since Kotlin 1.4, Kotlin compiler will prohibit instantiating equal type variables with different types</p><p id="rk8xnw_199"><span class="control" id="rk8xnw_206">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_200"><li class="list__item" id="rk8xnw_207"><p id="rk8xnw_209">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_208"><p id="rk8xnw_210">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_211">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="type-safety-problem-because-of-incorrect-subtyping-for-intersection-types" data-toc="type-safety-problem-because-of-incorrect-subtyping-for-intersection-types">Type safety problem because of incorrect subtyping for intersection types</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_212"><p id="rk8xnw_213"><span class="control" id="rk8xnw_219">Issues</span>: <a href="https://youtrack.jetbrains.com/issue/KT-22474" id="rk8xnw_220" data-external="true" rel="noopener noreferrer" target="_blank">KT-22474</a></p><p id="rk8xnw_214"><span class="control" id="rk8xnw_221">Component</span>: Core language</p><p id="rk8xnw_215"><span class="control" id="rk8xnw_222">Incompatible change type</span>: source</p><p id="rk8xnw_216"><span class="control" id="rk8xnw_223">Short summary</span>: in Kotlin 1.4, subtyping for intersection types will be refined to work more correctly</p><p id="rk8xnw_217"><span class="control" id="rk8xnw_224">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_218"><li class="list__item" id="rk8xnw_225"><p id="rk8xnw_227">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_226"><p id="rk8xnw_228">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_229">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="no-type-mismatch-with-an-empty-when-expression-inside-lambda" data-toc="no-type-mismatch-with-an-empty-when-expression-inside-lambda">No type mismatch with an empty when expression inside lambda</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_230"><p id="rk8xnw_231"><span class="control" id="rk8xnw_237">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-17995" id="rk8xnw_238" data-external="true" rel="noopener noreferrer" target="_blank">KT-17995</a></p><p id="rk8xnw_232"><span class="control" id="rk8xnw_239">Component</span>: Core language</p><p id="rk8xnw_233"><span class="control" id="rk8xnw_240">Incompatible change type</span>: source</p><p id="rk8xnw_234"><span class="control" id="rk8xnw_241">Short summary</span>: since Kotlin 1.4, there will be a type mismatch for empty <code class="code" id="rk8xnw_242">when</code> expression if it's used as the last expression in a lambda</p><p id="rk8xnw_235"><span class="control" id="rk8xnw_243">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_236"><li class="list__item" id="rk8xnw_244"><p id="rk8xnw_246">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_245"><p id="rk8xnw_247">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_248">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="return-type-any-inferred-for-lambda-with-early-return-with-integer-literal-in-one-of-possible-return-values" data-toc="return-type-any-inferred-for-lambda-with-early-return-with-integer-literal-in-one-of-possible-return-values">Return type Any inferred for lambda with early return with integer literal in one of possible return values</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_249"><p id="rk8xnw_250"><span class="control" id="rk8xnw_256">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-20226" id="rk8xnw_257" data-external="true" rel="noopener noreferrer" target="_blank">KT-20226</a></p><p id="rk8xnw_251"><span class="control" id="rk8xnw_258">Component</span>: Core language</p><p id="rk8xnw_252"><span class="control" id="rk8xnw_259">Incompatible change type</span>: source</p><p id="rk8xnw_253"><span class="control" id="rk8xnw_260">Short summary</span>: since Kotlin 1.4, integer type returning from a lambda will be more specific for cases when there is early return</p><p id="rk8xnw_254"><span class="control" id="rk8xnw_261">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_255"><li class="list__item" id="rk8xnw_262"><p id="rk8xnw_264">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_263"><p id="rk8xnw_265">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_266">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="proper-capturing-of-star-projections-with-recursive-types" data-toc="proper-capturing-of-star-projections-with-recursive-types">Proper capturing of star projections with recursive types</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_267"><p id="rk8xnw_268"><span class="control" id="rk8xnw_274">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-33012" id="rk8xnw_275" data-external="true" rel="noopener noreferrer" target="_blank">KT-33012</a></p><p id="rk8xnw_269"><span class="control" id="rk8xnw_276">Component</span>: Core language</p><p id="rk8xnw_270"><span class="control" id="rk8xnw_277">Incompatible change type</span>: source</p><p id="rk8xnw_271"><span class="control" id="rk8xnw_278">Short summary</span>: since Kotlin 1.4, more candidates will become applicable because capturing for recursive types will work more correctly</p><p id="rk8xnw_272"><span class="control" id="rk8xnw_279">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_273"><li class="list__item" id="rk8xnw_280"><p id="rk8xnw_282">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_281"><p id="rk8xnw_283">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_284">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="common-supertype-calculation-with-non-proper-type-and-flexible-one-leads-to-incorrect-results" data-toc="common-supertype-calculation-with-non-proper-type-and-flexible-one-leads-to-incorrect-results">Common supertype calculation with non-proper type and flexible one leads to incorrect results</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_285"><p id="rk8xnw_286"><span class="control" id="rk8xnw_292">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-37054" id="rk8xnw_293" data-external="true" rel="noopener noreferrer" target="_blank">KT-37054</a></p><p id="rk8xnw_287"><span class="control" id="rk8xnw_294">Component</span>: Core language</p><p id="rk8xnw_288"><span class="control" id="rk8xnw_295">Incompatible change type</span>: behavioral</p><p id="rk8xnw_289"><span class="control" id="rk8xnw_296">Short summary</span>: since Kotlin 1.4, common supertype between flexible types will be more specific protecting from runtime errors</p><p id="rk8xnw_290"><span class="control" id="rk8xnw_297">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_291"><li class="list__item" id="rk8xnw_298"><p id="rk8xnw_300">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_299"><p id="rk8xnw_301">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_302">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="type-safety-problem-because-of-lack-of-captured-conversion-against-nullable-type-argument" data-toc="type-safety-problem-because-of-lack-of-captured-conversion-against-nullable-type-argument">Type safety problem because of lack of captured conversion against nullable type argument</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_303"><p id="rk8xnw_304"><span class="control" id="rk8xnw_310">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35487" id="rk8xnw_311" data-external="true" rel="noopener noreferrer" target="_blank">KT-35487</a></p><p id="rk8xnw_305"><span class="control" id="rk8xnw_312">Component</span>: Core language</p><p id="rk8xnw_306"><span class="control" id="rk8xnw_313">Incompatible change type</span>: source</p><p id="rk8xnw_307"><span class="control" id="rk8xnw_314">Short summary</span>: since Kotlin 1.4, subtyping between captured and nullable types will be more correct protecting from runtime errors</p><p id="rk8xnw_308"><span class="control" id="rk8xnw_315">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_309"><li class="list__item" id="rk8xnw_316"><p id="rk8xnw_318">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_317"><p id="rk8xnw_319">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_320">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="preserve-intersection-type-for-covariant-types-after-unchecked-cast" data-toc="preserve-intersection-type-for-covariant-types-after-unchecked-cast">Preserve intersection type for covariant types after unchecked cast</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_321"><p id="rk8xnw_322"><span class="control" id="rk8xnw_328">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-37280" id="rk8xnw_329" data-external="true" rel="noopener noreferrer" target="_blank">KT-37280</a></p><p id="rk8xnw_323"><span class="control" id="rk8xnw_330">Component</span>: Core language</p><p id="rk8xnw_324"><span class="control" id="rk8xnw_331">Incompatible change type</span>: source</p><p id="rk8xnw_325"><span class="control" id="rk8xnw_332">Short summary</span>: since Kotlin 1.4, uchecked casts of covariant types produce the intersection type for smart casts, not the type of the unchecked cast.</p><p id="rk8xnw_326"><span class="control" id="rk8xnw_333">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_327"><li class="list__item" id="rk8xnw_334"><p id="rk8xnw_336">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_335"><p id="rk8xnw_337">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_338">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="type-variable-leaks-from-builder-inference-because-of-using-this-expression" data-toc="type-variable-leaks-from-builder-inference-because-of-using-this-expression">Type variable leaks from builder inference because of using this expression</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_339"><p id="rk8xnw_340"><span class="control" id="rk8xnw_346">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-32126" id="rk8xnw_347" data-external="true" rel="noopener noreferrer" target="_blank">KT-32126</a></p><p id="rk8xnw_341"><span class="control" id="rk8xnw_348">Component</span>: Core language</p><p id="rk8xnw_342"><span class="control" id="rk8xnw_349">Incompatible change type</span>: source</p><p id="rk8xnw_343"><span class="control" id="rk8xnw_350">Short summary</span>: since Kotlin 1.4, using <code class="code" id="rk8xnw_351">this</code> inside builder functions like <code class="code" id="rk8xnw_352">sequence {}</code> is prohibited if there are no other proper constraints</p><p id="rk8xnw_344"><span class="control" id="rk8xnw_353">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_345"><li class="list__item" id="rk8xnw_354"><p id="rk8xnw_356">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_355"><p id="rk8xnw_357">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_358">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="wrong-overload-resolution-for-contravariant-types-with-nullable-type-arguments" data-toc="wrong-overload-resolution-for-contravariant-types-with-nullable-type-arguments">Wrong overload resolution for contravariant types with nullable type arguments</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_359"><p id="rk8xnw_360"><span class="control" id="rk8xnw_366">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-31670" id="rk8xnw_367" data-external="true" rel="noopener noreferrer" target="_blank">KT-31670</a></p><p id="rk8xnw_361"><span class="control" id="rk8xnw_368">Component</span>: Core language</p><p id="rk8xnw_362"><span class="control" id="rk8xnw_369">Incompatible change type</span>: source</p><p id="rk8xnw_363"><span class="control" id="rk8xnw_370">Short summary</span>: since Kotlin 1.4, if two overloads of a function that takes contravariant type arguments differ only by the nullability of the type (such as <code class="code" id="rk8xnw_371">In&lt;T&gt;</code> and <code class="code" id="rk8xnw_372">In&lt;T?&gt;</code>), the nullable type is considered more specific.</p><p id="rk8xnw_364"><span class="control" id="rk8xnw_373">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_365"><li class="list__item" id="rk8xnw_374"><p id="rk8xnw_376">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_375"><p id="rk8xnw_377">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_378">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="builder-inference-with-non-nested-recursive-constraints" data-toc="builder-inference-with-non-nested-recursive-constraints">Builder inference with non-nested recursive constraints</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_379"><p id="rk8xnw_380"><span class="control" id="rk8xnw_386">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-34975" id="rk8xnw_387" data-external="true" rel="noopener noreferrer" target="_blank">KT-34975</a></p><p id="rk8xnw_381"><span class="control" id="rk8xnw_388">Component</span>: Core language</p><p id="rk8xnw_382"><span class="control" id="rk8xnw_389">Incompatible change type</span>: source</p><p id="rk8xnw_383"><span class="control" id="rk8xnw_390">Short summary</span>: since Kotlin 1.4, builder functions such as <code class="code" id="rk8xnw_391">sequence {}</code> with type that depends on a recursive constraint inside the passed lambda cause a compiler error.</p><p id="rk8xnw_384"><span class="control" id="rk8xnw_392">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_385"><li class="list__item" id="rk8xnw_393"><p id="rk8xnw_395">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_394"><p id="rk8xnw_396">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_397">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="eager-type-variable-fixation-leads-to-a-contradictory-constraint-system" data-toc="eager-type-variable-fixation-leads-to-a-contradictory-constraint-system">Eager type variable fixation leads to a contradictory constraint system</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_398"><p id="rk8xnw_399"><span class="control" id="rk8xnw_405">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-25175" id="rk8xnw_406" data-external="true" rel="noopener noreferrer" target="_blank">KT-25175</a></p><p id="rk8xnw_400"><span class="control" id="rk8xnw_407">Component</span>: Core language</p><p id="rk8xnw_401"><span class="control" id="rk8xnw_408">Incompatible change type</span>: source</p><p id="rk8xnw_402"><span class="control" id="rk8xnw_409">Short summary</span>: since Kotlin 1.4, the type inference in certain cases works less eagerly allowing to find the constraint system that is not contradictory.</p><p id="rk8xnw_403"><span class="control" id="rk8xnw_410">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_404"><li class="list__item" id="rk8xnw_411"><p id="rk8xnw_413">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_412"><p id="rk8xnw_414">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_415">-XXLanguage:-NewInference</code> can be used to temporarily revert to pre-1.4 behavior. Note that this flag will also disable several new language features.</p></li></ul></aside></section><section class="chapter"><h3 id="prohibit-tailrec-modifier-on-open-functions" data-toc="prohibit-tailrec-modifier-on-open-functions">Prohibit tailrec modifier on open functions</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_416"><p id="rk8xnw_417"><span class="control" id="rk8xnw_423">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-18541" id="rk8xnw_424" data-external="true" rel="noopener noreferrer" target="_blank">KT-18541</a></p><p id="rk8xnw_418"><span class="control" id="rk8xnw_425">Component</span>: Core language</p><p id="rk8xnw_419"><span class="control" id="rk8xnw_426">Incompatible change type</span>: source</p><p id="rk8xnw_420"><span class="control" id="rk8xnw_427">Short summary</span>: since Kotlin 1.4, functions can't have <code class="code" id="rk8xnw_428">open</code> and <code class="code" id="rk8xnw_429">tailrec</code> modifiers at the same time.</p><p id="rk8xnw_421"><span class="control" id="rk8xnw_430">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_422"><li class="list__item" id="rk8xnw_431"><p id="rk8xnw_433">&lt; 1.4: report a warning on functions that have <code class="code" id="rk8xnw_434">open</code> and <code class="code" id="rk8xnw_435">tailrec</code> modifiers together (error in the progressive mode).</p></li><li class="list__item" id="rk8xnw_432"><p id="rk8xnw_436">&gt;= 1.4: raise this warning to an error.</p></li></ul></aside></section><section class="chapter"><h3 id="the-instance-field-of-a-companion-object-more-visible-than-the-companion-object-class-itself" data-toc="the-instance-field-of-a-companion-object-more-visible-than-the-companion-object-class-itself">The INSTANCE field of a companion object more visible than the companion object class itself</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_437"><p id="rk8xnw_438"><span class="control" id="rk8xnw_444">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-11567" id="rk8xnw_445" data-external="true" rel="noopener noreferrer" target="_blank">KT-11567</a></p><p id="rk8xnw_439"><span class="control" id="rk8xnw_446">Component</span>: Kotlin/JVM</p><p id="rk8xnw_440"><span class="control" id="rk8xnw_447">Incompatible change type</span>: source</p><p id="rk8xnw_441"><span class="control" id="rk8xnw_448">Short summary</span>: since Kotlin 1.4, if a companion object is private, then its field <code class="code" id="rk8xnw_449">INSTANCE</code> will be also private</p><p id="rk8xnw_442"><span class="control" id="rk8xnw_450">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_443"><li class="list__item" id="rk8xnw_451"><p id="rk8xnw_453">&lt; 1.4: the compiler generates object <code class="code" id="rk8xnw_454">INSTANCE</code> with a deprecated flag</p></li><li class="list__item" id="rk8xnw_452"><p id="rk8xnw_455">&gt;= 1.4: companion object <code class="code" id="rk8xnw_456">INSTANCE</code> field has proper visibility</p></li></ul></aside></section><section class="chapter"><h3 id="outer-finally-block-inserted-before-return-is-not-excluded-from-the-catch-interval-of-the-inner-try-block-without-finally" data-toc="outer-finally-block-inserted-before-return-is-not-excluded-from-the-catch-interval-of-the-inner-try-block-without-finally">Outer finally block inserted before return is not excluded from the catch interval of the inner try block without finally</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_457"><p id="rk8xnw_458"><span class="control" id="rk8xnw_464">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-31923" id="rk8xnw_465" data-external="true" rel="noopener noreferrer" target="_blank">KT-31923</a></p><p id="rk8xnw_459"><span class="control" id="rk8xnw_466">Component</span>: Kotlin/JVM</p><p id="rk8xnw_460"><span class="control" id="rk8xnw_467">Incompatible change type</span>: behavioral</p><p id="rk8xnw_461"><span class="control" id="rk8xnw_468">Short summary</span>: since Kotlin 1.4, the catch interval will be computed properly for nested <code class="code" id="rk8xnw_469">try/catch</code> blocks</p><p id="rk8xnw_462"><span class="control" id="rk8xnw_470">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_463"><li class="list__item" id="rk8xnw_471"><p id="rk8xnw_473">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_472"><p id="rk8xnw_474">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_475">-XXLanguage:-ProperFinally</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="use-the-boxed-version-of-an-inline-class-in-return-type-position-for-covariant-and-generic-specialized-overrides" data-toc="use-the-boxed-version-of-an-inline-class-in-return-type-position-for-covariant-and-generic-specialized-overrides">Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_476"><p id="rk8xnw_477"><span class="control" id="rk8xnw_483">Issues</span>: <a href="https://youtrack.jetbrains.com/issue/KT-30419" id="rk8xnw_484" data-external="true" rel="noopener noreferrer" target="_blank">KT-30419</a></p><p id="rk8xnw_478"><span class="control" id="rk8xnw_485">Component</span>: Kotlin/JVM</p><p id="rk8xnw_479"><span class="control" id="rk8xnw_486">Incompatible change type</span>: behavioral</p><p id="rk8xnw_480"><span class="control" id="rk8xnw_487">Short summary</span>: since Kotlin 1.4, functions using covariant and generic-specialized overrides will return boxed values of inline classes</p><p id="rk8xnw_481"><span class="control" id="rk8xnw_488">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_482"><li class="list__item" id="rk8xnw_489"><p id="rk8xnw_491">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_490"><p id="rk8xnw_492">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="do-not-declare-checked-exceptions-in-jvm-bytecode-when-using-delegation-to-kotlin-interfaces" data-toc="do-not-declare-checked-exceptions-in-jvm-bytecode-when-using-delegation-to-kotlin-interfaces">Do not declare checked exceptions in JVM bytecode when using delegation to Kotlin interfaces</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_493"><p id="rk8xnw_494"><span class="control" id="rk8xnw_500">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35834" id="rk8xnw_501" data-external="true" rel="noopener noreferrer" target="_blank">KT-35834</a></p><p id="rk8xnw_495"><span class="control" id="rk8xnw_502">Component</span>: Kotlin/JVM</p><p id="rk8xnw_496"><span class="control" id="rk8xnw_503">Incompatible change type</span>: source</p><p id="rk8xnw_497"><span class="control" id="rk8xnw_504">Short summary</span>: Kotlin 1.4 will not generate checked exceptions during interface delegation to Kotlin interfaces</p><p id="rk8xnw_498"><span class="control" id="rk8xnw_505">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_499"><li class="list__item" id="rk8xnw_506"><p id="rk8xnw_508">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_507"><p id="rk8xnw_509">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_510">-XXLanguage:-DoNotGenerateThrowsForDelegatedKotlinMembers</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="changed-behavior-of-signature-polymorphic-calls-to-methods-with-a-single-vararg-parameter-to-avoid-wrapping-the-argument-into-another-array" data-toc="changed-behavior-of-signature-polymorphic-calls-to-methods-with-a-single-vararg-parameter-to-avoid-wrapping-the-argument-into-another-array">Changed behavior of signature-polymorphic calls to methods with a single vararg parameter to avoid wrapping the argument into another array</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_511"><p id="rk8xnw_512"><span class="control" id="rk8xnw_518">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35469" id="rk8xnw_519" data-external="true" rel="noopener noreferrer" target="_blank">KT-35469</a></p><p id="rk8xnw_513"><span class="control" id="rk8xnw_520">Component</span>: Kotlin/JVM</p><p id="rk8xnw_514"><span class="control" id="rk8xnw_521">Incompatible change type</span>: source</p><p id="rk8xnw_515"><span class="control" id="rk8xnw_522">Short summary</span>: Kotlin 1.4 will not wrap the argument into another array on a signature-polymorphic call</p><p id="rk8xnw_516"><span class="control" id="rk8xnw_523">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_517"><li class="list__item" id="rk8xnw_524"><p id="rk8xnw_526">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_525"><p id="rk8xnw_527">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="incorrect-generic-signature-in-annotations-when-kclass-is-used-as-a-generic-parameter" data-toc="incorrect-generic-signature-in-annotations-when-kclass-is-used-as-a-generic-parameter">Incorrect generic signature in annotations when KClass is used as a generic parameter</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_528"><p id="rk8xnw_529"><span class="control" id="rk8xnw_535">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35207" id="rk8xnw_536" data-external="true" rel="noopener noreferrer" target="_blank">KT-35207</a></p><p id="rk8xnw_530"><span class="control" id="rk8xnw_537">Component</span>: Kotlin/JVM</p><p id="rk8xnw_531"><span class="control" id="rk8xnw_538">Incompatible change type</span>: source</p><p id="rk8xnw_532"><span class="control" id="rk8xnw_539">Short summary</span>: Kotlin 1.4 will fix incorrect type mapping in annotations when KClass is used as a generic parameter</p><p id="rk8xnw_533"><span class="control" id="rk8xnw_540">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_534"><li class="list__item" id="rk8xnw_541"><p id="rk8xnw_543">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_542"><p id="rk8xnw_544">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="forbid-spread-operator-in-signature-polymorphic-calls" data-toc="forbid-spread-operator-in-signature-polymorphic-calls">Forbid spread operator in signature-polymorphic calls</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_545"><p id="rk8xnw_546"><span class="control" id="rk8xnw_552">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-35226" id="rk8xnw_553" data-external="true" rel="noopener noreferrer" target="_blank">KT-35226</a></p><p id="rk8xnw_547"><span class="control" id="rk8xnw_554">Component</span>: Kotlin/JVM</p><p id="rk8xnw_548"><span class="control" id="rk8xnw_555">Incompatible change type</span>: source</p><p id="rk8xnw_549"><span class="control" id="rk8xnw_556">Short summary</span>: Kotlin 1.4 will prohibit the use of spread operator (*) on signature-polymorphic calls</p><p id="rk8xnw_550"><span class="control" id="rk8xnw_557">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_551"><li class="list__item" id="rk8xnw_558"><p id="rk8xnw_560">&lt; 1.4: report a warning on the use of a spread operator in signature-polymorphic calls</p></li><li class="list__item" id="rk8xnw_559"><p id="rk8xnw_561">&gt;= 1.5: raise this warning to an error, <code class="code" id="rk8xnw_562">-XXLanguage:-ProhibitSpreadOnSignaturePolymorphicCall</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="change-initialization-order-of-default-values-for-tail-recursive-optimized-functions" data-toc="change-initialization-order-of-default-values-for-tail-recursive-optimized-functions">Change initialization order of default values for tail-recursive optimized functions</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_563"><p id="rk8xnw_564"><span class="control" id="rk8xnw_570">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-31540" id="rk8xnw_571" data-external="true" rel="noopener noreferrer" target="_blank">KT-31540</a></p><p id="rk8xnw_565"><span class="control" id="rk8xnw_572">Component</span>: Kotlin/JVM</p><p id="rk8xnw_566"><span class="control" id="rk8xnw_573">Incompatible change type</span>: behavioral</p><p id="rk8xnw_567"><span class="control" id="rk8xnw_574">Short summary</span>: Since Kotlin 1.4, the initialization order for tail-recursive functions will be the same as for regular functions</p><p id="rk8xnw_568"><span class="control" id="rk8xnw_575">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_569"><li class="list__item" id="rk8xnw_576"><p id="rk8xnw_578">&lt; 1.4: report a warning at declaration-site for problematic functions</p></li><li class="list__item" id="rk8xnw_577"><p id="rk8xnw_579">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_580">-XXLanguage:-ProperComputationOrderOfTailrecDefaultParameters</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="do-not-generate-constantvalue-attribute-for-non-const-vals" data-toc="do-not-generate-constantvalue-attribute-for-non-const-vals">Do not generate ConstantValue attribute for non-const vals</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_581"><p id="rk8xnw_582"><span class="control" id="rk8xnw_588">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-16615" id="rk8xnw_589" data-external="true" rel="noopener noreferrer" target="_blank">KT-16615</a></p><p id="rk8xnw_583"><span class="control" id="rk8xnw_590">Component</span>: Kotlin/JVM</p><p id="rk8xnw_584"><span class="control" id="rk8xnw_591">Incompatible change type</span>: behavioral</p><p id="rk8xnw_585"><span class="control" id="rk8xnw_592">Short summary</span>: Since Kotlin 1.4, the compiler will not generate the <code class="code" id="rk8xnw_593">ConstantValue</code> attribute for non-<code class="code" id="rk8xnw_594">const</code> <code class="code" id="rk8xnw_595">val</code>s</p><p id="rk8xnw_586"><span class="control" id="rk8xnw_596">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_587"><li class="list__item" id="rk8xnw_597"><p id="rk8xnw_599">&lt; 1.4: report a warning through an IntelliJ IDEA inspection</p></li><li class="list__item" id="rk8xnw_598"><p id="rk8xnw_600">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_601">-XXLanguage:-NoConstantValueAttributeForNonConstVals</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="generated-overloads-for-jvmoverloads-on-open-methods-should-be-final" data-toc="generated-overloads-for-jvmoverloads-on-open-methods-should-be-final">Generated overloads for @JvmOverloads on open methods should be final</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_602"><p id="rk8xnw_603"><span class="control" id="rk8xnw_609">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-33240" id="rk8xnw_610" data-external="true" rel="noopener noreferrer" target="_blank">KT-33240</a></p><p id="rk8xnw_604"><span class="control" id="rk8xnw_611">Components</span>: Kotlin/JVM</p><p id="rk8xnw_605"><span class="control" id="rk8xnw_612">Incompatible change type</span>: source</p><p id="rk8xnw_606"><span class="control" id="rk8xnw_613">Short summary</span>: overloads for functions with <code class="code" id="rk8xnw_614">@JvmOverloads</code> will be generated as <code class="code" id="rk8xnw_615">final</code></p><p id="rk8xnw_607"><span class="control" id="rk8xnw_616">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_608"><li class="list__item" id="rk8xnw_617"><p id="rk8xnw_619">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_618"><p id="rk8xnw_620">&gt;= 1.4: behavior changed, <code class="code" id="rk8xnw_621">-XXLanguage:-GenerateJvmOverloadsAsFinal</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="lambdas-returning-kotlin-result-now-return-boxed-value-instead-of-unboxed" data-toc="lambdas-returning-kotlin-result-now-return-boxed-value-instead-of-unboxed">Lambdas returning kotlin.Result now return boxed value instead of unboxed</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_622"><p id="rk8xnw_623"><span class="control" id="rk8xnw_629">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-39198" id="rk8xnw_630" data-external="true" rel="noopener noreferrer" target="_blank">KT-39198</a></p><p id="rk8xnw_624"><span class="control" id="rk8xnw_631">Component</span>: Kotlin/JVM</p><p id="rk8xnw_625"><span class="control" id="rk8xnw_632">Incompatible change type</span>: behavioral</p><p id="rk8xnw_626"><span class="control" id="rk8xnw_633">Short summary</span>: since Kotlin 1.4, lambdas returning values of <code class="code" id="rk8xnw_634">kotlin.Result</code> type will return boxed value instead of unboxed</p><p id="rk8xnw_627"><span class="control" id="rk8xnw_635">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_628"><li class="list__item" id="rk8xnw_636"><p id="rk8xnw_638">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_637"><p id="rk8xnw_639">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="unify-exceptions-from-null-checks" data-toc="unify-exceptions-from-null-checks">Unify exceptions from null checks</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_640"><p id="rk8xnw_641"><span class="control" id="rk8xnw_647">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-22275" id="rk8xnw_648" data-external="true" rel="noopener noreferrer" target="_blank">KT-22275</a></p><p id="rk8xnw_642"><span class="control" id="rk8xnw_649">Component</span>: Kotlin/JVM</p><p id="rk8xnw_643"><span class="control" id="rk8xnw_650">Incompatible change type</span>: behavior</p><p id="rk8xnw_644"><span class="control" id="rk8xnw_651">Short summary</span>: Starting from Kotlin 1.4, all runtime null checks will throw a <code class="code" id="rk8xnw_652">java.lang.NullPointerException</code></p><p id="rk8xnw_645"><span class="control" id="rk8xnw_653">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_646"><li class="list__item" id="rk8xnw_654"><p id="rk8xnw_656">&lt; 1.4: runtime null checks throw different exceptions, such as <code class="code" id="rk8xnw_657">KotlinNullPointerException</code>, <code class="code" id="rk8xnw_658">IllegalStateException</code>, <code class="code" id="rk8xnw_659">IllegalArgumentException</code>, and <code class="code" id="rk8xnw_660">TypeCastException</code></p></li><li class="list__item" id="rk8xnw_655"><p id="rk8xnw_661">&gt;= 1.4: all runtime null checks throw a <code class="code" id="rk8xnw_662">java.lang.NullPointerException</code>. <code class="code" id="rk8xnw_663">-Xno-unified-null-checks</code> can be used to temporarily revert to pre-1.4 behavior</p></li></ul></aside></section><section class="chapter"><h3 id="comparing-floating-point-values-in-array-list-operations-contains-indexof-lastindexof-ieee-754-or-total-order" data-toc="comparing-floating-point-values-in-array-list-operations-contains-indexof-lastindexof-ieee-754-or-total-order">Comparing floating-point values in array/list operations contains, indexOf, lastIndexOf: IEEE 754 or total order</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_664"><p id="rk8xnw_665"><span class="control" id="rk8xnw_671">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-28753" id="rk8xnw_672" data-external="true" rel="noopener noreferrer" target="_blank">KT-28753</a></p><p id="rk8xnw_666"><span class="control" id="rk8xnw_673">Component</span>: kotlin-stdlib (JVM)</p><p id="rk8xnw_667"><span class="control" id="rk8xnw_674">Incompatible change type</span>: behavioral</p><p id="rk8xnw_668"><span class="control" id="rk8xnw_675">Short summary</span>: the <code class="code" id="rk8xnw_676">List</code> implementation returned from <code class="code" id="rk8xnw_677">Double/FloatArray.asList()</code> will implement <code class="code" id="rk8xnw_678">contains</code>, <code class="code" id="rk8xnw_679">indexOf</code>, and <code class="code" id="rk8xnw_680">lastIndexOf</code>, so that they use total order equality</p><p id="rk8xnw_669"><span class="control" id="rk8xnw_681">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_670"><li class="list__item" id="rk8xnw_682"><p id="rk8xnw_684">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_683"><p id="rk8xnw_685">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="gradually-change-the-return-type-of-collection-min-and-max-functions-to-non-nullable" data-toc="gradually-change-the-return-type-of-collection-min-and-max-functions-to-non-nullable">Gradually change the return type of collection min and max functions to non-nullable</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_686"><p id="rk8xnw_687"><span class="control" id="rk8xnw_693">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-38854" id="rk8xnw_694" data-external="true" rel="noopener noreferrer" target="_blank">KT-38854</a></p><p id="rk8xnw_688"><span class="control" id="rk8xnw_695">Component</span>: kotlin-stdlib (JVM)</p><p id="rk8xnw_689"><span class="control" id="rk8xnw_696">Incompatible change type</span>: source</p><p id="rk8xnw_690"><span class="control" id="rk8xnw_697">Short summary</span>: return type of collection <code class="code" id="rk8xnw_698">min</code> and <code class="code" id="rk8xnw_699">max</code> functions will be changed to non-nullable in 1.6</p><p id="rk8xnw_691"><span class="control" id="rk8xnw_700">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_692"><li class="list__item" id="rk8xnw_701"><p id="rk8xnw_704">1.4: introduce <code class="code" id="rk8xnw_705">...OrNull</code> functions as synonyms and deprecate the affected API (see details in the issue)</p></li><li class="list__item" id="rk8xnw_702"><p id="rk8xnw_706">1.5.x: raise the deprecation level of the affected API to error</p></li><li class="list__item" id="rk8xnw_703"><p id="rk8xnw_707">&gt;=1.6: reintroduce the affected API but with non-nullable return type</p></li></ul></aside></section><section class="chapter"><h3 id="deprecate-appendln-in-favor-of-appendline" data-toc="deprecate-appendln-in-favor-of-appendline">Deprecate appendln in favor of appendLine</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_708"><p id="rk8xnw_709"><span class="control" id="rk8xnw_715">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-38754" id="rk8xnw_716" data-external="true" rel="noopener noreferrer" target="_blank">KT-38754</a></p><p id="rk8xnw_710"><span class="control" id="rk8xnw_717">Component</span>: kotlin-stdlib (JVM)</p><p id="rk8xnw_711"><span class="control" id="rk8xnw_718">Incompatible change type</span>: source</p><p id="rk8xnw_712"><span class="control" id="rk8xnw_719">Short summary</span>: <code class="code" id="rk8xnw_720">StringBuilder.appendln()</code> will be deprecated in favor of <code class="code" id="rk8xnw_721">StringBuilder.appendLine()</code></p><p id="rk8xnw_713"><span class="control" id="rk8xnw_722">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_714"><li class="list__item" id="rk8xnw_723"><p id="rk8xnw_725">1.4: introduce <code class="code" id="rk8xnw_726">appendLine</code> function as a replacement for <code class="code" id="rk8xnw_727">appendln</code> and deprecate <code class="code" id="rk8xnw_728">appendln</code></p></li><li class="list__item" id="rk8xnw_724"><p id="rk8xnw_729">&gt;=1.5: raise the deprecation level to error</p></li></ul></aside></section><section class="chapter"><h3 id="deprecate-conversions-of-floating-point-types-to-short-and-byte" data-toc="deprecate-conversions-of-floating-point-types-to-short-and-byte">Deprecate conversions of floating-point types to Short and Byte</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_730"><p id="rk8xnw_731"><span class="control" id="rk8xnw_737">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-30360" id="rk8xnw_738" data-external="true" rel="noopener noreferrer" target="_blank">KT-30360</a></p><p id="rk8xnw_732"><span class="control" id="rk8xnw_739">Component</span>: kotlin-stdlib (JVM)</p><p id="rk8xnw_733"><span class="control" id="rk8xnw_740">Incompatible change type</span>: source</p><p id="rk8xnw_734"><span class="control" id="rk8xnw_741">Short summary</span>: since Kotlin 1.4, conversions of floating-point types to <code class="code" id="rk8xnw_742">Short</code> and <code class="code" id="rk8xnw_743">Byte</code> will be deprecated</p><p id="rk8xnw_735"><span class="control" id="rk8xnw_744">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_736"><li class="list__item" id="rk8xnw_745"><p id="rk8xnw_747">1.4: deprecate <code class="code" id="rk8xnw_748">Double.toShort()/toByte()</code> and <code class="code" id="rk8xnw_749">Float.toShort()/toByte()</code> and propose replacement</p></li><li class="list__item" id="rk8xnw_746"><p id="rk8xnw_750">&gt;=1.5: raise the deprecation level to error</p></li></ul></aside></section><section class="chapter"><h3 id="fail-fast-in-regex-findall-on-an-invalid-startindex" data-toc="fail-fast-in-regex-findall-on-an-invalid-startindex">Fail fast in Regex.findAll on an invalid startIndex</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_751"><p id="rk8xnw_752"><span class="control" id="rk8xnw_758">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-28356" id="rk8xnw_759" data-external="true" rel="noopener noreferrer" target="_blank">KT-28356</a></p><p id="rk8xnw_753"><span class="control" id="rk8xnw_760">Component</span>: kotlin-stdlib</p><p id="rk8xnw_754"><span class="control" id="rk8xnw_761">Incompatible change type</span>: behavioral</p><p id="rk8xnw_755"><span class="control" id="rk8xnw_762">Short summary</span>: since Kotlin 1.4, <code class="code" id="rk8xnw_763">findAll</code> will be improved to check that <code class="code" id="rk8xnw_764">startIndex</code> is in the range of the valid position indices of the input char sequence at the moment of entering <code class="code" id="rk8xnw_765">findAll</code>, and throw <code class="code" id="rk8xnw_766">IndexOutOfBoundsException</code> if it's not</p><p id="rk8xnw_756"><span class="control" id="rk8xnw_767">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_757"><li class="list__item" id="rk8xnw_768"><p id="rk8xnw_770">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_769"><p id="rk8xnw_771">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="remove-deprecated-kotlin-coroutines-experimental" data-toc="remove-deprecated-kotlin-coroutines-experimental">Remove deprecated kotlin.coroutines.experimental</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_772"><p id="rk8xnw_773"><span class="control" id="rk8xnw_779">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-36083" id="rk8xnw_780" data-external="true" rel="noopener noreferrer" target="_blank">KT-36083</a></p><p id="rk8xnw_774"><span class="control" id="rk8xnw_781">Component</span>: kotlin-stdlib</p><p id="rk8xnw_775"><span class="control" id="rk8xnw_782">Incompatible change type</span>: source</p><p id="rk8xnw_776"><span class="control" id="rk8xnw_783">Short summary</span>: since Kotlin 1.4, the deprecated <code class="code" id="rk8xnw_784">kotlin.coroutines.experimental</code> API is removed from stdlib</p><p id="rk8xnw_777"><span class="control" id="rk8xnw_785">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_778"><li class="list__item" id="rk8xnw_786"><p id="rk8xnw_788">&lt; 1.4: <code class="code" id="rk8xnw_789">kotlin.coroutines.experimental</code> is deprecated with the <code class="code" id="rk8xnw_790">ERROR</code> level</p></li><li class="list__item" id="rk8xnw_787"><p id="rk8xnw_791">&gt;= 1.4: <code class="code" id="rk8xnw_792">kotlin.coroutines.experimental</code> is removed from stdlib. On the JVM, a separate compatibility artifact is provided (see details in the issue).</p></li></ul></aside></section><section class="chapter"><h3 id="remove-deprecated-mod-operator" data-toc="remove-deprecated-mod-operator">Remove deprecated mod operator</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_793"><p id="rk8xnw_794"><span class="control" id="rk8xnw_800">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-26654" id="rk8xnw_801" data-external="true" rel="noopener noreferrer" target="_blank">KT-26654</a></p><p id="rk8xnw_795"><span class="control" id="rk8xnw_802">Component</span>: kotlin-stdlib</p><p id="rk8xnw_796"><span class="control" id="rk8xnw_803">Incompatible change type</span>: source</p><p id="rk8xnw_797"><span class="control" id="rk8xnw_804">Short summary</span>: since Kotlin 1.4, <code class="code" id="rk8xnw_805">mod</code> operator on numeric types is removed from stdlib</p><p id="rk8xnw_798"><span class="control" id="rk8xnw_806">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_799"><li class="list__item" id="rk8xnw_807"><p id="rk8xnw_809">&lt; 1.4: <code class="code" id="rk8xnw_810">mod</code> is deprecated with the <code class="code" id="rk8xnw_811">ERROR</code> level</p></li><li class="list__item" id="rk8xnw_808"><p id="rk8xnw_812">&gt;= 1.4: <code class="code" id="rk8xnw_813">mod</code> is removed from stdlib</p></li></ul></aside></section><section class="chapter"><h3 id="hide-throwable-addsuppressed-member-and-prefer-extension-instead" data-toc="hide-throwable-addsuppressed-member-and-prefer-extension-instead">Hide Throwable.addSuppressed member and prefer extension instead</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_814"><p id="rk8xnw_815"><span class="control" id="rk8xnw_821">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-38777" id="rk8xnw_822" data-external="true" rel="noopener noreferrer" target="_blank">KT-38777</a></p><p id="rk8xnw_816"><span class="control" id="rk8xnw_823">Component</span>: kotlin-stdlib</p><p id="rk8xnw_817"><span class="control" id="rk8xnw_824">Incompatible change type</span>: behavioral</p><p id="rk8xnw_818"><span class="control" id="rk8xnw_825">Short summary</span>: <code class="code" id="rk8xnw_826">Throwable.addSuppressed()</code> extension function is now preferred over the <code class="code" id="rk8xnw_827">Throwable.addSuppressed()</code> member function</p><p id="rk8xnw_819"><span class="control" id="rk8xnw_828">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_820"><li class="list__item" id="rk8xnw_829"><p id="rk8xnw_831">&lt; 1.4: old behavior (see details in the issue)</p></li><li class="list__item" id="rk8xnw_830"><p id="rk8xnw_832">&gt;= 1.4: behavior changed</p></li></ul></aside></section><section class="chapter"><h3 id="capitalize-should-convert-digraphs-to-title-case" data-toc="capitalize-should-convert-digraphs-to-title-case">capitalize should convert digraphs to title case</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_833"><p id="rk8xnw_834"><span class="control" id="rk8xnw_840">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-38817" id="rk8xnw_841" data-external="true" rel="noopener noreferrer" target="_blank">KT-38817</a></p><p id="rk8xnw_835"><span class="control" id="rk8xnw_842">Component</span>: kotlin-stdlib</p><p id="rk8xnw_836"><span class="control" id="rk8xnw_843">Incompatible change type</span>: behavioral</p><p id="rk8xnw_837"><span class="control" id="rk8xnw_844">Short summary</span>: <code class="code" id="rk8xnw_845">String.capitalize()</code> function now capitalizes digraphs from the <a href="https://en.wikipedia.org/wiki/Gaj%27s_Latin_alphabet" id="rk8xnw_846" data-external="true" rel="noopener noreferrer" target="_blank">Serbo-Croatian Gaj's Latin alphabet</a> in the title case (<code class="code" id="rk8xnw_847"></code> instead of <code class="code" id="rk8xnw_848"></code>)</p><p id="rk8xnw_838"><span class="control" id="rk8xnw_849">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_839"><li class="list__item" id="rk8xnw_850"><p id="rk8xnw_852">&lt; 1.4: digraphs are capitalized in the upper case (<code class="code" id="rk8xnw_853"></code>)</p></li><li class="list__item" id="rk8xnw_851"><p id="rk8xnw_854">&gt;= 1.4: digraphs are capitalized in the title case (<code class="code" id="rk8xnw_855"></code>)</p></li></ul></aside></section></section><section class="chapter"><h2 id="tools" data-toc="tools">Tools</h2><section class="chapter"><h3 id="compiler-arguments-with-delimiter-characters-must-be-passed-in-double-quotes-on-windows" data-toc="compiler-arguments-with-delimiter-characters-must-be-passed-in-double-quotes-on-windows">Compiler arguments with delimiter characters must be passed in double quotes on Windows</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_858"><p id="rk8xnw_859"><span class="control" id="rk8xnw_865">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-41309" id="rk8xnw_866" data-external="true" rel="noopener noreferrer" target="_blank">KT-41309</a></p><p id="rk8xnw_860"><span class="control" id="rk8xnw_867">Component</span>: CLI</p><p id="rk8xnw_861"><span class="control" id="rk8xnw_868">Incompatible change type</span>: behavioral</p><p id="rk8xnw_862"><span class="control" id="rk8xnw_869">Short summary</span>: on Windows, <code class="code" id="rk8xnw_870">kotlinc.bat</code> arguments that contain delimiter characters (whitespace, <code class="code" id="rk8xnw_871">=</code>, <code class="code" id="rk8xnw_872">;</code>, <code class="code" id="rk8xnw_873">,</code>) now require double quotes (<code class="code" id="rk8xnw_874">&quot;</code>)</p><p id="rk8xnw_863"><span class="control" id="rk8xnw_875">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_864"><li class="list__item" id="rk8xnw_876"><p id="rk8xnw_878">&lt; 1.4: all compiler arguments are passed without quotes</p></li><li class="list__item" id="rk8xnw_877"><p id="rk8xnw_879">&gt;= 1.4: compiler arguments that contain delimiter characters (whitespace, <code class="code" id="rk8xnw_880">=</code>, <code class="code" id="rk8xnw_881">;</code>, <code class="code" id="rk8xnw_882">,</code>) require double quotes (<code class="code" id="rk8xnw_883">&quot;</code>)</p></li></ul></aside></section><section class="chapter"><h3 id="kapt-names-of-synthetic-annotations-methods-for-properties-have-changed" data-toc="kapt-names-of-synthetic-annotations-methods-for-properties-have-changed">KAPT: Names of synthetic $annotations() methods for properties have changed</h3><aside class="prompt" data-type="tip" data-title="" id="rk8xnw_884"><p id="rk8xnw_885"><span class="control" id="rk8xnw_891">Issue</span>: <a href="https://youtrack.jetbrains.com/issue/KT-36926" id="rk8xnw_892" data-external="true" rel="noopener noreferrer" target="_blank">KT-36926</a></p><p id="rk8xnw_886"><span class="control" id="rk8xnw_893">Component</span>: KAPT</p><p id="rk8xnw_887"><span class="control" id="rk8xnw_894">Incompatible change type</span>: behavioral</p><p id="rk8xnw_888"><span class="control" id="rk8xnw_895">Short summary</span>: names of synthetic <code class="code" id="rk8xnw_896">$annotations()</code> methods generated by KAPT for properties have changed in 1.4</p><p id="rk8xnw_889"><span class="control" id="rk8xnw_897">Deprecation cycle</span>:</p><ul class="list _bullet" id="rk8xnw_890"><li class="list__item" id="rk8xnw_898"><p id="rk8xnw_900">&lt; 1.4: names of synthetic <code class="code" id="rk8xnw_901">$annotations()</code> methods for properties follow the template <code class="code" id="rk8xnw_902">&lt;propertyName&gt;@annotations()</code></p></li><li class="list__item" id="rk8xnw_899"><p id="rk8xnw_903">&gt;= 1.4: names of synthetic <code class="code" id="rk8xnw_904">$annotations()</code> methods for properties include the <code class="code" id="rk8xnw_905">get</code> prefix: <code class="code" id="rk8xnw_906">get&lt;PropertyName&gt;@annotations()</code></p></li></ul></aside></section></section><div class="last-modified">05 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="compatibility-guide-15.html" class="navigation-links__prev">Compatibility guide for Kotlin 1.5</a><a href="compatibility-guide-13.html" class="navigation-links__next">Compatibility guide for Kotlin 1.3</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>