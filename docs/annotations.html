<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-28T16:03:09.089058351"><link rel="canonical" href="https://kotlinlang.org/docs/annotations.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Annotations | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"usage","level":0,"title":"Usage","anchor":"#usage"},{"id":"constructors","level":0,"title":"Constructors","anchor":"#constructors"},{"id":"instantiation","level":0,"title":"Instantiation","anchor":"#instantiation"},{"id":"lambdas","level":0,"title":"Lambdas","anchor":"#lambdas"},{"id":"annotation-use-site-targets","level":0,"title":"Annotation use-site targets","anchor":"#annotation-use-site-targets"},{"id":"defaults-when-no-use-site-targets-are-specified","level":1,"title":"Defaults when no use-site targets are specified","anchor":"#defaults-when-no-use-site-targets-are-specified"},{"id":"all-meta-target","level":1,"title":"all meta-target","anchor":"#all-meta-target"},{"id":"java-annotations","level":0,"title":"Java annotations","anchor":"#java-annotations"},{"id":"arrays-as-annotation-parameters","level":1,"title":"Arrays as annotation parameters","anchor":"#arrays-as-annotation-parameters"},{"id":"accessing-properties-of-an-annotation-instance","level":1,"title":"Accessing properties of an annotation instance","anchor":"#accessing-properties-of-an-annotation-instance"},{"id":"ability-to-not-generate-jvm-1-8-annotation-targets","level":1,"title":"Ability to not generate JVM 1.8+ annotation targets","anchor":"#ability-to-not-generate-jvm-1-8-annotation-targets"},{"id":"repeatable-annotations","level":0,"title":"Repeatable annotations","anchor":"#repeatable-annotations"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Annotations | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/annotations.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Annotations | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/annotations.html#webpage",
    "url": "https://kotlinlang.org/docs/annotations.html",
    "name": "Annotations | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="annotations" data-main-title="Annotations" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/annotations.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="annotations" id="annotations.md">Annotations</h1><p id="wnz077_2">Annotations are a means of attaching metadata to code. To declare an annotation, put the <code class="code" id="wnz077_14">annotation</code> modifier in front of a class:</p><div class="code-block" data-lang="kotlin">
annotation class Fancy
</div><p id="wnz077_4">Additional attributes of the annotation can be specified by annotating the annotation class with meta-annotations:</p><ul class="list _bullet" id="wnz077_5"><li class="list__item" id="wnz077_15"><p id="wnz077_19"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html" id="wnz077_20" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_21">@Target</code></a> specifies the possible kinds of elements which can be annotated with the annotation (such as classes, functions, properties, and expressions);</p></li><li class="list__item" id="wnz077_16"><p id="wnz077_22"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-retention/index.html" id="wnz077_23" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_24">@Retention</code></a> specifies whether the annotation is stored in the compiled class files and whether it's visible through reflection at runtime (by default, both are true);</p></li><li class="list__item" id="wnz077_17"><p id="wnz077_25"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index.html" id="wnz077_26" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_27">@Repeatable</code></a> allows using the same annotation on a single element multiple times;</p></li><li class="list__item" id="wnz077_18"><p id="wnz077_28"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-must-be-documented/index.html" id="wnz077_29" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_30">@MustBeDocumented</code></a> specifies that the annotation is part of the public API and should be included in the class or method signature shown in the generated API documentation.</p></li></ul><div class="code-block" data-lang="kotlin">
@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,
        AnnotationTarget.TYPE_PARAMETER, AnnotationTarget.VALUE_PARAMETER, 
        AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
annotation class Fancy
</div><section class="chapter"><h2 id="usage" data-toc="usage">Usage</h2><div class="code-block" data-lang="kotlin">
@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</div><p id="wnz077_32">If you need to annotate the primary constructor of a class, you need to add the <code class="code" id="wnz077_36">constructor</code> keyword to the constructor declaration, and add the annotations before it:</p><div class="code-block" data-lang="kotlin">
class Foo @Inject constructor(dependency: MyDependency) { ... }
</div><p id="wnz077_34">You can also annotate property accessors:</p><div class="code-block" data-lang="kotlin">
class Foo {
    var x: MyDependency? = null
        @Inject set
}
</div></section><section class="chapter"><h2 id="constructors" data-toc="constructors">Constructors</h2><p id="wnz077_37">Annotations can have constructors that take parameters.</p><div class="code-block" data-lang="kotlin">
annotation class Special(val why: String)

@Special(&quot;example&quot;) class Foo {}
</div><p id="wnz077_39">Allowed parameter types are:</p><ul class="list _bullet" id="wnz077_40"><li class="list__item" id="wnz077_46"><p id="wnz077_52">Types that correspond to Java primitive types (Int, Long etc.)</p></li><li class="list__item" id="wnz077_47"><p id="wnz077_53">Strings</p></li><li class="list__item" id="wnz077_48"><p id="wnz077_54">Classes (<code class="code" id="wnz077_55">Foo::class</code>)</p></li><li class="list__item" id="wnz077_49"><p id="wnz077_56">Enums</p></li><li class="list__item" id="wnz077_50"><p id="wnz077_57">Other annotations</p></li><li class="list__item" id="wnz077_51"><p id="wnz077_58">Arrays of the types listed above</p></li></ul><p id="wnz077_41">Annotation parameters cannot have nullable types, because the JVM does not support storing <code class="code" id="wnz077_59">null</code> as a value of an annotation attribute.</p><p id="wnz077_42">If an annotation is used as a parameter of another annotation, its name is not prefixed with the <code class="code" id="wnz077_60">@</code> character:</p><div class="code-block" data-lang="kotlin">
annotation class ReplaceWith(val expression: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(&quot;&quot;))

@Deprecated(&quot;This function is deprecated, use === instead&quot;, ReplaceWith(&quot;this === other&quot;))
</div><p id="wnz077_44">If you need to specify a class as an argument of an annotation, use a Kotlin class (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" id="wnz077_61" data-external="true" rel="noopener noreferrer" target="_blank">KClass</a>). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</p><div class="code-block" data-lang="kotlin">

import kotlin.reflect.KClass

annotation class Ann(val arg1: KClass&lt;*&gt;, val arg2: KClass&lt;out Any&gt;)

@Ann(String::class, Int::class) class MyClass
</div></section><section class="chapter"><h2 id="instantiation" data-toc="instantiation">Instantiation</h2><p id="wnz077_62">In Java, an annotation type is a form of an interface, so you can implement it and use an instance. As an alternative to this mechanism, Kotlin lets you call a constructor of an annotation class in arbitrary code and similarly use the resulting instance.</p><div class="code-block" data-lang="kotlin">
annotation class InfoMarker(val info: String)

fun processInfo(marker: InfoMarker): Unit = TODO()

fun main(args: Array&lt;String&gt;) {
    if (args.isNotEmpty())
        processInfo(getAnnotationReflective(args))
    else
        processInfo(InfoMarker(&quot;default&quot;))
}
</div><p id="wnz077_64">Learn more about instantiation of annotation classes in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-instantiation.md" id="wnz077_65" data-external="true" rel="noopener noreferrer" target="_blank">this KEEP</a>.</p></section><section class="chapter"><h2 id="lambdas" data-toc="lambdas">Lambdas</h2><p id="wnz077_66">Annotations can also be used on lambdas. They will be applied to the <code class="code" id="wnz077_68">invoke()</code> method into which the body of the lambda is generated. This is useful for frameworks like <a href="https://docs.paralleluniverse.co/quasar/" id="wnz077_69" data-external="true" rel="noopener noreferrer" target="_blank">Quasar</a>, which uses annotations for concurrency control.</p><div class="code-block" data-lang="kotlin">
annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }
</div></section><section class="chapter"><h2 id="annotation-use-site-targets" data-toc="annotation-use-site-targets">Annotation use-site targets</h2><p id="wnz077_70">When you're annotating a property or a primary constructor parameter, there are multiple Java elements that are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:</p><div class="code-block" data-lang="kotlin">
class Example(@field:Ann val foo,    // annotate only the Java field
              @get:Ann val bar,      // annotate only the Java getter
              @param:Ann val quux)   // annotate only the Java constructor parameter
</div><p id="wnz077_72">The same syntax can be used to annotate the entire file. To do this, put an annotation with the target <code class="code" id="wnz077_80">file</code> at the top level of a file, before the package directive or before all imports if the file is in the default package:</p><div class="code-block" data-lang="kotlin">
@file:JvmName(&quot;Foo&quot;)

package org.jetbrains.demo
</div><p id="wnz077_74">If you have multiple annotations with the same target, you can avoid repeating the target by adding brackets after the target and putting all the annotations inside the brackets (except for the <code class="code" id="wnz077_81">all</code> meta-target):</p><div class="code-block" data-lang="kotlin">
class Example {
     @set:[Inject VisibleForTesting]
     var collaborator: Collaborator
}
</div><p id="wnz077_76">The full list of supported use-site targets is:</p><ul class="list _bullet" id="wnz077_77"><li class="list__item" id="wnz077_82"><p id="wnz077_92"><code class="code" id="wnz077_93">file</code></p></li><li class="list__item" id="wnz077_83"><p id="wnz077_94"><code class="code" id="wnz077_95">field</code></p></li><li class="list__item" id="wnz077_84"><p id="wnz077_96"><code class="code" id="wnz077_97">property</code> (annotations with this target are not visible to Java)</p></li><li class="list__item" id="wnz077_85"><p id="wnz077_98"><code class="code" id="wnz077_99">get</code> (property getter)</p></li><li class="list__item" id="wnz077_86"><p id="wnz077_100"><code class="code" id="wnz077_101">set</code> (property setter)</p></li><li class="list__item" id="wnz077_87"><p id="wnz077_102"><code class="code" id="wnz077_103">all</code> (an experimental meta-target for properties, see <a href="#all-meta-target" id="wnz077_104">below</a> for its purpose and usage)</p></li><li class="list__item" id="wnz077_88"><p id="wnz077_105"><code class="code" id="wnz077_108">receiver</code> (receiver parameter of an extension function or property)</p><p id="wnz077_106">To annotate the receiver parameter of an extension function, use the following syntax:</p><div class="code-block" data-lang="kotlin">
fun @receiver:Fancy String.myExtension() { ... }
</div></li><li class="list__item" id="wnz077_89"><p id="wnz077_109"><code class="code" id="wnz077_110">param</code> (constructor parameter)</p></li><li class="list__item" id="wnz077_90"><p id="wnz077_111"><code class="code" id="wnz077_112">setparam</code> (property setter parameter)</p></li><li class="list__item" id="wnz077_91"><p id="wnz077_113"><code class="code" id="wnz077_114">delegate</code> (the field storing the delegate instance for a delegated property)</p></li></ul><section class="chapter"><h3 id="defaults-when-no-use-site-targets-are-specified" data-toc="defaults-when-no-use-site-targets-are-specified">Defaults when no use-site targets are specified</h3><p id="wnz077_115">If you don't specify a use-site target, the target is chosen according to the <code class="code" id="wnz077_131">@Target</code> annotation of the annotation being used. If there are multiple applicable targets, the first applicable target from the following list is used:</p><ul class="list _bullet" id="wnz077_116"><li class="list__item" id="wnz077_132"><p id="wnz077_135"><code class="code" id="wnz077_136">param</code></p></li><li class="list__item" id="wnz077_133"><p id="wnz077_137"><code class="code" id="wnz077_138">property</code></p></li><li class="list__item" id="wnz077_134"><p id="wnz077_139"><code class="code" id="wnz077_140">field</code></p></li></ul><p id="wnz077_117">Let's use the <a href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/email" id="wnz077_141" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_142">@Email</code> annotation from Jakarta Bean Validation</a>:</p><div class="code-block" data-lang="java">
@Target(value={METHOD,FIELD,ANNOTATION_TYPE,CONSTRUCTOR,PARAMETER,TYPE_USE})
public @interface Email { }
</div><p id="wnz077_119">With this annotation, consider the following example:</p><div class="code-block" data-lang="kotlin">
data class User(val username: String,
                // @Email is equivalent to @param:Email
                @Email val email: String) {
    // @Email is equivalent to @field:Email
    @Email val secondaryEmail: String? = null
}
</div><p id="wnz077_121">Kotlin 2.2.0 introduced an experimental defaulting rule which should make propagating annotations to parameters, fields, and properties more predictable.</p><p id="wnz077_122">With the new rule, if there are multiple applicable targets, one or more is chosen as follows:</p><ul class="list _bullet" id="wnz077_123"><li class="list__item" id="wnz077_143"><p id="wnz077_146">If the constructor parameter target (<code class="code" id="wnz077_147">param</code>) is applicable, it is used.</p></li><li class="list__item" id="wnz077_144"><p id="wnz077_148">If the property target (<code class="code" id="wnz077_149">property</code>) is applicable, it is used.</p></li><li class="list__item" id="wnz077_145"><p id="wnz077_150">If the field target (<code class="code" id="wnz077_151">field</code>) is applicable while <code class="code" id="wnz077_152">property</code> isn't, <code class="code" id="wnz077_153">field</code> is used.</p></li></ul><p id="wnz077_124">Using the same example:</p><div class="code-block" data-lang="kotlin">
data class User(val username: String,
                // @Email is now equivalent to @param:Email @field:Email
                @Email val email: String) {
    // @Email is still equivalent to @field:Email
    @Email val secondaryEmail: String? = null
}
</div><p id="wnz077_126">If there are multiple targets, and none of <code class="code" id="wnz077_154">param</code>, <code class="code" id="wnz077_155">property</code>, or <code class="code" id="wnz077_156">field</code> are applicable, the annotation is invalid.</p><p id="wnz077_127">To enable the new defaulting rule, use the following line in your Gradle configuration:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xannotation-default-target=param-property&quot;)
    }
}
</div><p id="wnz077_129">Whenever you'd like to use the old behavior, you can:</p><ul class="list _bullet" id="wnz077_130"><li class="list__item" id="wnz077_157"><p id="wnz077_159">In a specific case, specify the necessary target explicitly, for example, using <code class="code" id="wnz077_160">@param:Annotation</code> instead of <code class="code" id="wnz077_161">@Annotation</code>.</p></li><li class="list__item" id="wnz077_158"><p id="wnz077_162">For a whole project, use this flag in your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xannotation-default-target=first-only&quot;)
    }
}
</div></li></ul></section><section class="chapter"><h3 id="all-meta-target" data-toc="all-meta-target" data-label-id="experimental-opt-in"><code class="code" id="wnz077_176">all</code> meta-target</h3><p id="wnz077_166">The <code class="code" id="wnz077_177">all</code> target makes it easier to apply the same annotation not only to the parameter and the property or field, but also to the corresponding getter and setter.</p><p id="wnz077_167">Specifically, the annotation marked with <code class="code" id="wnz077_178">all</code> is propagated, if applicable:</p><ul class="list _bullet" id="wnz077_168"><li class="list__item" id="wnz077_179"><p id="wnz077_185">To the constructor parameter (<code class="code" id="wnz077_186">param</code>) if the property is defined in the primary constructor.</p></li><li class="list__item" id="wnz077_180"><p id="wnz077_187">To the property itself (<code class="code" id="wnz077_188">property</code>).</p></li><li class="list__item" id="wnz077_181"><p id="wnz077_189">To the backing field (<code class="code" id="wnz077_190">field</code>) if the property has one.</p></li><li class="list__item" id="wnz077_182"><p id="wnz077_191">To the getter (<code class="code" id="wnz077_192">get</code>).</p></li><li class="list__item" id="wnz077_183"><p id="wnz077_193">To the setter parameter (<code class="code" id="wnz077_194">setparam</code>) if the property is defined as <code class="code" id="wnz077_195">var</code>.</p></li><li class="list__item" id="wnz077_184"><p id="wnz077_196">To the Java-only target <code class="code" id="wnz077_197">RECORD_COMPONENT</code> if the class has the <code class="code" id="wnz077_198">@JvmRecord</code> annotation.</p></li></ul><p id="wnz077_169">Let's use the <a href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/email" id="wnz077_199" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_200">@Email</code> annotation from Jakarta Bean Validation</a>, which is defined as follows:</p><div class="code-block" data-lang="java">
@Target(value={METHOD,FIELD,ANNOTATION_TYPE,CONSTRUCTOR,PARAMETER,TYPE_USE})
public @interface Email { }
</div><p id="wnz077_171">In the example below, this <code class="code" id="wnz077_201">@Email</code> annotation is applied to all relevant targets:</p><div class="code-block" data-lang="kotlin">
data class User(
    val username: String,
    // Applies `@Email` to `param`, `field` and `get`
    @all:Email val email: String,
    // Applies `@Email` to `param`, `field`, `get`, and `set_param`
    @all:Email var name: String,
) {
    // Applies `@Email` to `field` and `getter` (no `param` since it's not in the constructor)
    @all:Email val secondaryEmail: String? = null
}
</div><p id="wnz077_173">You can use the <code class="code" id="wnz077_202">all</code> meta-target with any property, both inside and outside the primary constructor.</p><section class="chapter"><h4 id="limitations" data-toc="limitations">Limitations</h4><p id="wnz077_203">The <code class="code" id="wnz077_205">all</code> target comes with some limitations:</p><ul class="list _bullet" id="wnz077_204"><li class="list__item" id="wnz077_206"><p id="wnz077_209">It does not propagate an annotation to types, potential extension receivers, or context receivers or parameters.</p></li><li class="list__item" id="wnz077_207"><p id="wnz077_210">It cannot be used with multiple annotations:</p><div class="code-block" data-lang="kotlin">
@all:[A B] // forbidden, use `@all:A @all:B`
val x: Int = 5
</div></li><li class="list__item" id="wnz077_208"><p id="wnz077_212">It cannot be used with <a href="delegated-properties.html" id="wnz077_213">delegated properties</a>.</p></li></ul></section><section class="chapter"><h4 id="how-to-enable" data-toc="how-to-enable">How to enable</h4><p id="wnz077_214">To enable the <code class="code" id="wnz077_218">all</code> meta-target in your project, use the following compiler option in the command line:</p><div class="code-block" data-lang="bash">
-Xannotation-target-all
</div><p id="wnz077_216">Or add it to the <code class="code" id="wnz077_219">compilerOptions {}</code> block of your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xannotation-target-all&quot;)
    }
}
</div></section></section></section><section class="chapter"><h2 id="java-annotations" data-toc="java-annotations">Java annotations</h2><p id="wnz077_220">Java annotations are 100% compatible with Kotlin:</p><div class="code-block" data-lang="kotlin">
import org.junit.Test
import org.junit.Assert.*
import org.junit.Rule
import org.junit.rules.*

class Tests {
    // apply @Rule annotation to property getter
    @get:Rule val tempFolder = TemporaryFolder()

    @Test fun simple() {
        val f = tempFolder.newFile()
        assertEquals(42, getTheAnswer())
    }
}
</div><p id="wnz077_222">Since the order of parameters for an annotation written in Java is not defined, you can't use a regular function call syntax for passing the arguments. Instead, you need to use the named argument syntax:</p><div class="code-block" data-lang="java">
// Java
public @interface Ann {
    int intValue();
    String stringValue();
}
</div><div class="code-block" data-lang="kotlin">
// Kotlin
@Ann(intValue = 1, stringValue = &quot;abc&quot;) class C
</div><p id="wnz077_225">Just like in Java, a special case is the <code class="code" id="wnz077_231">value</code> parameter; its value can be specified without an explicit name:</p><div class="code-block" data-lang="java">
// Java
public @interface AnnWithValue {
    String value();
}
</div><div class="code-block" data-lang="kotlin">
// Kotlin
@AnnWithValue(&quot;abc&quot;) class C
</div><section class="chapter"><h3 id="arrays-as-annotation-parameters" data-toc="arrays-as-annotation-parameters">Arrays as annotation parameters</h3><p id="wnz077_232">If the <code class="code" id="wnz077_238">value</code> argument in Java has an array type, it becomes a <code class="code" id="wnz077_239">vararg</code> parameter in Kotlin:</p><div class="code-block" data-lang="java">
// Java
public @interface AnnWithArrayValue {
    String[] value();
}
</div><div class="code-block" data-lang="kotlin">
// Kotlin
@AnnWithArrayValue(&quot;abc&quot;, &quot;foo&quot;, &quot;bar&quot;) class C
</div><p id="wnz077_235">For other arguments that have an array type, you need to use the array literal syntax or <code class="code" id="wnz077_240">arrayOf(...)</code>:</p><div class="code-block" data-lang="java">
// Java
public @interface AnnWithArrayMethod {
    String[] names();
}
</div><div class="code-block" data-lang="kotlin">
@AnnWithArrayMethod(names = [&quot;abc&quot;, &quot;foo&quot;, &quot;bar&quot;]) 
class C
</div></section><section class="chapter"><h3 id="accessing-properties-of-an-annotation-instance" data-toc="accessing-properties-of-an-annotation-instance">Accessing properties of an annotation instance</h3><p id="wnz077_241">Values of an annotation instance are exposed as properties to Kotlin code:</p><div class="code-block" data-lang="java">
// Java
public @interface Ann {
    int value();
}
</div><div class="code-block" data-lang="kotlin">
// Kotlin
fun foo(ann: Ann) {
    val i = ann.value
}
</div></section><section class="chapter"><h3 id="ability-to-not-generate-jvm-1-8-annotation-targets" data-toc="ability-to-not-generate-jvm-1-8-annotation-targets">Ability to not generate JVM 1.8+ annotation targets</h3><p id="wnz077_244">If a Kotlin annotation has <code class="code" id="wnz077_246">TYPE</code> among its Kotlin targets, the annotation maps to <code class="code" id="wnz077_247">java.lang.annotation.ElementType.TYPE_USE</code> in its list of Java annotation targets. This is just like how the <code class="code" id="wnz077_248">TYPE_PARAMETER</code> Kotlin target maps to the <code class="code" id="wnz077_249">java.lang.annotation.ElementType.TYPE_PARAMETER</code> Java target. This is an issue for Android clients with API levels less than 26, which don't have these targets in the API.</p><p id="wnz077_245">To avoid generating the <code class="code" id="wnz077_250">TYPE_USE</code> and <code class="code" id="wnz077_251">TYPE_PARAMETER</code> annotation targets, use the new compiler argument <code class="code" id="wnz077_252">-Xno-new-java-annotation-targets</code>.</p></section></section><section class="chapter"><h2 id="repeatable-annotations" data-toc="repeatable-annotations">Repeatable annotations</h2><p id="wnz077_253">Just like <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" id="wnz077_260" data-external="true" rel="noopener noreferrer" target="_blank">in Java</a>, Kotlin has repeatable annotations, which can be applied to a single code element multiple times. To make your annotation repeatable, mark its declaration with the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/" id="wnz077_261" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_262">@kotlin.annotation.Repeatable</code></a> meta-annotation. This will make it repeatable both in Kotlin and Java. Java repeatable annotations are also supported from the Kotlin side.</p><p id="wnz077_254">The main difference with the scheme used in Java is the absence of a <span class="emphasis" id="wnz077_263">containing annotation</span>, which the Kotlin compiler generates automatically with a predefined name. For an annotation in the example below, it will generate the containing annotation <code class="code" id="wnz077_264">@Tag.Container</code>:</p><div class="code-block" data-lang="kotlin">
@Repeatable
annotation class Tag(val name: String)

// The compiler generates the @Tag.Container containing annotation
</div><p id="wnz077_256">You can set a custom name for a containing annotation by applying the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvmrepeatable/" id="wnz077_265" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_266">@kotlin.jvm.JvmRepeatable</code></a> meta-annotation and passing an explicitly declared containing annotation class as an argument:</p><div class="code-block" data-lang="kotlin">
@JvmRepeatable(Tags::class)
annotation class Tag(val name: String)

annotation class Tags(val value: Array&lt;Tag&gt;)
</div><p id="wnz077_258">To extract Kotlin or Java repeatable annotations via reflection, use the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations.html" id="wnz077_267" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="wnz077_268">KAnnotatedElement.findAnnotations()</code></a> function.</p><p id="wnz077_259">Learn more about Kotlin repeatable annotations in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/repeatable-annotations.md" id="wnz077_269" data-external="true" rel="noopener noreferrer" target="_blank">this KEEP</a>.</p></section><div class="last-modified">28 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="coroutines-overview.html" class="navigation-links__prev">Coroutines</a><a href="destructuring-declarations.html" class="navigation-links__next">Destructuring declarations</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>