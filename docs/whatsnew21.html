<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-01T15:59:01.842549963"><link rel="canonical" href="https://kotlinlang.org/docs/whatsnew21.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>What's new in Kotlin 2.1.0 | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"ide-support","level":0,"title":"IDE support","anchor":"#ide-support"},{"id":"language","level":0,"title":"Language","anchor":"#language"},{"id":"guard-conditions-in-when-with-a-subject","level":1,"title":"Guard conditions in when with a subject","anchor":"#guard-conditions-in-when-with-a-subject"},{"id":"non-local-break-and-continue","level":1,"title":"Non-local break and continue","anchor":"#non-local-break-and-continue"},{"id":"multi-dollar-string-interpolation","level":1,"title":"Multi-dollar string interpolation","anchor":"#multi-dollar-string-interpolation"},{"id":"support-for-requiring-opt-in-to-extend-apis","level":1,"title":"Support for requiring opt-in to extend APIs","anchor":"#support-for-requiring-opt-in-to-extend-apis"},{"id":"improved-overload-resolution-for-functions-with-generic-types","level":1,"title":"Improved overload resolution for functions with generic types","anchor":"#improved-overload-resolution-for-functions-with-generic-types"},{"id":"improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes","level":1,"title":"Improved exhaustiveness checks for when expressions with sealed classes","anchor":"#improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes"},{"id":"kotlin-k2-compiler","level":0,"title":"Kotlin K2 compiler","anchor":"#kotlin-k2-compiler"},{"id":"extra-compiler-checks","level":1,"title":"Extra compiler checks","anchor":"#extra-compiler-checks"},{"id":"global-warning-suppression","level":1,"title":"Global warning suppression","anchor":"#global-warning-suppression"},{"id":"improved-k2-kapt-implementation","level":1,"title":"Improved K2 kapt implementation","anchor":"#improved-k2-kapt-implementation"},{"id":"resolution-for-overload-conflicts-between-unsigned-and-non-primitive-types","level":1,"title":"Resolution for overload conflicts between unsigned and non-primitive types","anchor":"#resolution-for-overload-conflicts-between-unsigned-and-non-primitive-types"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"change-of-jspecify-nullability-mismatch-diagnostics-severity-to-strict","level":1,"title":"Change of JSpecify nullability mismatch diagnostics severity to strict","anchor":"#change-of-jspecify-nullability-mismatch-diagnostics-severity-to-strict"},{"id":"kotlin-multiplatform","level":0,"title":"Kotlin Multiplatform","anchor":"#kotlin-multiplatform"},{"id":"new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable","level":1,"title":"New Gradle DSL for compiler options in multiplatform projects promoted to Stable","anchor":"#new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable"},{"id":"preview-gradle-s-isolated-projects-in-kotlin-multiplatform","level":1,"title":"Preview Gradle\u0027s Isolated Projects in Kotlin Multiplatform","anchor":"#preview-gradle-s-isolated-projects-in-kotlin-multiplatform"},{"id":"basic-support-for-swift-export","level":1,"title":"Basic support for Swift export","anchor":"#basic-support-for-swift-export"},{"id":"ability-to-publish-kotlin-libraries-from-any-host","level":1,"title":"Ability to publish Kotlin libraries from any host","anchor":"#ability-to-publish-kotlin-libraries-from-any-host"},{"id":"support-for-non-packed-klibs","level":1,"title":"Support for non-packed klibs","anchor":"#support-for-non-packed-klibs"},{"id":"further-deprecation-of-old-android-target","level":1,"title":"Further deprecation of old android target","anchor":"#further-deprecation-of-old-android-target"},{"id":"dropped-support-for-declaring-multiple-targets-of-the-same-type","level":1,"title":"Dropped support for declaring multiple targets of the same type","anchor":"#dropped-support-for-declaring-multiple-targets-of-the-same-type"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"iosarm64-promoted-to-tier-1","level":1,"title":"iosArm64 promoted to Tier 1","anchor":"#iosarm64-promoted-to-tier-1"},{"id":"llvm-update-from-11-1-0-to-16-0-0","level":1,"title":"LLVM update from 11.1.0 to 16.0.0","anchor":"#llvm-update-from-11-1-0-to-16-0-0"},{"id":"changes-to-caching-in-cinterop","level":1,"title":"Changes to caching in cinterop","anchor":"#changes-to-caching-in-cinterop"},{"id":"deprecation-of-the-mimalloc-memory-allocator","level":1,"title":"Deprecation of the mimalloc memory allocator","anchor":"#deprecation-of-the-mimalloc-memory-allocator"},{"id":"kotlin-wasm","level":0,"title":"Kotlin/Wasm","anchor":"#kotlin-wasm"},{"id":"support-for-incremental-compilation","level":1,"title":"Support for incremental compilation","anchor":"#support-for-incremental-compilation"},{"id":"browser-apis-moved-to-the-kotlinx-browser-stand-alone-library","level":1,"title":"Browser APIs moved to the kotlinx-browser stand-alone library","anchor":"#browser-apis-moved-to-the-kotlinx-browser-stand-alone-library"},{"id":"improved-debugging-experience-for-kotlin-wasm","level":1,"title":"Improved debugging experience for Kotlin/Wasm","anchor":"#improved-debugging-experience-for-kotlin-wasm"},{"id":"reduced-size-of-kotlin-wasm-binaries","level":1,"title":"Reduced size of Kotlin/Wasm binaries","anchor":"#reduced-size-of-kotlin-wasm-binaries"},{"id":"improved-javascript-array-interoperability-in-kotlin-wasm","level":1,"title":"Improved JavaScript array interoperability in Kotlin/Wasm","anchor":"#improved-javascript-array-interoperability-in-kotlin-wasm"},{"id":"support-for-accessing-javascript-exception-details-in-kotlin-wasm","level":1,"title":"Support for accessing JavaScript exception details in Kotlin/Wasm","anchor":"#support-for-accessing-javascript-exception-details-in-kotlin-wasm"},{"id":"deprecation-of-default-exports","level":1,"title":"Deprecation of default exports","anchor":"#deprecation-of-default-exports"},{"id":"subproject-specific-node-js-settings","level":1,"title":"Subproject-specific Node.js settings","anchor":"#subproject-specific-node-js-settings"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"support-for-non-identifier-characters-in-properties","level":1,"title":"Support for non-identifier characters in properties","anchor":"#support-for-non-identifier-characters-in-properties"},{"id":"support-for-generating-es2015-arrow-functions","level":1,"title":"Support for generating ES2015 arrow functions","anchor":"#support-for-generating-es2015-arrow-functions"},{"id":"gradle-improvements","level":0,"title":"Gradle improvements","anchor":"#gradle-improvements"},{"id":"minimum-supported-agp-version-bumped-to-7-3-1","level":1,"title":"Minimum supported AGP version bumped to 7.3.1","anchor":"#minimum-supported-agp-version-bumped-to-7-3-1"},{"id":"minimum-supported-gradle-version-bumped-to-7-6-3","level":1,"title":"Minimum supported Gradle version bumped to 7.6.3","anchor":"#minimum-supported-gradle-version-bumped-to-7-6-3"},{"id":"new-api-for-kotlin-gradle-plugin-extensions","level":1,"title":"New API for Kotlin Gradle plugin extensions","anchor":"#new-api-for-kotlin-gradle-plugin-extensions"},{"id":"compiler-symbols-hidden-from-the-kotlin-gradle-plugin-api","level":1,"title":"Compiler symbols hidden from the Kotlin Gradle plugin API","anchor":"#compiler-symbols-hidden-from-the-kotlin-gradle-plugin-api"},{"id":"compose-compiler-updates","level":0,"title":"Compose compiler updates","anchor":"#compose-compiler-updates"},{"id":"support-for-multiple-stability-configuration-files","level":1,"title":"Support for multiple stability configuration files","anchor":"#support-for-multiple-stability-configuration-files"},{"id":"pausable-composition","level":1,"title":"Pausable composition","anchor":"#pausable-composition"},{"id":"changes-to-open-and-overridden-composable-functions","level":1,"title":"Changes to open and overridden @Composable functions","anchor":"#changes-to-open-and-overridden-composable-functions"},{"id":"performance-improvements","level":1,"title":"Performance improvements","anchor":"#performance-improvements"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"changes-to-the-deprecation-severity-of-standard-library-apis","level":1,"title":"Changes to the deprecation severity of standard library APIs","anchor":"#changes-to-the-deprecation-severity-of-standard-library-apis"},{"id":"stable-file-tree-traversal-extensions-for-java-nio-file-path","level":1,"title":"Stable file tree traversal extensions for java.nio.file.Path","anchor":"#stable-file-tree-traversal-extensions-for-java-nio-file-path"},{"id":"documentation-updates","level":0,"title":"Documentation updates","anchor":"#documentation-updates"},{"id":"language-concepts","level":1,"title":"Language concepts","anchor":"#language-concepts"},{"id":"compose-compiler","level":1,"title":"Compose compiler","anchor":"#compose-compiler"},{"id":"api-references","level":1,"title":"API references","anchor":"#api-references"},{"id":"multiplatform-development","level":1,"title":"Multiplatform development","anchor":"#multiplatform-development"},{"id":"tooling","level":1,"title":"Tooling","anchor":"#tooling"},{"id":"compatibility-guide-for-kotlin-2-1-0","level":0,"title":"Compatibility guide for Kotlin 2.1.0","anchor":"#compatibility-guide-for-kotlin-2-1-0"},{"id":"install-kotlin-2-1-0","level":0,"title":"Install Kotlin 2.1.0","anchor":"#install-kotlin-2-1-0"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 2.1.0 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/whatsnew21.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="What's new in Kotlin 2.1.0 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/whatsnew21.html#webpage",
    "url": "https://kotlinlang.org/docs/whatsnew21.html",
    "name": "What's new in Kotlin 2.1.0 | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="whatsnew21" data-main-title="What's new in Kotlin 2.1.0" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/whatsnew/whatsnew21.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew21" id="whatsnew21.md">What's new in Kotlin 2.1.0</h1><p id="-qc40jp_2"><span class="emphasis" id="-qc40jp_19"><a href="releases.html#release-details" id="-qc40jp_20">Released: November 27, 2024</a></span></p><p id="-qc40jp_3">The Kotlin 2.1.0 release is here! Here are the main highlights:</p><ul class="list _bullet" id="-qc40jp_4"><li class="list__item" id="-qc40jp_21"><p id="-qc40jp_28"><span class="control" id="-qc40jp_29">New language features in preview</span>: <a href="#guard-conditions-in-when-with-a-subject" id="-qc40jp_30">Guard conditions in <code class="code" id="-qc40jp_33">when</code> with a subject</a>, <a href="#non-local-break-and-continue" id="-qc40jp_31">non-local <code class="code" id="-qc40jp_34">break</code> and <code class="code" id="-qc40jp_35">continue</code></a>, and <a href="#multi-dollar-string-interpolation" id="-qc40jp_32">multi-dollar string interpolation</a>.</p></li><li class="list__item" id="-qc40jp_22"><p id="-qc40jp_36"><span class="control" id="-qc40jp_37">K2 compiler updates</span>: <a href="#extra-compiler-checks" id="-qc40jp_38">More flexibility around compiler checks</a> and <a href="#improved-k2-kapt-implementation" id="-qc40jp_39">improvements to the kapt implementation</a>.</p></li><li class="list__item" id="-qc40jp_23"><p id="-qc40jp_40"><span class="control" id="-qc40jp_41">Kotlin Multiplatform</span>: Introduced <a href="#basic-support-for-swift-export" id="-qc40jp_42">basic support for Swift export</a>, <a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable" id="-qc40jp_43">stable Gradle DSL for compiler options</a>, and more.</p></li><li class="list__item" id="-qc40jp_24"><p id="-qc40jp_44"><span class="control" id="-qc40jp_45">Kotlin/Native</span>: <a href="#iosarm64-promoted-to-tier-1" id="-qc40jp_46">Improved support for <code class="code" id="-qc40jp_47">iosArm64</code></a> and other updates.</p></li><li class="list__item" id="-qc40jp_25"><p id="-qc40jp_48"><span class="control" id="-qc40jp_49">Kotlin/Wasm</span>: Multiple updates, including <a href="#support-for-incremental-compilation" id="-qc40jp_50">support for incremental compilation</a>.</p></li><li class="list__item" id="-qc40jp_26"><p id="-qc40jp_51"><span class="control" id="-qc40jp_52">Gradle support</span>: <a href="#gradle-improvements" id="-qc40jp_53">Improved compatibility with newer versions of Gradle and the Android Gradle plugin</a>, along with <a href="#new-api-for-kotlin-gradle-plugin-extensions" id="-qc40jp_54">updates to the Kotlin Gradle plugin API</a>.</p></li><li class="list__item" id="-qc40jp_27"><p id="-qc40jp_55"><span class="control" id="-qc40jp_56">Documentation</span>: <a href="#documentation-updates" id="-qc40jp_57">Significant improvements to the Kotlin documentation</a>.</p></li></ul><section class="chapter"><h2 id="ide-support" data-toc="ide-support">IDE support</h2><p id="-qc40jp_58">The Kotlin plugins that support 2.1.0 are bundled in the latest IntelliJ IDEA and Android Studio. You don't need to update the Kotlin plugin in your IDE. All you need to do is change the Kotlin version to 2.1.0 in your build scripts.</p><p id="-qc40jp_59">See <a href="releases.html#update-to-a-new-kotlin-version" id="-qc40jp_60">Update to a new Kotlin version</a> for details.</p></section><section class="chapter"><h2 id="language" data-toc="language">Language</h2><p id="-qc40jp_61">After the Kotlin 2.0.0 release with the K2 compiler, the JetBrains team is focusing on improving the language with new features. In this release, we are excited to announce several new language design improvements.</p><p id="-qc40jp_62">These features are available in preview, and we encourage you to try them and share your feedback:</p><ul class="list _bullet" id="-qc40jp_63"><li class="list__item" id="-qc40jp_74"><p id="-qc40jp_77"><a href="#guard-conditions-in-when-with-a-subject" id="-qc40jp_78">Guard conditions in <code class="code" id="-qc40jp_79">when</code> with a subject</a></p></li><li class="list__item" id="-qc40jp_75"><p id="-qc40jp_80"><a href="#non-local-break-and-continue" id="-qc40jp_81">Non-local <code class="code" id="-qc40jp_82">break</code> and <code class="code" id="-qc40jp_83">continue</code></a></p></li><li class="list__item" id="-qc40jp_76"><p id="-qc40jp_84"><a href="#multi-dollar-string-interpolation" id="-qc40jp_85">Multi-dollar interpolation: improved handling of <code class="code" id="-qc40jp_86">$</code> in string literals</a></p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-qc40jp_64"><p id="-qc40jp_87">All the features have IDE support in the latest 2024.3 version of IntelliJ IDEA with K2 mode enabled.</p><p id="-qc40jp_88">Learn more in the <a href="https://blog.jetbrains.com/idea/2024/11/intellij-idea-2024-3/" id="-qc40jp_89" data-external="true" rel="noopener noreferrer" target="_blank">IntelliJ IDEA 2024.3 blog post</a>.</p></aside><p id="-qc40jp_65"><a href="kotlin-language-features-and-proposals.html" id="-qc40jp_90">See the full list of Kotlin language design features and proposals</a>.</p><p id="-qc40jp_66">This release also brings the following language updates:</p><ul class="list _bullet" id="-qc40jp_67"><li class="list__item" id="-qc40jp_91"><p id="-qc40jp_94"><a href="#support-for-requiring-opt-in-to-extend-apis" id="-qc40jp_95">Support for requiring opt-in to extend APIs</a></p></li><li class="list__item" id="-qc40jp_92"><p id="-qc40jp_96"><a href="#improved-overload-resolution-for-functions-with-generic-types" id="-qc40jp_97">Improved overload resolution for functions with generic types</a></p></li><li class="list__item" id="-qc40jp_93"><p id="-qc40jp_98"><a href="#improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes" id="-qc40jp_99">Improved exhaustiveness checks for when expressions with sealed classes</a></p></li></ul><section class="chapter"><h3 id="guard-conditions-in-when-with-a-subject" data-toc="guard-conditions-in-when-with-a-subject">Guard conditions in when with a subject</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_100"><p id="-qc40jp_110">This feature is <a href="kotlin-evolution-principles.html#pre-stable-features" id="-qc40jp_112">In preview</a>, and opt-in is required (see details below).</p><p id="-qc40jp_111">We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-71140" id="-qc40jp_113" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_101">Starting from 2.1.0, you can use guard conditions in <code class="code" id="-qc40jp_114">when</code> expressions or statements with subjects.</p><p id="-qc40jp_102">Guard conditions allow you to include more than one condition for the branches of a <code class="code" id="-qc40jp_115">when</code> expression, making complex control flows more explicit and concise as well as flattening the code structure.</p><p id="-qc40jp_103">To include a guard condition in a branch, place it after the primary condition, separated by <code class="code" id="-qc40jp_116">if</code>:</p><div class="code-block" data-lang="kotlin">
sealed interface Animal {
    data class Cat(val mouseHunter: Boolean) : Animal {
        fun feedCat() {}
    }

    data class Dog(val breed: String) : Animal {
        fun feedDog() {}
    }
}

fun feedAnimal(animal: Animal) {
    when (animal) {
        // Branch with only the primary condition. Calls `feedDog()` when `animal` is `Dog`
        is Animal.Dog -&gt; animal.feedDog()
        // Branch with both primary and guard conditions. Calls `feedCat()` when `animal` is `Cat` and is not `mouseHunter`
        is Animal.Cat if !animal.mouseHunter -&gt; animal.feedCat()
        // Prints &quot;Unknown animal&quot; if none of the above conditions match
        else -&gt; println(&quot;Unknown animal&quot;)
    }
}
</div><p id="-qc40jp_105">In a single <code class="code" id="-qc40jp_117">when</code> expression, you can combine branches with and without guard conditions. The code in a branch with a guard condition runs only if both the primary condition and the guard condition are <code class="code" id="-qc40jp_118">true</code>. If the primary condition does not match, the guard condition is not evaluated. Additionally, guard conditions support <code class="code" id="-qc40jp_119">else if</code>.</p><p id="-qc40jp_106">To enable guard conditions in your project, use the following compiler option in the command line:</p><div class="code-block" data-lang="bash">
kotlinc -Xwhen-guards main.kt
</div><p id="-qc40jp_108">Or add it to the <code class="code" id="-qc40jp_120">compilerOptions {}</code> block of your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xwhen-guards&quot;)
    }
}
</div></section><section class="chapter"><h3 id="non-local-break-and-continue" data-toc="non-local-break-and-continue">Non-local break and continue</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_121"><p id="-qc40jp_130">This feature is <a href="kotlin-evolution-principles.html#pre-stable-features" id="-qc40jp_132">In preview</a>, and opt-in is required (see details below).</p><p id="-qc40jp_131">We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-1436" id="-qc40jp_133" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_122">Kotlin 2.1.0 adds a preview of another long-awaited feature, the ability to use non-local <code class="code" id="-qc40jp_134">break</code> and <code class="code" id="-qc40jp_135">continue</code>. This feature expands the toolset you can use in the scope of inline functions and reduces boilerplate code in your project.</p><p id="-qc40jp_123">Previously, you could use only non-local returns. Now, Kotlin also supports <code class="code" id="-qc40jp_136">break</code> and <code class="code" id="-qc40jp_137">continue</code> <a href="returns.html" id="-qc40jp_138">jump expressions</a> non-locally. This means that you can apply them within lambdas passed as arguments to an inline function that encloses the loop:</p><div class="code-block" data-lang="kotlin">
fun processList(elements: List&lt;Int&gt;): Boolean {
    for (element in elements) {
        val variable = element.nullableMethod() ?: run {
            log.warning(&quot;Element is null or invalid, continuing...&quot;)
            continue
        }
        if (variable == 0) return true // If variable is zero, return true
    }
    return false
}
</div><p id="-qc40jp_125">To try the feature in your project, use the <code class="code" id="-qc40jp_139">-Xnon-local-break-continue</code> compiler option in the command line:</p><div class="code-block" data-lang="bash">
kotlinc -Xnon-local-break-continue main.kt
</div><p id="-qc40jp_127">Or add it in the <code class="code" id="-qc40jp_140">compilerOptions {}</code> block of your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xnon-local-break-continue&quot;)
    }
}
</div><p id="-qc40jp_129">We're planning to make this feature Stable in future Kotlin releases. If you encounter any issues when using non-local <code class="code" id="-qc40jp_141">break</code> and <code class="code" id="-qc40jp_142">continue</code>, please report them to our <a href="https://youtrack.jetbrains.com/issue/KT-1436" id="-qc40jp_143" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>.</p></section><section class="chapter"><h3 id="multi-dollar-string-interpolation" data-toc="multi-dollar-string-interpolation">Multi-dollar string interpolation</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_144"><p id="-qc40jp_156">The feature is <a href="kotlin-evolution-principles.html#pre-stable-features" id="-qc40jp_158">In preview</a> and opt-in is required (see details below).</p><p id="-qc40jp_157">We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-2425" id="-qc40jp_159" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_145">Kotlin 2.1.0 introduces support for multi-dollar string interpolation, improving how the dollar sign (<code class="code" id="-qc40jp_160">$</code>) is handled within string literals. This feature is helpful in contexts that require multiple dollar signs, such as templating engines, JSON schemas, or other data formats.</p><p id="-qc40jp_146">String interpolation in Kotlin uses a single dollar sign. However, using a literal dollar sign in a string, which is common in financial data and templating systems, required workarounds such as <code class="code" id="-qc40jp_161">${'$'}</code>. With the multi-dollar interpolation feature enabled, you can configure how many dollar signs trigger interpolation, with fewer dollar signs being treated as string literals.</p><p id="-qc40jp_147">Here's an example of how to generate an JSON schema multi-line string with placeholders using <code class="code" id="-qc40jp_162">$</code>:</p><div class="code-block" data-lang="kotlin">
val KClass&lt;*&gt;.jsonSchema : String
    get() = $$&quot;&quot;&quot;
    {
      &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
      &quot;$id&quot;: &quot;https://example.com/product.schema.json&quot;,
      &quot;$dynamicAnchor&quot;: &quot;meta&quot;
      &quot;title&quot;: &quot;$${simpleName ?: qualifiedName ?: &quot;unknown&quot;}&quot;,
      &quot;type&quot;: &quot;object&quot;
    }
    &quot;&quot;&quot;
</div><p id="-qc40jp_149">In this example, the initial <code class="code" id="-qc40jp_163">$$</code> means that you need <span class="control" id="-qc40jp_164">two dollar signs</span> (<code class="code" id="-qc40jp_165">$$</code>) to trigger interpolation. It prevents <code class="code" id="-qc40jp_166">$schema</code>, <code class="code" id="-qc40jp_167">$id</code>, and <code class="code" id="-qc40jp_168">$dynamicAnchor</code> from being interpreted as interpolation markers.</p><p id="-qc40jp_150">This approach is especially helpful when working with systems that use dollar signs for placeholder syntax.</p><p id="-qc40jp_151">To enable the feature, use the following compiler option in the command line:</p><div class="code-block" data-lang="bash">
kotlinc -Xmulti-dollar-interpolation main.kt
</div><p id="-qc40jp_153">Alternatively, update the <code class="code" id="-qc40jp_169">compilerOptions {}</code> block of your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xmulti-dollar-interpolation&quot;)
    }
}
</div><p id="-qc40jp_155">If your code already uses standard string interpolation with a single dollar sign, no changes are needed. You can use <code class="code" id="-qc40jp_170">$$</code> whenever you need literal dollar signs in your strings.</p></section><section class="chapter"><h3 id="support-for-requiring-opt-in-to-extend-apis" data-toc="support-for-requiring-opt-in-to-extend-apis">Support for requiring opt-in to extend APIs</h3><p id="-qc40jp_171">Kotlin 2.1.0 introduces the <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-subclass-opt-in-required/" id="-qc40jp_179" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-qc40jp_180">@SubclassOptInRequired</code></a> annotation, which allows library authors to require an explicit opt-in before users can implement experimental interfaces or extend experimental classes.</p><p id="-qc40jp_172">This feature can be useful when a library API is stable enough to use but might evolve with new abstract functions, making it unstable for inheritance.</p><p id="-qc40jp_173">To add the opt-in requirement to an API element, use the <code class="code" id="-qc40jp_181">@SubclassOptInRequired</code> annotation with a reference to the annotation class:</p><div class="code-block" data-lang="kotlin">
@RequiresOptIn(
level = RequiresOptIn.Level.WARNING,
message = &quot;Interfaces in this library are experimental&quot;
)
annotation class UnstableApi()

@SubclassOptInRequired(UnstableApi::class)
interface CoreLibraryApi
</div><p id="-qc40jp_175">In this example, the <code class="code" id="-qc40jp_182">CoreLibraryApi</code> interface requires users to opt in before they can implement it. A user can opt in like this:</p><div class="code-block" data-lang="kotlin">
@OptIn(UnstableApi::class)
interface MyImplementation: CoreLibraryApi
</div><aside class="prompt" data-type="note" data-title="" id="-qc40jp_177"><p id="-qc40jp_183">When you use the <code class="code" id="-qc40jp_184">@SubclassOptInRequired</code> annotation to require opt-in, the requirement is not propagated to any <a href="nested-classes.html" id="-qc40jp_185">inner or nested classes</a>.</p></aside><p id="-qc40jp_178">For a real-world example of how to use the <code class="code" id="-qc40jp_186">@SubclassOptInRequired</code> annotation in your API, check out the <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" id="-qc40jp_187" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-qc40jp_189">SharedFlow</code></a> interface in the <code class="code" id="-qc40jp_188">kotlinx.coroutines</code> library.</p></section><section class="chapter"><h3 id="improved-overload-resolution-for-functions-with-generic-types" data-toc="improved-overload-resolution-for-functions-with-generic-types">Improved overload resolution for functions with generic types</h3><p id="-qc40jp_190">Previously, if you had a number of overloads for a function where some had value parameters of a generic type and others had function types in the same position, the resolution behavior could sometimes be inconsistent.</p><p id="-qc40jp_191">This led to different behavior depending on whether your overloads were member functions or extension functions. For example:</p><div class="code-block" data-lang="kotlin">
class KeyValueStore&lt;K, V&gt; {
    fun store(key: K, value: V) {} // 1
    fun store(key: K, lazyValue: () -&gt; V) {} // 2
}

fun &lt;K, V&gt; KeyValueStore&lt;K, V&gt;.storeExtension(key: K, value: V) {} // 1 
fun &lt;K, V&gt; KeyValueStore&lt;K, V&gt;.storeExtension(key: K, lazyValue: () -&gt; V) {} // 2

fun test(kvs: KeyValueStore&lt;String, Int&gt;) {
    // Member functions
    kvs.store(&quot;&quot;, 1)    // Resolves to 1
    kvs.store(&quot;&quot;) { 1 } // Resolves to 2

    // Extension functions
    kvs.storeExtension(&quot;&quot;, 1)    // Resolves to 1
    kvs.storeExtension(&quot;&quot;) { 1 } // Doesn't resolve
}
</div><p id="-qc40jp_193">In this example, the <code class="code" id="-qc40jp_196">KeyValueStore</code> class has two overloads for the <code class="code" id="-qc40jp_197">store()</code> function, where one overload has function parameters with generic types <code class="code" id="-qc40jp_198">K</code> and <code class="code" id="-qc40jp_199">V</code>, and another has a lambda function that returns a generic type <code class="code" id="-qc40jp_200">V</code>. Similarly, there are two overloads for the extension function: <code class="code" id="-qc40jp_201">storeExtension()</code>.</p><p id="-qc40jp_194">When the <code class="code" id="-qc40jp_202">store()</code> function was called with and without a lambda function, the compiler successfully resolved the correct overloads. However, when the extension function <code class="code" id="-qc40jp_203">storeExtension()</code> was called with a lambda function, the compiler didn't resolve the correct overload because it incorrectly considered both overloads to be applicable.</p><p id="-qc40jp_195">To fix this problem, we've introduced a new heuristic so that the compiler can discard a possible overload when a function parameter with a generic type can't accept a lambda function based on information from a different argument. This change makes the behavior of member functions and extension functions consistent, and it is enabled by default in Kotlin 2.1.0.</p></section><section class="chapter"><h3 id="improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes" data-toc="improved-exhaustiveness-checks-for-when-expressions-with-sealed-classes">Improved exhaustiveness checks for when expressions with sealed classes</h3><p id="-qc40jp_204">In previous versions of Kotlin, the compiler required an <code class="code" id="-qc40jp_207">else</code> branch in <code class="code" id="-qc40jp_208">when</code> expressions for type parameters with sealed upper bounds, even when all cases in the <code class="code" id="-qc40jp_209">sealed class</code> hierarchy were covered. This behavior is addressed and improved in Kotlin 2.1.0, making exhaustiveness checks more powerful and allowing you to remove redundant <code class="code" id="-qc40jp_210">else</code> branches, keeping <code class="code" id="-qc40jp_211">when</code> expressions cleaner and more intuitive.</p><p id="-qc40jp_205">Here's an example demonstrating the change:</p><div class="code-block" data-lang="kotlin">
sealed class Result
object Error: Result()
class Success(val value: String): Result()

fun &lt;T : Result&gt; render(result: T) = when (result) {
    Error -&gt; &quot;Error!&quot;
    is Success -&gt; result.value
    // Requires no else branch
}
</div></section></section><section class="chapter"><h2 id="kotlin-k2-compiler" data-toc="kotlin-k2-compiler">Kotlin K2 compiler</h2><p id="-qc40jp_212">With Kotlin 2.1.0, the K2 compiler now provides <a href="#extra-compiler-checks" id="-qc40jp_217">more flexibility when working with compiler checks</a> and <a href="#global-warning-suppression" id="-qc40jp_218">warnings</a>, as well as <a href="#improved-k2-kapt-implementation" id="-qc40jp_219">improved support for the kapt plugin</a>.</p><section class="chapter"><h3 id="extra-compiler-checks" data-toc="extra-compiler-checks">Extra compiler checks</h3><p id="-qc40jp_220">With Kotlin 2.1.0, you can now enable additional checks in the K2 compiler. These are extra declaration, expression, and type checks that are usually not crucial for compilation but can still be useful if you want to validate the following cases:</p><div class="table-wrapper"><table class="wide" id="-qc40jp_221"><thead><tr class="ijRowHead" id="-qc40jp_226"><th id="-qc40jp_242"><p>Check type</p></th><th id="-qc40jp_243"><p>Comment</p></th></tr></thead><tbody><tr id="-qc40jp_227"><td id="-qc40jp_244"><p><code class="code" id="-qc40jp_246">REDUNDANT_NULLABLE</code></p></td><td id="-qc40jp_245"><p><code class="code" id="-qc40jp_247">Boolean??</code> is used instead of <code class="code" id="-qc40jp_248">Boolean?</code></p></td></tr><tr id="-qc40jp_228"><td id="-qc40jp_249"><p><code class="code" id="-qc40jp_251">PLATFORM_CLASS_MAPPED_TO_KOTLIN</code></p></td><td id="-qc40jp_250"><p><code class="code" id="-qc40jp_252">java.lang.String</code> is used instead of <code class="code" id="-qc40jp_253">kotlin.String</code></p></td></tr><tr id="-qc40jp_229"><td id="-qc40jp_254"><p><code class="code" id="-qc40jp_256">ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_EQUALS</code></p></td><td id="-qc40jp_255"><p><code class="code" id="-qc40jp_257">arrayOf(&quot;&quot;) == arrayOf(&quot;&quot;)</code> is used instead of <code class="code" id="-qc40jp_258">arrayOf(&quot;&quot;).contentEquals(arrayOf(&quot;&quot;))</code></p></td></tr><tr id="-qc40jp_230"><td id="-qc40jp_259"><p><code class="code" id="-qc40jp_261">REDUNDANT_CALL_OF_CONVERSION_METHOD</code></p></td><td id="-qc40jp_260"><p><code class="code" id="-qc40jp_262">42.toInt()</code> is used instead of <code class="code" id="-qc40jp_263">42</code></p></td></tr><tr id="-qc40jp_231"><td id="-qc40jp_264"><p><code class="code" id="-qc40jp_266">USELESS_CALL_ON_NOT_NULL</code></p></td><td id="-qc40jp_265"><p><code class="code" id="-qc40jp_267">&quot;&quot;.orEmpty()</code> is used instead of <code class="code" id="-qc40jp_268">&quot;&quot;</code></p></td></tr><tr id="-qc40jp_232"><td id="-qc40jp_269"><p><code class="code" id="-qc40jp_271">REDUNDANT_SINGLE_EXPRESSION_STRING_TEMPLATE</code></p></td><td id="-qc40jp_270"><p><code class="code" id="-qc40jp_272">&quot;$string&quot;</code> is used instead of <code class="code" id="-qc40jp_273">string</code></p></td></tr><tr id="-qc40jp_233"><td id="-qc40jp_274"><p><code class="code" id="-qc40jp_276">UNUSED_ANONYMOUS_PARAMETER</code></p></td><td id="-qc40jp_275"><p>A parameter is passed in the lambda expression but never used</p></td></tr><tr id="-qc40jp_234"><td id="-qc40jp_277"><p><code class="code" id="-qc40jp_279">REDUNDANT_VISIBILITY_MODIFIER</code></p></td><td id="-qc40jp_278"><p><code class="code" id="-qc40jp_280">public class Klass</code> is used instead of <code class="code" id="-qc40jp_281">class Klass</code></p></td></tr><tr id="-qc40jp_235"><td id="-qc40jp_282"><p><code class="code" id="-qc40jp_284">REDUNDANT_MODALITY_MODIFIER</code></p></td><td id="-qc40jp_283"><p><code class="code" id="-qc40jp_285">final class Klass</code> is used instead of <code class="code" id="-qc40jp_286">class Klass</code></p></td></tr><tr id="-qc40jp_236"><td id="-qc40jp_287"><p><code class="code" id="-qc40jp_289">REDUNDANT_SETTER_PARAMETER_TYPE</code></p></td><td id="-qc40jp_288"><p><code class="code" id="-qc40jp_290">set(value: Int)</code> is used instead of <code class="code" id="-qc40jp_291">set(value)</code></p></td></tr><tr id="-qc40jp_237"><td id="-qc40jp_292"><p><code class="code" id="-qc40jp_294">CAN_BE_VAL</code></p></td><td id="-qc40jp_293"><p><code class="code" id="-qc40jp_295">var local = 0</code> is defined but never reassigned, can be <code class="code" id="-qc40jp_296">val local = 42</code> instead</p></td></tr><tr id="-qc40jp_238"><td id="-qc40jp_297"><p><code class="code" id="-qc40jp_299">ASSIGNED_VALUE_IS_NEVER_READ</code></p></td><td id="-qc40jp_298"><p><code class="code" id="-qc40jp_300">val local = 42</code> is defined but never used afterward in the code</p></td></tr><tr id="-qc40jp_239"><td id="-qc40jp_301"><p><code class="code" id="-qc40jp_303">UNUSED_VARIABLE</code></p></td><td id="-qc40jp_302"><p><code class="code" id="-qc40jp_304">val local = 0</code> is defined but never used in the code</p></td></tr><tr id="-qc40jp_240"><td id="-qc40jp_305"><p><code class="code" id="-qc40jp_307">REDUNDANT_RETURN_UNIT_TYPE</code></p></td><td id="-qc40jp_306"><p><code class="code" id="-qc40jp_308">fun foo(): Unit {}</code> is used instead of <code class="code" id="-qc40jp_309">fun foo() {}</code></p></td></tr><tr id="-qc40jp_241"><td id="-qc40jp_310"><p><code class="code" id="-qc40jp_312">UNREACHABLE_CODE</code></p></td><td id="-qc40jp_311"><p>Code statement is present but can never be executed</p></td></tr></tbody></table></div><p id="-qc40jp_222">If the check is true, you'll receive a compiler warning with a suggestion on how to fix the problem.</p><p id="-qc40jp_223">Extra checks are disabled by default. To enable them, use the <code class="code" id="-qc40jp_313">-Wextra</code> compiler option in the command line or specify <code class="code" id="-qc40jp_314">extraWarnings</code> in the <code class="code" id="-qc40jp_315">compilerOptions {}</code> block of your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        extraWarnings.set(true)
    }
}
</div><p id="-qc40jp_225">For more information on how to define and use compiler options, see <a href="gradle-compiler-options.html" id="-qc40jp_316">Compiler options in the Kotlin Gradle plugin</a>.</p></section><section class="chapter"><h3 id="global-warning-suppression" data-toc="global-warning-suppression">Global warning suppression</h3><p id="-qc40jp_317">In 2.1.0, the Kotlin compiler has received a highly requested feature &ndash; the ability to suppress warnings globally.</p><p id="-qc40jp_318">You can now suppress specific warnings in the whole project by using the <code class="code" id="-qc40jp_325">-Xsuppress-warning=WARNING_NAME</code> syntax in the command line or the <code class="code" id="-qc40jp_326">freeCompilerArgs</code> attribute in the <code class="code" id="-qc40jp_327">compilerOptions {}</code> block of your build file.</p><p id="-qc40jp_319">For example, if you have <a href="#extra-compiler-checks" id="-qc40jp_328">extra compiler checks</a> enabled in your project but want to suppress one of them, use:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        extraWarnings.set(true)
        freeCompilerArgs.add(&quot;-Xsuppress-warning=CAN_BE_VAL&quot;)
    }
}
</div><p id="-qc40jp_321">If you want to suppress a warning but don't know its name, select the element and click the light bulb icon (or use <kbd class="keystroke" id="-qc40jp_329" data-bypass="true"><span class="keystroke__value">Cmd + Enter</span></kbd>/<kbd class="keystroke" id="-qc40jp_330" data-bypass="true"><span class="keystroke__value">Alt + Enter</span></kbd>):</p><figure id="-qc40jp_322"><img alt="Warning name intention" src="images/warning-name-intention.png" title="Warning name intention" width="500" height="299"></figure><p id="-qc40jp_323">The new compiler option is currently <a href="components-stability.html#stability-levels-explained" id="-qc40jp_331">Experimental</a>. The following details are also worth noting:</p><ul class="list _bullet" id="-qc40jp_324"><li class="list__item" id="-qc40jp_332"><p id="-qc40jp_335">Error suppression is not allowed.</p></li><li class="list__item" id="-qc40jp_333"><p id="-qc40jp_336">If you pass an unknown warning name, compilation will result in an error.</p></li><li class="list__item" id="-qc40jp_334"><p id="-qc40jp_337">You can specify several warnings at once:</p><div class="tabs" id="-qc40jp_338" data-anchors="[-qc40jp_339,-qc40jp_340]"><div class="tabs__content" data-gtm="tab" id="-qc40jp_339" data-title="Command line"><div class="code-block" data-lang="bash" data-title="Bash">
kotlinc -Xsuppress-warning=NOTHING_TO_INLINE -Xsuppress-warning=NO_TAIL_CALLS_FOUND main.kt
</div></div><div class="tabs__content" data-gtm="tab" id="-qc40jp_340" data-title="Build file"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
// build.gradle.kts
kotlin {
    compilerOptions {
        freeCompilerArgs.addAll(
            listOf(
                &quot;-Xsuppress-warning=NOTHING_TO_INLINE&quot;,
                &quot;-Xsuppress-warning=NO_TAIL_CALLS_FOUND&quot;
            )
        )
    }
}
</div></div></div></li></ul></section><section class="chapter"><h3 id="improved-k2-kapt-implementation" data-toc="improved-k2-kapt-implementation">Improved K2 kapt implementation</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_343"><p id="-qc40jp_351">The kapt plugin for the K2 compiler (K2 kapt) is in <a href="components-stability.html#stability-levels-explained" id="-qc40jp_353">Alpha</a>. It may be changed at any time.</p><p id="-qc40jp_352">We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-71439/K2-kapt-feedback" id="-qc40jp_354" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_344">Currently, projects using the <a href="kapt.html" id="-qc40jp_355">kapt</a> plugin work with the K1 compiler by default, supporting Kotlin versions up to 1.9.</p><p id="-qc40jp_345">In Kotlin 1.9.20, we launched an experimental implementation of the kapt plugin with the K2 compiler (K2 kapt). We have now improved K2 kapt's internal implementation to mitigate technical and performance issues.</p><p id="-qc40jp_346">While the new K2 kapt implementation doesn't introduce new features, its performance has significantly improved compared to the previous K2 kapt implementation. Additionally, the K2 kapt plugin's behavior is now much closer to that of K1 kapt.</p><p id="-qc40jp_347">To use the new K2 kapt plugin implementation, enable it just like you did the previous K2 kapt plugin. Add the following option to the <code class="code" id="-qc40jp_356">gradle.properties</code> file of your project:</p><div class="code-block" data-lang="kotlin">
kapt.use.k2=true
</div><p id="-qc40jp_349">In upcoming releases, the K2 kapt implementation will be enabled by default instead of K1 kapt, so you will no longer need to enable it manually.</p><p id="-qc40jp_350">We highly appreciate your <a href="https://youtrack.jetbrains.com/issue/KT-71439/K2-kapt-feedback" id="-qc40jp_357" data-external="true" rel="noopener noreferrer" target="_blank">feedback</a> before the new implementation is stabilized.</p></section><section class="chapter"><h3 id="resolution-for-overload-conflicts-between-unsigned-and-non-primitive-types" data-toc="resolution-for-overload-conflicts-between-unsigned-and-non-primitive-types">Resolution for overload conflicts between unsigned and non-primitive types</h3><p id="-qc40jp_358">This release addresses the issue of resolution for overload conflicts that could occur in previous versions when functions were overloaded for unsigned and non-primitive types, as in the following examples:</p><section class="chapter"><h4 id="overloaded-extension-functions" data-toc="overloaded-extension-functions">Overloaded extension functions</h4><div class="code-block" data-lang="kotlin">
fun Any.doStuff() = &quot;Any&quot;
fun UByte.doStuff() = &quot;UByte&quot;

fun main() {
    val uByte: UByte = UByte.MIN_VALUE
    uByte.doStuff() // Overload resolution ambiguity before Kotlin 2.1.0
}
</div><p id="-qc40jp_362">In earlier versions, calling <code class="code" id="-qc40jp_363">uByte.doStuff()</code> led to ambiguity because both the <code class="code" id="-qc40jp_364">Any</code> and <code class="code" id="-qc40jp_365">UByte</code> extensions were applicable.</p></section><section class="chapter"><h4 id="overloaded-top-level-functions" data-toc="overloaded-top-level-functions">Overloaded top-level functions</h4><div class="code-block" data-lang="kotlin">
fun doStuff(value: Any) = &quot;Any&quot;
fun doStuff(value: UByte) = &quot;UByte&quot;

fun main() {
    val uByte: UByte = UByte.MIN_VALUE
    doStuff(uByte) // Overload resolution ambiguity before Kotlin 2.1.0
}
</div><p id="-qc40jp_367">Similarly, the call to <code class="code" id="-qc40jp_368">doStuff(uByte)</code> was ambiguous because the compiler couldn't decide whether to use the <code class="code" id="-qc40jp_369">Any</code> or <code class="code" id="-qc40jp_370">UByte</code> version. With 2.1.0, the compiler now handles these cases correctly, resolving the ambiguity by giving precedence to the more specific type, in this case <code class="code" id="-qc40jp_371">UByte</code>.</p></section></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="-qc40jp_372">Starting with version 2.1.0, the compiler can generate classes containing Java 23 bytecode.</p><section class="chapter"><h3 id="change-of-jspecify-nullability-mismatch-diagnostics-severity-to-strict" data-toc="change-of-jspecify-nullability-mismatch-diagnostics-severity-to-strict">Change of JSpecify nullability mismatch diagnostics severity to strict</h3><p id="-qc40jp_374">Kotlin 2.1.0 enforces strict handling of nullability annotations from <code class="code" id="-qc40jp_385">org.jspecify.annotations</code>, improving type safety for Java interoperability.</p><p id="-qc40jp_375">The following nullability annotations are affected:</p><ul class="list _bullet" id="-qc40jp_376"><li class="list__item" id="-qc40jp_386"><p id="-qc40jp_390"><code class="code" id="-qc40jp_391">org.jspecify.annotations.Nullable</code></p></li><li class="list__item" id="-qc40jp_387"><p id="-qc40jp_392"><code class="code" id="-qc40jp_393">org.jspecify.annotations.NonNull</code></p></li><li class="list__item" id="-qc40jp_388"><p id="-qc40jp_394"><code class="code" id="-qc40jp_395">org.jspecify.annotations.NullMarked</code></p></li><li class="list__item" id="-qc40jp_389"><p id="-qc40jp_396">Legacy annotations in <code class="code" id="-qc40jp_397">org.jspecify.nullness</code> (JSpecify 0.2 and earlier)</p></li></ul><p id="-qc40jp_377">Starting from Kotlin 2.1.0, nullability mismatches are raised from warnings to errors by default. This ensures that annotations like <code class="code" id="-qc40jp_398">@NonNull</code> and <code class="code" id="-qc40jp_399">@Nullable</code> are enforced during type checks, preventing unexpected nullability issues at runtime.</p><p id="-qc40jp_378">The <code class="code" id="-qc40jp_400">@NullMarked</code> annotation also affects the nullability of all members within its scope, making the behavior more predictable when you're working with annotated Java code.</p><p id="-qc40jp_379">Here's an example demonstrating the new default behavior:</p><div class="code-block" data-lang="java">
// Java
import org.jspecify.annotations.*;
public class SomeJavaClass {
    @NonNull
    public String foo() { //...
    }

    @Nullable
    public String bar() { //...
    }
}
</div><div class="code-block" data-lang="kotlin">
// Kotlin
fun test(sjc: SomeJavaClass) {
    // Accesses a non-null result, which is allowed
    sjc.foo().length

    // Raises an error in the default strict mode because the result is nullable
    // To avoid the error, use ?.length instead
    sjc.bar().length
}
</div><p id="-qc40jp_382">You can manually control the severity of diagnostics for these annotations. To do so, use the <code class="code" id="-qc40jp_401">-Xnullability-annotations</code> compiler option to choose a mode:</p><ul class="list _bullet" id="-qc40jp_383"><li class="list__item" id="-qc40jp_402"><p id="-qc40jp_405"><code class="code" id="-qc40jp_406">ignore</code>: Ignore nullability mismatches.</p></li><li class="list__item" id="-qc40jp_403"><p id="-qc40jp_407"><code class="code" id="-qc40jp_408">warning</code>: Report warnings for nullability mismatches.</p></li><li class="list__item" id="-qc40jp_404"><p id="-qc40jp_409"><code class="code" id="-qc40jp_410">strict</code>: Report errors for nullability mismatches (default mode).</p></li></ul><p id="-qc40jp_384">For more information, see <a href="java-interop.html#nullability-annotations" id="-qc40jp_411">Nullability annotations</a>.</p></section></section><section class="chapter"><h2 id="kotlin-multiplatform" data-toc="kotlin-multiplatform">Kotlin Multiplatform</h2><p id="-qc40jp_412">Kotlin 2.1.0 introduces <a href="#basic-support-for-swift-export" id="-qc40jp_420">basic support for Swift export</a> and makes <a href="#ability-to-publish-kotlin-libraries-from-any-host" id="-qc40jp_421">publishing Kotlin Multiplatform libraries easier</a>. It also focuses on improvements around Gradle that stabilize the <a href="#new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable" id="-qc40jp_422">new DSL for configuring compiler options</a> and bring a <a href="#preview-gradle-s-isolated-projects-in-kotlin-multiplatform" id="-qc40jp_423">preview of the Isolated Projects feature</a>.</p><section class="chapter"><h3 id="new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable" data-toc="new-gradle-dsl-for-compiler-options-in-multiplatform-projects-promoted-to-stable">New Gradle DSL for compiler options in multiplatform projects promoted to Stable</h3><p id="-qc40jp_424">In Kotlin 2.0.0, <a href="whatsnew20.html#new-gradle-dsl-for-compiler-options-in-multiplatform-projects" id="-qc40jp_428">we introduced a new Experimental Gradle DSL</a> to simplify the configuration of compiler options across your multiplatform projects. In Kotlin 2.1.0, this DSL has been promoted to Stable.</p><p id="-qc40jp_425">The overall project configuration now has three layers. The highest is the extension level, then the target level, and the lowest is the compilation unit (which is usually a compilation task):</p><figure id="-qc40jp_426"><img alt="Kotlin compiler options levels" src="images/compiler-options-levels.svg" title="Kotlin compiler options levels" width="700" height="440"></figure><p id="-qc40jp_427">To learn more about the different levels and how compiler options can be configured between them, see <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#compiler-options" id="-qc40jp_429" data-external="true" rel="noopener noreferrer" target="_blank">Compiler options</a>.</p></section><section class="chapter"><h3 id="preview-gradle-s-isolated-projects-in-kotlin-multiplatform" data-toc="preview-gradle-s-isolated-projects-in-kotlin-multiplatform">Preview Gradle's Isolated Projects in Kotlin Multiplatform</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_430"><p id="-qc40jp_435">This feature is <a href="components-stability.html#stability-levels-explained" id="-qc40jp_437">Experimental</a> and is currently in a pre-Alpha state in Gradle. Use it only with Gradle version 8.10 and solely for evaluation purposes. The feature may be dropped or changed at any time.</p><p id="-qc40jp_436">We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-57279/Support-Gradle-Project-Isolation-Feature-for-Kotlin-Multiplatform" id="-qc40jp_438" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>. Opt-in is required (see details below).</p></aside><p id="-qc40jp_431">In Kotlin 2.1.0, you can preview Gradle's <a href="https://docs.gradle.org/current/userguide/isolated_projects.html" id="-qc40jp_439" data-external="true" rel="noopener noreferrer" target="_blank">Isolated Projects</a> feature in your multiplatform projects.</p><p id="-qc40jp_432">The Isolated Projects feature in Gradle improves build performance by &quot;isolating&quot; configuration of individual Gradle projects from each other. Each project's build logic is restricted from directly accessing the mutable state of other projects, allowing them to safely run in parallel. To support this feature, we made some changes to the Kotlin Gradle plugin's model, and we are interested in hearing about your experiences during this preview phase.</p><p id="-qc40jp_433">There are two ways to enable the Kotlin Gradle plugin's new model:</p><ul class="list _bullet" id="-qc40jp_434"><li class="list__item" id="-qc40jp_440"><p id="-qc40jp_442">Option 1: <span class="control" id="-qc40jp_444">Testing compatibility without enabling Isolated Projects</span> &ndash; To check compatibility with the Kotlin Gradle plugin's new model without enabling the Isolated Projects feature, add the following Gradle property in the <code class="code" id="-qc40jp_445">gradle.properties</code> file of your project:</p><div class="code-block" data-lang="none">
# gradle.properties
kotlin.kmp.isolated-projects.support=enable
</div></li><li class="list__item" id="-qc40jp_441"><p id="-qc40jp_446">Option 2: <span class="control" id="-qc40jp_447">Testing with Isolated Projects enabled</span> &ndash; Enabling the Isolated Projects feature in Gradle automatically configures the Kotlin Gradle plugin to use the new model. To enable the Isolated Projects feature, <a href="https://docs.gradle.org/current/userguide/isolated_projects.html#how_do_i_use_it" id="-qc40jp_448" data-external="true" rel="noopener noreferrer" target="_blank">set the system property</a>. In this case, you don't need to add the Gradle property for the Kotlin Gradle plugin to your project.</p></li></ul></section><section class="chapter"><h3 id="basic-support-for-swift-export" data-toc="basic-support-for-swift-export">Basic support for Swift export</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_449"><p id="-qc40jp_459">This feature is currently in the early stages of development. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://kotl.in/issue" id="-qc40jp_460" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_450">Version 2.1.0 takes the first step towards providing support for Swift export in Kotlin, allowing you to export Kotlin sources directly to the Swift interface without using Objective-C headers. This should make multiplatform development for Apple targets easier.</p><p id="-qc40jp_451">The current basic support includes the ability to:</p><ul class="list _bullet" id="-qc40jp_452"><li class="list__item" id="-qc40jp_461"><p id="-qc40jp_464">Export multiple Gradle modules from Kotlin directly to Swift.</p></li><li class="list__item" id="-qc40jp_462"><p id="-qc40jp_465">Define custom Swift module names with the <code class="code" id="-qc40jp_466">moduleName</code> property.</p></li><li class="list__item" id="-qc40jp_463"><p id="-qc40jp_467">Set collapse rules for the package structure with the <code class="code" id="-qc40jp_468">flattenPackage</code> property.</p></li></ul><p id="-qc40jp_453">You can use the following build file in your project as a starting point for setting up Swift export:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts 
kotlin {

    iosX64()
    iosArm64()
    iosSimulatorArm64()

    @OptIn(ExperimentalSwiftExportDsl::class)
    swiftExport {
        // Root module name
        moduleName = &quot;Shared&quot;

        // Collapse rule
        // Removes package prefix from generated Swift code
        flattenPackage = &quot;com.example.sandbox&quot;

        // Export external modules
        export(project(&quot;:subproject&quot;)) {
            // Exported module name
            moduleName = &quot;Subproject&quot;
            // Collapse exported dependency rule
            flattenPackage = &quot;com.subproject.library&quot;
        }
    }
}
</div><p id="-qc40jp_455">You can also clone our <a href="https://github.com/Kotlin/swift-export-sample" id="-qc40jp_469" data-external="true" rel="noopener noreferrer" target="_blank">public sample</a> with Swift export already set up.</p><p id="-qc40jp_456">The compiler automatically generates all the necessary files (including <code class="code" id="-qc40jp_470">swiftmodule</code> files, static <code class="code" id="-qc40jp_471">a</code> library, and header and <code class="code" id="-qc40jp_472">modulemap</code> files) and copies them into the app's build directory, which you can access from Xcode.</p><section class="chapter"><h4 id="how-to-enable-swift-export" data-toc="how-to-enable-swift-export">How to enable Swift export</h4><p id="-qc40jp_473">Keep in mind that the feature is currently only in the early stages of development.</p><p id="-qc40jp_474">Swift export currently works in projects that use <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" id="-qc40jp_477" data-external="true" rel="noopener noreferrer" target="_blank">direct integration</a> to connect the iOS framework to the Xcode project. This is a standard configuration for Kotlin Multiplatform projects created in Android Studio or through the <a href="https://kmp.jetbrains.com/" id="-qc40jp_478" data-external="true" rel="noopener noreferrer" target="_blank">web wizard</a>.</p><p id="-qc40jp_475">To try out Swift export in your project:</p><ol class="list _decimal" id="-qc40jp_476" type="1"><li class="list__item" id="-qc40jp_479"><p id="-qc40jp_483">Add the following Gradle option to your <code class="code" id="-qc40jp_485">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
# gradle.properties
kotlin.experimental.swift-export.enabled=true
</div></li><li class="list__item" id="-qc40jp_480"><p id="-qc40jp_486">In Xcode, open the project settings.</p></li><li class="list__item" id="-qc40jp_481"><p id="-qc40jp_487">On the <span class="control" id="-qc40jp_488">Build Phases</span> tab, locate the <span class="control" id="-qc40jp_489">Run Script</span> phase with the <code class="code" id="-qc40jp_490">embedAndSignAppleFrameworkForXcode</code> task.</p></li><li class="list__item" id="-qc40jp_482"><p id="-qc40jp_491">Adjust the script to feature the <code class="code" id="-qc40jp_494">embedSwiftExportForXcode</code> task instead in the run script phase:</p><div class="code-block" data-lang="bash">
./gradlew :&lt;Shared module name&gt;:embedSwiftExportForXcode
</div><figure id="-qc40jp_493"><img alt="Add the Swift export script" src="images/xcode-swift-export-run-script-phase.png" title="Add the Swift export script" width="700" height="369"></figure></li></ol></section><section class="chapter"><h4 id="leave-feedback-on-swift-export" data-toc="leave-feedback-on-swift-export">Leave feedback on Swift export</h4><p id="-qc40jp_495">We're planning to expand and stabilize Swift export support in future Kotlin releases. Please leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-64572" id="-qc40jp_496" data-external="true" rel="noopener noreferrer" target="_blank">this YouTrack issue</a>.</p></section></section><section class="chapter"><h3 id="ability-to-publish-kotlin-libraries-from-any-host" data-toc="ability-to-publish-kotlin-libraries-from-any-host">Ability to publish Kotlin libraries from any host</h3><aside class="prompt" data-type="warning" data-title="" id="-qc40jp_497"><p id="-qc40jp_502">This feature is currently <a href="components-stability.html#stability-levels-explained" id="-qc40jp_503">Experimental</a>. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-71290" id="-qc40jp_504" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="-qc40jp_498">The Kotlin compiler produces <code class="code" id="-qc40jp_505">.klib</code> artifacts for publishing Kotlin libraries. Previously, you could get the necessary artifacts from any host, except for Apple platform targets that required a Mac machine. That put a special restraint on Kotlin Multiplatform projects that targeted iOS, macOS, tvOS, and watchOS targets.</p><p id="-qc40jp_499">Kotlin 2.1.0 lifts this restriction, adding support for cross-compilation. Now you can use any host to produce <code class="code" id="-qc40jp_506">.klib</code> artifacts, which should greatly simplify the publishing process for Kotlin and Kotlin Multiplatform libraries.</p><section class="chapter"><h4 id="how-to-enable-publishing-libraries-from-any-host" data-toc="how-to-enable-publishing-libraries-from-any-host">How to enable publishing libraries from any host</h4><p id="-qc40jp_507">To try cross-compilation out in your project, add the following binary option to your <code class="code" id="-qc40jp_511">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
# gradle.properties
kotlin.native.enableKlibsCrossCompilation=true
</div><p id="-qc40jp_509">This feature is currently Experimental and has some limitations. You still need to use a Mac machine if:</p><ul class="list _bullet" id="-qc40jp_510"><li class="list__item" id="-qc40jp_512"><p id="-qc40jp_515">Your library has a <a href="native-c-interop.html" id="-qc40jp_516">cinterop dependency</a>.</p></li><li class="list__item" id="-qc40jp_513"><p id="-qc40jp_517">You have <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" id="-qc40jp_518" data-external="true" rel="noopener noreferrer" target="_blank">CocoaPods integration</a> set up in your project.</p></li><li class="list__item" id="-qc40jp_514"><p id="-qc40jp_519">You need to build or test <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" id="-qc40jp_520" data-external="true" rel="noopener noreferrer" target="_blank">final binaries</a> for Apple targets.</p></li></ul></section><section class="chapter"><h4 id="leave-feedback-on-publishing-libraries-from-any-host" data-toc="leave-feedback-on-publishing-libraries-from-any-host">Leave feedback on publishing libraries from any host</h4><p id="-qc40jp_521">We're planning to stabilize this feature and further improve library publication in future Kotlin releases. Please leave your feedback in our issue tracker <a href="https://youtrack.jetbrains.com/issue/KT-71290" id="-qc40jp_523" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p><p id="-qc40jp_522">For more information, see <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" id="-qc40jp_524" data-external="true" rel="noopener noreferrer" target="_blank">Publishing multiplatform libraries</a>.</p></section></section><section class="chapter"><h3 id="support-for-non-packed-klibs" data-toc="support-for-non-packed-klibs">Support for non-packed klibs</h3><p id="-qc40jp_525">Kotlin 2.1.0 makes it possible to generate non-packed <code class="code" id="-qc40jp_529">.klib</code> file artifacts. This gives you the option to configure dependencies on klibs directly rather than unpack them first.</p><p id="-qc40jp_526">This change can also improve performance, decreasing compilation and linking time in your Kotlin/Wasm, Kotlin/JS, and Kotlin/Native projects.</p><p id="-qc40jp_527">For example, our benchmark shows a performance improvement of roughly 3% in total build time on the project with 1 linking and 10 compilation tasks (the project builds a single native executable binary that depends on 9 simplified projects). However, the actual impact on build time depends on both the number of subprojects and their respective sizes.</p><section class="chapter"><h4 id="how-to-set-up-your-project" data-toc="how-to-set-up-your-project">How to set up your project</h4><p id="-qc40jp_530">By default, Kotlin compilation and linking tasks are now configured to use the new non-packed artifacts.</p><p id="-qc40jp_531">If you have set up custom build logic for resolving klibs and want to use the new unpacked artifacts, you need to explicitly specify the preferred variant of klib package resolution in your Gradle build file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
import org.jetbrains.kotlin.gradle.plugin.attributes.KlibPackaging
// ...
val resolvableConfiguration = configurations.resolvable(&quot;resolvable&quot;) {

    // For the new non-packed configuration:
    attributes.attribute(KlibPackaging.ATTRIBUTE, project.objects.named(KlibPackaging.NON_PACKED))

    // For the previous packed configuration:
    attributes.attribute(KlibPackaging.ATTRIBUTE, project.objects.named(KlibPackaging.PACKED))
}
</div><p id="-qc40jp_533">Non-packed <code class="code" id="-qc40jp_537">.klib</code> files are generated at the same path in your project's build directory as the packed ones previously were. In turn, packed klibs are now located in the <code class="code" id="-qc40jp_538">build/libs</code> directory.</p><p id="-qc40jp_534">If no attribute is specified, the packed variant is used. You can check the list of available attributes and variants with the following console command:</p><div class="code-block" data-lang="bash">
./gradlew outgoingVariants
</div><p id="-qc40jp_536">We would appreciate your feedback on this feature in <a href="https://kotl.in/issue" id="-qc40jp_539" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section><section class="chapter"><h3 id="further-deprecation-of-old-android-target" data-toc="further-deprecation-of-old-android-target">Further deprecation of old <code class="code" id="-qc40jp_545">android</code> target</h3><p id="-qc40jp_541">In Kotlin 2.1.0, the deprecation warning for the old <code class="code" id="-qc40jp_546">android</code> target name has been raised to an error.</p><p id="-qc40jp_542">Currently, we recommend using the <code class="code" id="-qc40jp_547">androidTarget</code> option in your Kotlin Multiplatform projects targeting Android. This is a temporary solution that is necessary to free the <code class="code" id="-qc40jp_548">android</code> name for the upcoming Android/KMP plugin from Google.</p><p id="-qc40jp_543">We'll provide further migration instructions when the new plugin is available. The new DSL from Google will be the preferred option for Android target support in Kotlin Multiplatform.</p><p id="-qc40jp_544">For more information, see the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#rename-of-android-target-to-androidtarget" id="-qc40jp_549" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Multiplatform compatibility guide</a>.</p></section><section class="chapter"><h3 id="dropped-support-for-declaring-multiple-targets-of-the-same-type" data-toc="dropped-support-for-declaring-multiple-targets-of-the-same-type">Dropped support for declaring multiple targets of the same type</h3><p id="-qc40jp_550">Before Kotlin 2.1.0, you could declare multiple targets of the same type in your multiplatform projects. However, this made it challenging to distinguish between targets and to support shared source sets effectively. In most cases, a simpler setup, such as using separate Gradle projects, works better. For detailed guidance and an example of how to migrate, see <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-compatibility-guide.html#declaring-several-similar-targets" id="-qc40jp_552" data-external="true" rel="noopener noreferrer" target="_blank">Declaring several similar targets</a> in the Kotlin Multiplatform compatibility guide.</p><p id="-qc40jp_551">Kotlin 1.9.20 triggered a deprecation warning if you declared multiple targets of the same type in your multiplatform projects. In Kotlin 2.1.0, this deprecation warning is now an error for all targets except Kotlin/JS ones. To learn more about why Kotlin/JS targets are exempt, see this issue in <a href="https://youtrack.jetbrains.com/issue/KT-47038/KJS-MPP-Split-JS-target-into-JsBrowser-and-JsNode" id="-qc40jp_553" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="-qc40jp_554">Kotlin 2.1.0 includes an <a href="#iosarm64-promoted-to-tier-1" id="-qc40jp_559">upgrade for the <code class="code" id="-qc40jp_561">iosArm64</code> target support</a>, <a href="#changes-to-caching-in-cinterop" id="-qc40jp_560">improved cinterop caching process</a>, and other updates.</p><section class="chapter"><h3 id="iosarm64-promoted-to-tier-1" data-toc="iosarm64-promoted-to-tier-1">iosArm64 promoted to Tier 1</h3><p id="-qc40jp_562">The <code class="code" id="-qc40jp_565">iosArm64</code> target, which is crucial for <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" id="-qc40jp_566" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Multiplatform</a> development, has been promoted to Tier 1. This is the highest level of support in the Kotlin/Native compiler.</p><p id="-qc40jp_563">This means the target is regularly tested on the CI pipeline to ensure that it's able to compile and run. We also provide source and binary compatibility between compiler releases for the target.</p><p id="-qc40jp_564">For more information on target tiers, see <a href="native-target-support.html" id="-qc40jp_567">Kotlin/Native target support</a>.</p></section><section class="chapter"><h3 id="llvm-update-from-11-1-0-to-16-0-0" data-toc="llvm-update-from-11-1-0-to-16-0-0">LLVM update from 11.1.0 to 16.0.0</h3><p id="-qc40jp_568">In Kotlin 2.1.0, we updated LLVM from version 11.1.0 to 16.0.0. The new version includes bug fixes and security updates. In certain cases, it also provides compiler optimizations and faster compilation.</p><p id="-qc40jp_569">If you have Linux targets in your project, take note that the Kotlin/Native compiler now uses the <code class="code" id="-qc40jp_571">lld</code> linker by default for all Linux targets.</p><p id="-qc40jp_570">This update shouldn't affect your code, but if you encounter any issues, please report them to our <a href="http://kotl.in/issue" id="-qc40jp_572" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>.</p></section><section class="chapter"><h3 id="changes-to-caching-in-cinterop" data-toc="changes-to-caching-in-cinterop">Changes to caching in cinterop</h3><p id="-qc40jp_573">In Kotlin 2.1.0, we're making changes to the cinterop caching process. It no longer has the <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/CacheableTask.html" id="-qc40jp_575" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-qc40jp_577">CacheableTask</code></a> annotation type. The new recommended approach is to use the <a href="https://docs.gradle.org/current/kotlin-dsl/gradle/org.gradle.api.tasks/-task-outputs/cache-if.html" id="-qc40jp_576" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-qc40jp_578">cacheIf</code></a> output type to cache the results of the task.</p><p id="-qc40jp_574">This should resolve issues where <code class="code" id="-qc40jp_579">UP-TO-DATE</code> checks failed to detect changes to header files specified in the <a href="native-definition-file.html" id="-qc40jp_580">definition file</a>, preventing the build system from recompiling the code.</p></section><section class="chapter"><h3 id="deprecation-of-the-mimalloc-memory-allocator" data-toc="deprecation-of-the-mimalloc-memory-allocator">Deprecation of the mimalloc memory allocator</h3><p id="-qc40jp_581">Back in Kotlin 1.9.0, we introduced the new memory allocator, and then we enabled it by default in Kotlin 1.9.20. The new allocator has been designed to make garbage collection more efficient and improve the Kotlin/Native memory manager's runtime performance.</p><p id="-qc40jp_582">The new memory allocator replaced the previous default allocator, <a href="https://github.com/microsoft/mimalloc" id="-qc40jp_585" data-external="true" rel="noopener noreferrer" target="_blank">mimalloc</a>. Now, it's time to deprecate mimalloc in the Kotlin/Native compiler.</p><p id="-qc40jp_583">You can now remove the <code class="code" id="-qc40jp_586">-Xallocator=mimalloc</code> compiler option from your build scripts. If you encounter any issues, please report them to our <a href="http://kotl.in/issue" id="-qc40jp_587" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>.</p><p id="-qc40jp_584">For more information on the memory allocator and garbage collection in Kotlin, see <a href="native-memory-manager.html" id="-qc40jp_588">Kotlin/Native memory management</a>.</p></section></section><section class="chapter"><h2 id="kotlin-wasm" data-toc="kotlin-wasm">Kotlin/Wasm</h2><p id="-qc40jp_589">Kotlin/Wasm received multiple updates along with <a href="#support-for-incremental-compilation" id="-qc40jp_598">support for incremental compilation</a>.</p><section class="chapter"><h3 id="support-for-incremental-compilation" data-toc="support-for-incremental-compilation">Support for incremental compilation</h3><p id="-qc40jp_599">Previously, when you changed something in your Kotlin code, the Kotlin/Wasm toolchain had to recompile the entire codebase.</p><p id="-qc40jp_600">Starting from 2.1.0, incremental compilation is supported for Wasm targets. In development tasks, the compiler now recompiles only files relevant to changes from the last compilation, which noticeably reduces the compilation time.</p><p id="-qc40jp_601">This change currently doubles the compilation speed, and there are plans to improve it further in future releases.</p><p id="-qc40jp_602">In the current setup, incremental compilation for Wasm targets is disabled by default. To enable incremental compilation, add the following line to your project's <code class="code" id="-qc40jp_605">local.properties</code> or <code class="code" id="-qc40jp_606">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
# gradle.properties
kotlin.incremental.wasm=true
</div><p id="-qc40jp_604">Try out Kotlin/Wasm incremental compilation and <a href="https://youtrack.jetbrains.com/issue/KT-72158/Kotlin-Wasm-incremental-compilation-feedback" id="-qc40jp_607" data-external="true" rel="noopener noreferrer" target="_blank">share your feedback</a>. Your insights will help make this feature Stable and enabled by default sooner.</p></section><section class="chapter"><h3 id="browser-apis-moved-to-the-kotlinx-browser-stand-alone-library" data-toc="browser-apis-moved-to-the-kotlinx-browser-stand-alone-library">Browser APIs moved to the kotlinx-browser stand-alone library</h3><p id="-qc40jp_608">Previously, the declarations for web APIs and related target utilities were part of the Kotlin/Wasm standard library.</p><p id="-qc40jp_609">In this release, the <code class="code" id="-qc40jp_613">org.w3c.*</code> declarations have been moved from the Kotlin/Wasm standard library to the new <a href="https://github.com/kotlin/kotlinx-browser" id="-qc40jp_614" data-external="true" rel="noopener noreferrer" target="_blank">kotlinx-browser library</a>. This library also includes other web-related packages, such as <code class="code" id="-qc40jp_615">org.khronos.webgl</code>, <code class="code" id="-qc40jp_616">kotlin.dom</code>, and <code class="code" id="-qc40jp_617">kotlinx.browser</code>.</p><p id="-qc40jp_610">This separation provides modularity, enabling independent updates for web-related APIs outside of Kotlin's release cycle. Additionally, the Kotlin/Wasm standard library now contains only declarations available in any JavaScript environment.</p><p id="-qc40jp_611">To use the declarations from the moved packages, you need to add the <code class="code" id="-qc40jp_618">kotlinx-browser</code> dependency to your project's build configuration file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
val wasmJsMain by getting {
    dependencies {
        implementation(&quot;org.jetbrains.kotlinx:kotlinx-browser:0.3&quot;)
    }
}
</div></section><section class="chapter"><h3 id="improved-debugging-experience-for-kotlin-wasm" data-toc="improved-debugging-experience-for-kotlin-wasm">Improved debugging experience for Kotlin/Wasm</h3><p id="-qc40jp_619">Previously, when debugging Kotlin/Wasm code in web browsers, you might have encountered a low-level representation of variable values in the debugging interface. This often made it challenging to track the current state of the application.</p><figure id="-qc40jp_620"><img alt="Kotlin/Wasm old debugger" src="images/wasm-old-debugger.png" title="Kotlin/Wasm old debugger" width="700" height="445"></figure><p id="-qc40jp_621">To improve this experience, custom formatters have been added in the variable view. The implementation uses the <a href="https://firefox-source-docs.mozilla.org/devtools-user/custom_formatters/index.html" id="-qc40jp_626" data-external="true" rel="noopener noreferrer" target="_blank">custom formatters API</a>, which is supported across major browsers like Firefox and Chromium-based ones.</p><p id="-qc40jp_622">With this change, you can now display and locate variable values in a more user-friendly and comprehensible manner.</p><figure id="-qc40jp_623"><img alt="Kotlin/Wasm improved debugger" src="images/wasm-debugger-improved.png" title="Kotlin/Wasm improved debugger" width="700" height="495"></figure><p id="-qc40jp_624">To try the new debugging experience:</p><ol class="list _decimal" id="-qc40jp_625" type="1"><li class="list__item" id="-qc40jp_627"><p id="-qc40jp_629">Add the following compiler option to the <code class="code" id="-qc40jp_631">wasmJs {}</code> compiler options:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    wasmJs {
        // ...

        compilerOptions {
            freeCompilerArgs.add(&quot;-Xwasm-debugger-custom-formatters&quot;)
        }
    }
}
</div></li><li class="list__item" id="-qc40jp_628"><p id="-qc40jp_632">Enable custom formatters in your browser:</p><ul class="list _bullet" id="-qc40jp_633"><li class="list__item" id="-qc40jp_634"><p id="-qc40jp_636">In Chrome DevTools, it's available via <span class="control" id="-qc40jp_638">Settings | Preferences | Console</span>:</p><figure id="-qc40jp_637"><img alt="Enable custom formatters in Chrome" src="images/wasm-custom-formatters-chrome.png" title="Enable custom formatters in Chrome" width="700" height="718"></figure></li><li class="list__item" id="-qc40jp_635"><p id="-qc40jp_639">In Firefox DevTools, it's available via <span class="control" id="-qc40jp_641">Settings | Advanced settings</span>:</p><figure id="-qc40jp_640"><img alt="Enable custom formatters in Firefox" src="images/wasm-custom-formatters-firefox.png" title="Enable custom formatters in Firefox" width="700" height="541"></figure></li></ul></li></ol></section><section class="chapter"><h3 id="reduced-size-of-kotlin-wasm-binaries" data-toc="reduced-size-of-kotlin-wasm-binaries">Reduced size of Kotlin/Wasm binaries</h3><p id="-qc40jp_642">The size of your Wasm binaries produced by production builds will be reduced by up to 30%, and you may see some performance improvements. This is because the <code class="code" id="-qc40jp_643">--closed-world</code>, <code class="code" id="-qc40jp_644">--type-ssa</code>, and <code class="code" id="-qc40jp_645">--type-merging</code> Binaryen options are now considered safe to use for all Kotlin/Wasm projects and are enabled by default.</p></section><section class="chapter"><h3 id="improved-javascript-array-interoperability-in-kotlin-wasm" data-toc="improved-javascript-array-interoperability-in-kotlin-wasm">Improved JavaScript array interoperability in Kotlin/Wasm</h3><p id="-qc40jp_646">While Kotlin/Wasm's standard library provides the <code class="code" id="-qc40jp_654">JsArray&lt;T&gt;</code> type for JavaScript arrays, there was no direct method to transform <code class="code" id="-qc40jp_655">JsArray&lt;T&gt;</code> into Kotlin's native <code class="code" id="-qc40jp_656">Array</code> or <code class="code" id="-qc40jp_657">List</code> types.</p><p id="-qc40jp_647">This gap required creating custom functions for array transformations, complicating interoperability between Kotlin and JavaScript code.</p><p id="-qc40jp_648">This release introduces an adapter function that automatically converts <code class="code" id="-qc40jp_658">JsArray&lt;T&gt;</code> to <code class="code" id="-qc40jp_659">Array&lt;T&gt;</code> and vice versa, simplifying array operations.</p><p id="-qc40jp_649">Here's an example of conversion between generic types: Kotlin <code class="code" id="-qc40jp_660">List&lt;T&gt;</code> and <code class="code" id="-qc40jp_661">Array&lt;T&gt;</code> to JavaScript <code class="code" id="-qc40jp_662">JsArray&lt;T&gt;</code>.</p><div class="code-block" data-lang="kotlin">
val list: List&lt;JsString&gt; =
    listOf(&quot;Kotlin&quot;, &quot;Wasm&quot;).map { it.toJsString() }

// Uses .toJsArray() to convert List or Array to JsArray
val jsArray: JsArray&lt;JsString&gt; = list.toJsArray()

// Uses .toArray() and .toList() to convert it back to Kotlin types 
val kotlinArray: Array&lt;JsString&gt; = jsArray.toArray()
val kotlinList: List&lt;JsString&gt; = jsArray.toList()
</div><p id="-qc40jp_651">Similar methods are available for converting typed arrays to their Kotlin equivalents (for example, <code class="code" id="-qc40jp_663">IntArray</code> and <code class="code" id="-qc40jp_664">Int32Array</code>). For detailed information and implementation, see the <a href="https://github.com/Kotlin/kotlinx-browser/blob/dfbdceed314567983c98f1d66e8c2e10d99c5a55/src/wasmJsMain/kotlin/arrayCopy.kt" id="-qc40jp_665" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-qc40jp_666">kotlinx-browser</code> repository</a>.</p><p id="-qc40jp_652">Here's an example of conversion between typed arrays: Kotlin <code class="code" id="-qc40jp_667">IntArray</code> to JavaScript <code class="code" id="-qc40jp_668">Int32Array</code>.</p><div class="code-block" data-lang="kotlin">
import org.khronos.webgl.*

    // ...

    val intArray: IntArray = intArrayOf(1, 2, 3)
    
    // Uses .toInt32Array() to convert Kotlin IntArray to JavaScript Int32Array
    val jsInt32Array: Int32Array = intArray.toInt32Array()
    
    // Uses toIntArray() to convert JavaScript Int32Array back to Kotlin IntArray
    val kotlinIntArray: IntArray = jsInt32Array.toIntArray()
</div></section><section class="chapter"><h3 id="support-for-accessing-javascript-exception-details-in-kotlin-wasm" data-toc="support-for-accessing-javascript-exception-details-in-kotlin-wasm">Support for accessing JavaScript exception details in Kotlin/Wasm</h3><p id="-qc40jp_669">Previously, when a JavaScript exception occurred in Kotlin/Wasm, the <code class="code" id="-qc40jp_678">JsException</code> type provided only a generic message without details from the original JavaScript error.</p><p id="-qc40jp_670">Starting from Kotlin 2.1.0, you can configure <code class="code" id="-qc40jp_679">JsException</code> to include the original error message and stack trace by enabling a specific compiler option. This provides more context to help diagnose issues originating from JavaScript.</p><p id="-qc40jp_671">This behavior depends on the <code class="code" id="-qc40jp_680">WebAssembly.JSTag</code> API, which is available only in certain browsers:</p><ul class="list _bullet" id="-qc40jp_672"><li class="list__item" id="-qc40jp_681"><p id="-qc40jp_684"><span class="control" id="-qc40jp_685">Chrome</span>: Supported from version 115</p></li><li class="list__item" id="-qc40jp_682"><p id="-qc40jp_686"><span class="control" id="-qc40jp_687">Firefox</span>: Supported from version 129</p></li><li class="list__item" id="-qc40jp_683"><p id="-qc40jp_688"><span class="control" id="-qc40jp_689">Safari</span>: Not yet supported</p></li></ul><p id="-qc40jp_673">To enable this feature, which is disabled by default, add the following compiler option to your <code class="code" id="-qc40jp_690">build.gradle.kts</code> file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    wasmJs {
        compilerOptions {
            freeCompilerArgs.add(&quot;-Xwasm-attach-js-exception&quot;)
        }
    }
}
</div><p id="-qc40jp_675">Here's an example demonstrating the new behavior:</p><div class="code-block" data-lang="kotlin">
external object JSON {
    fun &lt;T: JsAny&gt; parse(json: String): T
}

fun main() {
    try {
        JSON.parse(&quot;an invalid JSON&quot;)
    } catch (e: JsException) {
        println(&quot;Thrown value is: ${e.thrownValue}&quot;)
        // SyntaxError: Unexpected token 'a', &quot;an invalid JSON&quot; is not valid JSON

        println(&quot;Message: ${e.message}&quot;)
        // Message: Unexpected token 'a', &quot;an invalid JSON&quot; is not valid JSON

        println(&quot;Stacktrace:&quot;)
        // Stacktrace:

        // Prints the full JavaScript stack trace 
        e.printStackTrace()
    }
}
</div><p id="-qc40jp_677">With the <code class="code" id="-qc40jp_691">-Xwasm-attach-js-exception</code> option enabled, <code class="code" id="-qc40jp_692">JsException</code> provides specific details from the JavaScript error. Without the option, <code class="code" id="-qc40jp_693">JsException</code> includes only a generic message stating that an exception was thrown while running JavaScript code.</p></section><section class="chapter"><h3 id="deprecation-of-default-exports" data-toc="deprecation-of-default-exports">Deprecation of default exports</h3><p id="-qc40jp_694">As part of the migration to named exports, an error was previously printed to the console when a default import was used for Kotlin/Wasm exports in JavaScript.</p><p id="-qc40jp_695">In 2.1.0, default imports have been completely removed to fully support named exports.</p><p id="-qc40jp_696">When coding in JavaScript for the Kotlin/Wasm target, you now need to use the corresponding named imports instead of default imports.</p><p id="-qc40jp_697">This change marks the last phase of a deprecation cycle to migrate to named exports:</p><p id="-qc40jp_698"><span class="control" id="-qc40jp_701">In version 2.0.0:</span> A warning message was printed to the console, explaining that exporting entities via default exports is deprecated.</p><p id="-qc40jp_699"><span class="control" id="-qc40jp_702">In version 2.0.20:</span> An error occurred, requesting the use of the corresponding named import.</p><p id="-qc40jp_700"><span class="control" id="-qc40jp_703">In version 2.1.0:</span> The use of default imports has been completely removed.</p></section><section class="chapter"><h3 id="subproject-specific-node-js-settings" data-toc="subproject-specific-node-js-settings">Subproject-specific Node.js settings</h3><p id="-qc40jp_704">You can configure Node.js settings for your project by defining properties of the <code class="code" id="-qc40jp_709">NodeJsRootPlugin</code> class for <code class="code" id="-qc40jp_710">rootProject</code>. In 2.1.0, you can configure these settings for each subproject using a new class, <code class="code" id="-qc40jp_711">NodeJsPlugin</code>. Here's an example demonstrating how to set a specific Node.js version for a subproject:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
project.plugins.withType&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsPlugin&gt; {
    project.the&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsEnvSpec&gt;().version = &quot;22.0.0&quot;
}
</div><p id="-qc40jp_706">To use the new class for the entire project, add the same code in the <code class="code" id="-qc40jp_712">allprojects {}</code> block:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
allprojects {
    project.plugins.withType&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsPlugin&gt; {
        project.the&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsEnvSpec&gt;().version = &quot;your Node.js version&quot;
    }
}
</div><p id="-qc40jp_708">You can also use Gradle convention plugins to apply the settings to a particular set of subprojects.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><section class="chapter"><h3 id="support-for-non-identifier-characters-in-properties" data-toc="support-for-non-identifier-characters-in-properties">Support for non-identifier characters in properties</h3><p id="-qc40jp_715">Kotlin/JS previously did not allow using <a href="coding-conventions.html#names-for-test-methods" id="-qc40jp_722">names for test methods</a> with spaces enclosed in backticks.</p><p id="-qc40jp_716">Similarly, it was not possible to access JavaScript object properties that contained characters not permitted in Kotlin identifiers, such as hyphens or spaces:</p><div class="code-block" data-lang="kotlin">
external interface Headers {
    var accept: String?

    // Invalid Kotlin identifier due to hyphen
    var `content-length`: String?
}

val headers: Headers = TODO(&quot;value provided by a JS library&quot;)
val accept = headers.accept
// Causes error due to the hyphen in property name
val length = headers.`content-length`
</div><p id="-qc40jp_718">This behavior differed from JavaScript and TypeScript, which allow such properties to be accessed using non-identifier characters.</p><p id="-qc40jp_719">Starting from Kotlin 2.1.0, this feature is enabled by default. Kotlin/JS now allows you to use the backticks (``) and the <code class="code" id="-qc40jp_723">@JsName</code> annotation to interact with JavaScript properties containing non-identifier characters and to use names for test methods.</p><p id="-qc40jp_720">Additionally, you can use the <code class="code" id="-qc40jp_724">@JsName</code> and <code class="code" id="-qc40jp_725">@JsQualifier</code> annotations to map Kotlin property names to JavaScript equivalents:</p><div class="code-block" data-lang="kotlin">
object Bar {
    val `property example`: String = &quot;bar&quot;
}

@JsQualifier(&quot;fooNamespace&quot;)
external object Foo {
    val `property example`: String
}

@JsExport
object Baz {
    val `property example`: String = &quot;bar&quot;
}

fun main() {
    // In JavaScript, this is compiled into Bar.property_example_HASH
    println(Bar.`property example`)
    // In JavaScript, this is compiled into fooNamespace[&quot;property example&quot;]
    println(Foo.`property example`)
    // In JavaScript, this is compiled into Baz[&quot;property example&quot;]
    println(Baz.`property example`)
}
</div></section><section class="chapter"><h3 id="support-for-generating-es2015-arrow-functions" data-toc="support-for-generating-es2015-arrow-functions">Support for generating ES2015 arrow functions</h3><p id="-qc40jp_726">In Kotlin 2.1.0, Kotlin/JS introduces support for generating ES2015 arrow functions, such as <code class="code" id="-qc40jp_730">(a, b) =&gt; expression</code>, instead of anonymous functions.</p><p id="-qc40jp_727">Using arrow functions can reduce the bundle size of your project, especially when using the experimental <code class="code" id="-qc40jp_731">-Xir-generate-inline-anonymous-functions</code> mode. This also makes the generated code more aligned with modern JS.</p><p id="-qc40jp_728">This feature is enabled by default when targeting ES2015. Alternatively, you can enable it by using the <code class="code" id="-qc40jp_732">-Xes-arrow-functions</code> command line argument.</p><p id="-qc40jp_729">Learn more about <a href="https://262.ecma-international.org/6.0/" id="-qc40jp_733" data-external="true" rel="noopener noreferrer" target="_blank">ES2015 (ECMAScript 2015, ES6) in the official documentation</a>.</p></section></section><section class="chapter"><h2 id="gradle-improvements" data-toc="gradle-improvements">Gradle improvements</h2><p id="-qc40jp_734">Kotlin 2.1.0 is fully compatible with Gradle 7.6.3 through 8.6. Gradle versions 8.7 to 8.10 are also supported, with only one exception. If you use the Kotlin Multiplatform Gradle plugin, you may see deprecation warnings in your multiplatform projects calling the <code class="code" id="-qc40jp_741">withJava()</code> function in the JVM target. We plan to fix this issue as soon as possible.</p><p id="-qc40jp_735">For more information, see the related issue in <a href="https://youtrack.jetbrains.com/issue/KT-66542" id="-qc40jp_742" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p><p id="-qc40jp_736">You can also use Gradle versions up to the latest Gradle release, but if you do, keep in mind that you might encounter deprecation warnings or some new Gradle features might not work.</p><section class="chapter"><h3 id="minimum-supported-agp-version-bumped-to-7-3-1" data-toc="minimum-supported-agp-version-bumped-to-7-3-1">Minimum supported AGP version bumped to 7.3.1</h3><p id="-qc40jp_743">Starting with Kotlin 2.1.0, the minimum supported Android Gradle plugin version is 7.3.1.</p></section><section class="chapter"><h3 id="minimum-supported-gradle-version-bumped-to-7-6-3" data-toc="minimum-supported-gradle-version-bumped-to-7-6-3">Minimum supported Gradle version bumped to 7.6.3</h3><p id="-qc40jp_744">Starting with Kotlin 2.1.0, the minimum supported Gradle version is 7.6.3.</p></section><section class="chapter"><h3 id="new-api-for-kotlin-gradle-plugin-extensions" data-toc="new-api-for-kotlin-gradle-plugin-extensions">New API for Kotlin Gradle plugin extensions</h3><p id="-qc40jp_745">Kotlin 2.1.0 introduces a new API to make it easier to create your own plugins for configuring the Kotlin Gradle plugin. This change deprecates the <code class="code" id="-qc40jp_754">KotlinTopLevelExtension</code> and <code class="code" id="-qc40jp_755">KotlinTopLevelExtensionConfig</code> interfaces and introduces the following interfaces for plugin authors:</p><div class="table-wrapper"><table class="wide" id="-qc40jp_746"><thead><tr class="ijRowHead" id="-qc40jp_756"><th id="-qc40jp_760"><p>Name</p></th><th id="-qc40jp_761"><p>Description</p></th></tr></thead><tbody><tr id="-qc40jp_757"><td id="-qc40jp_762"><p><code class="code" id="-qc40jp_764">KotlinBaseExtension</code></p></td><td id="-qc40jp_763"><p>A plugin DSL extension type for configuring common Kotlin JVM, Android, and Multiplatform plugin options for the entire project: </p><ul class="list _bullet" id="-qc40jp_765"><li class="list__item" id="-qc40jp_766"><p><code class="code" id="-qc40jp_769">org.jetbrains.kotlin.jvm</code></p></li><li class="list__item" id="-qc40jp_767"><p><code class="code" id="-qc40jp_770">org.jetbrains.kotlin.android</code></p></li><li class="list__item" id="-qc40jp_768"><p><code class="code" id="-qc40jp_771">org.jetbrains.kotlin.multiplatform</code></p></li></ul></td></tr><tr id="-qc40jp_758"><td id="-qc40jp_772"><p><code class="code" id="-qc40jp_774">KotlinJvmExtension</code></p></td><td id="-qc40jp_773"><p>A plugin DSL extension type for configuring Kotlin <span class="control" id="-qc40jp_775">JVM</span> plugin options for the entire project.</p></td></tr><tr id="-qc40jp_759"><td id="-qc40jp_776"><p><code class="code" id="-qc40jp_778">KotlinAndroidExtension</code></p></td><td id="-qc40jp_777"><p>A plugin DSL extension type for configuring Kotlin <span class="control" id="-qc40jp_779">Android</span> plugin options for the entire project.</p></td></tr></tbody></table></div><p id="-qc40jp_747">For example, if you want to configure compiler options for both JVM and Android projects, use <code class="code" id="-qc40jp_780">KotlinBaseExtension</code>:</p><div class="code-block" data-lang="kotlin">
configure&lt;KotlinBaseExtension&gt; {
    if (this is HasConfigurableKotlinCompilerOptions&lt;*&gt;) {
        with(compilerOptions) {
            if (this is KotlinJvmCompilerOptions) {
                jvmTarget.set(JvmTarget.JVM_17)
            }
        }
    }
}
</div><p id="-qc40jp_749">This configures the JVM target to 17 for both JVM and Android projects.</p><p id="-qc40jp_750">To configure compiler options specifically for JVM projects, use <code class="code" id="-qc40jp_781">KotlinJvmExtension</code>:</p><div class="code-block" data-lang="kotlin">
configure&lt;KotlinJvmExtension&gt; {
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_17)
    }

    target.mavenPublication {
        groupId = &quot;com.example&quot;
        artifactId = &quot;example-project&quot;
        version = &quot;1.0-SNAPSHOT&quot;
    }
}
</div><p id="-qc40jp_752">This example similarly configures the JVM target to 17 for JVM projects. It also configures a Maven publication for the project so that its output is published to a Maven repository.</p><p id="-qc40jp_753">You can use the <code class="code" id="-qc40jp_782">KotlinAndroidExtension</code> in exactly the same way.</p></section><section class="chapter"><h3 id="compiler-symbols-hidden-from-the-kotlin-gradle-plugin-api" data-toc="compiler-symbols-hidden-from-the-kotlin-gradle-plugin-api">Compiler symbols hidden from the Kotlin Gradle plugin API</h3><p id="-qc40jp_783">Previously, KGP included <code class="code" id="-qc40jp_789">org.jetbrains.kotlin:kotlin-compiler-embeddable</code> in its runtime dependencies, making internal compiler symbols available in the build script classpath. These symbols were intended for internal use only.</p><p id="-qc40jp_784">Starting with Kotlin 2.1.0, KGP bundles a subset of <code class="code" id="-qc40jp_790">org.jetbrains.kotlin:kotlin-compiler-embeddable</code> class files in its JAR file and progressively removes them. This change aims to prevent compatibility issues and simplify KGP maintenance.</p><p id="-qc40jp_785">If other parts of your build logic, such as plugins like <code class="code" id="-qc40jp_791">kotlinter</code>, depend on a different version of <code class="code" id="-qc40jp_792">org.jetbrains.kotlin:kotlin-compiler-embeddable</code> than the one bundled with KGP, it can lead to conflicts and runtime exceptions.</p><p id="-qc40jp_786">To prevent such issues, KGP now shows a warning if <code class="code" id="-qc40jp_793">org.jetbrains.kotlin:kotlin-compiler-embeddable</code> is present in the build classpath alongside KGP.</p><p id="-qc40jp_787">As a long-term solution, if you're a plugin author using <code class="code" id="-qc40jp_794">org.jetbrains.kotlin:kotlin-compiler-embeddable</code> classes, we recommend running them in an isolated classloader. For example, you can achieve it using the <a href="https://docs.gradle.org/current/userguide/worker_api.html" id="-qc40jp_795" data-external="true" rel="noopener noreferrer" target="_blank">Gradle Workers API</a> with classloader or process isolation.</p><section class="chapter"><h4 id="using-the-gradle-workers-api" data-toc="using-the-gradle-workers-api">Using the Gradle Workers API</h4><p id="-qc40jp_796">This example demonstrates how to safely use the Kotlin compiler in a project producing a Gradle plugin. First, add a compile-only dependency in your build script. This makes the symbol available at compile time only:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
dependencies {
    compileOnly(&quot;org.jetbrains.kotlin:kotlin-compiler-embeddable:2.2.0&quot;)
}
</div><p id="-qc40jp_798">Next, define a Gradle work action to print the Kotlin compiler version:</p><div class="code-block" data-lang="kotlin">
import org.gradle.workers.WorkAction
import org.gradle.workers.WorkParameters
import org.jetbrains.kotlin.config.KotlinCompilerVersion
abstract class ActionUsingKotlinCompiler : WorkAction&lt;WorkParameters.None&gt; {
    override fun execute() {
        println(&quot;Kotlin compiler version: ${KotlinCompilerVersion.getVersion()}&quot;)
    }
}
</div><p id="-qc40jp_800">Now create a task that submits this action to the worker executor using classloader isolation:</p><div class="code-block" data-lang="kotlin">
import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.tasks.Classpath
import org.gradle.api.tasks.TaskAction
import org.gradle.workers.WorkerExecutor
import javax.inject.Inject
abstract class TaskUsingKotlinCompiler: DefaultTask() {
    @get:Inject
    abstract val executor: WorkerExecutor

    @get:Classpath
    abstract val kotlinCompiler: ConfigurableFileCollection

    @TaskAction
    fun compile() {
        val workQueue = executor.classLoaderIsolation {
            classpath.from(kotlinCompiler)
        }
        workQueue.submit(ActionUsingKotlinCompiler::class.java) {}
    }
}
</div><p id="-qc40jp_802">Finally, configure the Kotlin compiler classpath in your Gradle plugin:</p><div class="code-block" data-lang="kotlin">
import org.gradle.api.Plugin
import org.gradle.api.Project
abstract class MyPlugin: Plugin&lt;Project&gt; {
    override fun apply(target: Project) {
        val myDependencyScope = target.configurations.create(&quot;myDependencyScope&quot;)
        target.dependencies.add(myDependencyScope.name, &quot;$KOTLIN_COMPILER_EMBEDDABLE:$KOTLIN_COMPILER_VERSION&quot;)
        val myResolvableConfiguration = target.configurations.create(&quot;myResolvable&quot;) {
            extendsFrom(myDependencyScope)
        }
        target.tasks.register(&quot;myTask&quot;, TaskUsingKotlinCompiler::class.java) {
            kotlinCompiler.from(myResolvableConfiguration)
        }
    }

    companion object {
        const val KOTLIN_COMPILER_EMBEDDABLE = &quot;org.jetbrains.kotlin:kotlin-compiler-embeddable&quot;
        const val KOTLIN_COMPILER_VERSION = &quot;2.2.0&quot;
    }
}
</div></section></section></section><section class="chapter"><h2 id="compose-compiler-updates" data-toc="compose-compiler-updates">Compose compiler updates</h2><section class="chapter"><h3 id="support-for-multiple-stability-configuration-files" data-toc="support-for-multiple-stability-configuration-files">Support for multiple stability configuration files</h3><p id="-qc40jp_808">The Compose compiler can interpret multiple stability configuration files, but the <code class="code" id="-qc40jp_812">stabilityConfigurationFile</code> option of the Compose Compiler Gradle plugin previously allowed for only a single file to be specified. In Kotlin 2.1.0, this functionality was reworked to allow you to use several stability configuration files for a single module:</p><ul class="list _bullet" id="-qc40jp_809"><li class="list__item" id="-qc40jp_813"><p id="-qc40jp_815">The <code class="code" id="-qc40jp_816">stabilityConfigurationFile</code> option is deprecated.</p></li><li class="list__item" id="-qc40jp_814"><p id="-qc40jp_817">There is a new option, <code class="code" id="-qc40jp_818">stabilityConfigurationFiles</code>, with the type <code class="code" id="-qc40jp_819">ListProperty&lt;RegularFile&gt;</code>.</p></li></ul><p id="-qc40jp_810">Here's how to pass several files to the Compose compiler using the new option:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kt
composeCompiler {
    stabilityConfigurationFiles.addAll(
        project.layout.projectDirectory.file(&quot;configuration-file1.conf&quot;),
        project.layout.projectDirectory.file(&quot;configuration-file2.conf&quot;),
    )
}
</div></section><section class="chapter"><h3 id="pausable-composition" data-toc="pausable-composition">Pausable composition</h3><p id="-qc40jp_820">Pausable composition is a new Experimental feature that changes how the compiler generates skippable functions. With this feature enabled, composition can be suspended on skipping points during runtime, allowing long-running composition processes to be split across multiple frames. Pausable composition is used in lazy lists and other performance-intensive components for prefetching content that might cause frames to drop when executed in a blocking manner.</p><p id="-qc40jp_821">To try out pausable composition, add the following feature flag in the Gradle configuration for the Compose compiler:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
composeCompiler {
    featureFlags = setOf(
        ComposeFeatureFlag.PausableComposition
    )
}
</div><aside class="prompt" data-type="note" data-title="" id="-qc40jp_823"><p id="-qc40jp_824">Runtime support for this feature was added in the 1.8.0-alpha02 version of <code class="code" id="-qc40jp_825">androidx.compose.runtime</code>. The feature flag has no effect when used with older runtime versions.</p></aside></section><section class="chapter"><h3 id="changes-to-open-and-overridden-composable-functions" data-toc="changes-to-open-and-overridden-composable-functions">Changes to open and overridden @Composable functions</h3><p id="-qc40jp_826">Virtual (open, abstract, and overridden) <code class="code" id="-qc40jp_828">@Composable</code> functions can no longer be restartable. The codegen for restartable groups was generating calls that <a href="https://issuetracker.google.com/329477544" id="-qc40jp_829" data-external="true" rel="noopener noreferrer" target="_blank">did not work correctly</a> with inheritance, resulting in runtime crashes.</p><p id="-qc40jp_827">This means that virtual functions won't be restarted or skipped: whenever their state is invalidated, runtime will recompose their parent composable instead. If your code is sensitive to recompositions, you may notice changes in runtime behavior.</p></section><section class="chapter"><h3 id="performance-improvements" data-toc="performance-improvements">Performance improvements</h3><p id="-qc40jp_830">The Compose compiler used to create a full copy of module's IR to transform <code class="code" id="-qc40jp_832">@Composable</code> types. Apart from increased memory consumption when copying elements that were not related to Compose, this behavior was also breaking downstream compiler plugins in <a href="https://issuetracker.google.com/365066530" id="-qc40jp_833" data-external="true" rel="noopener noreferrer" target="_blank">certain edge cases</a>.</p><p id="-qc40jp_831">This copy operation was removed, resulting in potentially faster compilation times.</p></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><section class="chapter"><h3 id="changes-to-the-deprecation-severity-of-standard-library-apis" data-toc="changes-to-the-deprecation-severity-of-standard-library-apis">Changes to the deprecation severity of standard library APIs</h3><p id="-qc40jp_836">In Kotlin 2.1.0, we are raising the deprecation severity level of several standard library APIs from warning to error. If your code relies on these APIs, you need to update it to ensure compatibility. The most notable changes include:</p><ul class="list _bullet" id="-qc40jp_837"><li class="list__item" id="-qc40jp_839"><p id="-qc40jp_842"><span class="control" id="-qc40jp_843">Locale-sensitive case conversion functions for <code class="code" id="-qc40jp_851">Char</code> and <code class="code" id="-qc40jp_852">String</code> are deprecated:</span> Functions like <code class="code" id="-qc40jp_844">Char.toLowerCase()</code>, <code class="code" id="-qc40jp_845">Char.toUpperCase()</code>, <code class="code" id="-qc40jp_846">String.toUpperCase()</code>, and <code class="code" id="-qc40jp_847">String.toLowerCase()</code> are now deprecated, and using them results in an error. Replace them with locale-agnostic function alternatives or other case conversion mechanisms. If you want to continue using the default locale, replace calls like <code class="code" id="-qc40jp_848">String.toLowerCase()</code> with <code class="code" id="-qc40jp_849">String.lowercase(Locale.getDefault())</code>, explicitly specifying the locale. For a locale-agnostic conversion, replace them with <code class="code" id="-qc40jp_850">String.lowercase()</code>, which uses the invariant locale by default.</p></li><li class="list__item" id="-qc40jp_840"><p id="-qc40jp_853"><span class="control" id="-qc40jp_854">Kotlin/Native freezing API is deprecated:</span> Using the freezing-related declarations previously marked with the <code class="code" id="-qc40jp_855">@FreezingIsDeprecated</code> annotation now results in an error. This change reflects the transition from the legacy memory manager in Kotlin/Native, which required freezing objects to share them between threads. To learn how to migrate from freezing-related APIs in the new memory model, see the <a href="native-migration-guide.html#update-your-code" id="-qc40jp_856">Kotlin/Native migration guide</a>. For more information, see the <a href="whatsnew1720.html#freezing" id="-qc40jp_857">announcement about the deprecation of freezing</a>.</p></li><li class="list__item" id="-qc40jp_841"><p id="-qc40jp_858"><span class="control" id="-qc40jp_859"><code class="code" id="-qc40jp_870">appendln()</code> is deprecated in favor of <code class="code" id="-qc40jp_871">appendLine()</code>:</span> The <code class="code" id="-qc40jp_860">StringBuilder.appendln()</code> and <code class="code" id="-qc40jp_861">Appendable.appendln()</code> functions are now deprecated, and using them results in an error. To replace them, use the <code class="code" id="-qc40jp_862">StringBuilder.appendLine()</code> or <code class="code" id="-qc40jp_863">Appendable.appendLine()</code> functions instead. The <code class="code" id="-qc40jp_864">appendln()</code> function is deprecated because, on Kotlin/JVM, it uses the <code class="code" id="-qc40jp_865">line.separator</code> system property, which has a different default value on each OS. On Kotlin/JVM, this property defaults to <code class="code" id="-qc40jp_866">\r\n</code> (CR LF) on Windows and <code class="code" id="-qc40jp_867">\n</code> (LF) on other systems. On the other hand, the <code class="code" id="-qc40jp_868">appendLine()</code> function consistently uses <code class="code" id="-qc40jp_869">\n</code> (LF) as the line separator, ensuring consistent behavior across platforms.</p></li></ul><p id="-qc40jp_838">For a complete list of affected APIs in this release, see the <a href="https://youtrack.jetbrains.com/issue/KT-71628" id="-qc40jp_872" data-external="true" rel="noopener noreferrer" target="_blank">KT-71628</a> YouTrack issue.</p></section><section class="chapter"><h3 id="stable-file-tree-traversal-extensions-for-java-nio-file-path" data-toc="stable-file-tree-traversal-extensions-for-java-nio-file-path">Stable file tree traversal extensions for java.nio.file.Path</h3><p id="-qc40jp_873">Kotlin 1.7.20 introduced Experimental <a href="extensions.html#extension-functions" id="-qc40jp_882">extension functions</a> for the <code class="code" id="-qc40jp_883">java.nio.file.Path</code> class, which allows you to walk through a file tree. In Kotlin 2.1.0, the following file tree traversal extensions are now <a href="components-stability.html#stability-levels-explained" id="-qc40jp_884">Stable</a>:</p><ul class="list _bullet" id="-qc40jp_874"><li class="list__item" id="-qc40jp_885"><p id="-qc40jp_891"><code class="code" id="-qc40jp_892">walk()</code> lazily traverses the file tree rooted at the specified path.</p></li><li class="list__item" id="-qc40jp_886"><p id="-qc40jp_893"><code class="code" id="-qc40jp_894">fileVisitor()</code> makes it possible to create a <code class="code" id="-qc40jp_895">FileVisitor</code> separately. <code class="code" id="-qc40jp_896">FileVisitor</code> specifies the actions to be performed on directories and files during traversal.</p></li><li class="list__item" id="-qc40jp_887"><p id="-qc40jp_897"><code class="code" id="-qc40jp_898">visitFileTree(fileVisitor: FileVisitor, ...)</code> traverses through a file tree, invoking the specified <code class="code" id="-qc40jp_899">FileVisitor</code> on each encountered entry, and it uses the <code class="code" id="-qc40jp_900">java.nio.file.Files.walkFileTree()</code> function under the hood.</p></li><li class="list__item" id="-qc40jp_888"><p id="-qc40jp_901"><code class="code" id="-qc40jp_902">visitFileTree(..., builderAction: FileVisitorBuilder.() -&gt; Unit)</code> creates a <code class="code" id="-qc40jp_903">FileVisitor</code> with the provided <code class="code" id="-qc40jp_904">builderAction</code> and calls the <code class="code" id="-qc40jp_905">visitFileTree(fileVisitor, ...)</code> function.</p></li><li class="list__item" id="-qc40jp_889"><p id="-qc40jp_906"><code class="code" id="-qc40jp_907">sealed interface FileVisitorBuilder</code> allows you to define a custom <code class="code" id="-qc40jp_908">FileVisitor</code> implementation.</p></li><li class="list__item" id="-qc40jp_890"><p id="-qc40jp_909"><code class="code" id="-qc40jp_910">enum class PathWalkOption</code> provides traversal options for the <code class="code" id="-qc40jp_911">Path.walk()</code> function.</p></li></ul><p id="-qc40jp_875">The examples below demonstrate how to use these file traversal APIs to create custom <code class="code" id="-qc40jp_912">FileVisitor</code> behaviors, which allows you to define specific actions for visiting files and directories.</p><p id="-qc40jp_876">For instance, you can explicitly create a <code class="code" id="-qc40jp_913">FileVisitor</code> and use it later:</p><div class="code-block" data-lang="kotlin">
val cleanVisitor = fileVisitor {
    onPreVisitDirectory { directory, attributes -&gt;
        // Placeholder: Add logic on visiting directories
        FileVisitResult.CONTINUE
    }

    onVisitFile { file, attributes -&gt;
        // Placeholder: Add logic on visiting files
        FileVisitResult.CONTINUE
    }
}

// Placeholder: Add logic here for general setup before traversal
projectDirectory.visitFileTree(cleanVisitor)
</div><p id="-qc40jp_878">You can also create a <code class="code" id="-qc40jp_914">FileVisitor</code> with the <code class="code" id="-qc40jp_915">builderAction</code> and use it immediately for the traversal:</p><div class="code-block" data-lang="kotlin">
projectDirectory.visitFileTree {
    // Defines the builderAction:
    onPreVisitDirectory { directory, attributes -&gt;
        // Some logic on visiting directories
        FileVisitResult.CONTINUE
    }

    onVisitFile { file, attributes -&gt;
        // Some logic on visiting files
        FileVisitResult.CONTINUE
    }
}
</div><p id="-qc40jp_880">Additionally, you can traverse a file tree rooted at the specified path with the <code class="code" id="-qc40jp_916">walk()</code> function:</p><div class="code-block" data-lang="kotlin">
fun traverseFileTree() {
    val cleanVisitor = fileVisitor {
        onPreVisitDirectory { directory, _ -&gt;
            if (directory.name == &quot;build&quot;) {
                directory.toFile().deleteRecursively()
                FileVisitResult.SKIP_SUBTREE
            } else {
                FileVisitResult.CONTINUE
            }
        }

        // Deletes files with the .class extension
        onVisitFile { file, _ -&gt;
            if (file.extension == &quot;class&quot;) {
                file.deleteExisting()
            }
            FileVisitResult.CONTINUE
        }
    }

    // Sets up the root directory and files
    val rootDirectory = createTempDirectory(&quot;Project&quot;)

    // Creates the src directory with A.kt and A.class files
    rootDirectory.resolve(&quot;src&quot;).let { srcDirectory -&gt;
        srcDirectory.createDirectory()
        srcDirectory.resolve(&quot;A.kt&quot;).createFile()
        srcDirectory.resolve(&quot;A.class&quot;).createFile()
    }

    // Creates the build directory with a Project.jar file
    rootDirectory.resolve(&quot;build&quot;).let { buildDirectory -&gt;
        buildDirectory.createDirectory()
        buildDirectory.resolve(&quot;Project.jar&quot;).createFile()
    }

    // Uses the walk() function:
    val directoryStructure = rootDirectory.walk(PathWalkOption.INCLUDE_DIRECTORIES)
        .map { it.relativeTo(rootDirectory).toString() }
        .toList().sorted()
    println(directoryStructure)
    // &quot;[, build, build/Project.jar, src, src/A.class, src/A.kt]&quot;
  
    // Traverses the file tree with cleanVisitor, applying the rootDirectory.visitFileTree(cleanVisitor) cleanup rules
    val directoryStructureAfterClean = rootDirectory.walk(PathWalkOption.INCLUDE_DIRECTORIES)
        .map { it.relativeTo(rootDirectory).toString() }
        .toList().sorted()
    println(directoryStructureAfterClean)
    // &quot;[, src, src/A.kt]&quot;
}
</div></section></section><section class="chapter"><h2 id="documentation-updates" data-toc="documentation-updates">Documentation updates</h2><p id="-qc40jp_917">The Kotlin documentation has received some notable changes:</p><section class="chapter"><h3 id="language-concepts" data-toc="language-concepts">Language concepts</h3><ul class="list _bullet" id="-qc40jp_923"><li class="list__item" id="-qc40jp_924"><p id="-qc40jp_928">Improved <a href="null-safety.html" id="-qc40jp_929">Null safety</a> page &ndash; Learn how to handle <code class="code" id="-qc40jp_930">null</code> values safely in your code.</p></li><li class="list__item" id="-qc40jp_925"><p id="-qc40jp_931">Improved <a href="object-declarations.html" id="-qc40jp_932">Objects declarations and expressions</a> page &ndash; Learn how to define a class and create an instance in a single step.</p></li><li class="list__item" id="-qc40jp_926"><p id="-qc40jp_933">Improved <a href="control-flow.html#when-expressions-and-statements" id="-qc40jp_934">When expressions and statements</a> section &ndash; Learn about the <code class="code" id="-qc40jp_935">when</code> conditional and how you can use it.</p></li><li class="list__item" id="-qc40jp_927"><p id="-qc40jp_936">Updated <a href="roadmap.html" id="-qc40jp_937">Kotlin roadmap</a>, <a href="kotlin-evolution-principles.html" id="-qc40jp_938">Kotlin evolution principles</a>, and <a href="kotlin-language-features-and-proposals.html" id="-qc40jp_939">Kotlin language features and proposals</a> pages &ndash; Learn about Kotlin's plans, ongoing developments, and guiding principles.</p></li></ul></section><section class="chapter"><h3 id="compose-compiler" data-toc="compose-compiler">Compose compiler</h3><ul class="list _bullet" id="-qc40jp_940"><li class="list__item" id="-qc40jp_941"><p id="-qc40jp_942"><a href="compose-compiler-migration-guide.html" id="-qc40jp_943">Compose compiler documentation</a> now located in the Compiler and plugins section &ndash; Learn about the Compose compiler, the compiler options, and the steps to migrate.</p></li></ul></section><section class="chapter"><h3 id="api-references" data-toc="api-references">API references</h3><ul class="list _bullet" id="-qc40jp_944"><li class="list__item" id="-qc40jp_945"><p id="-qc40jp_946">New <a href="https://kotlinlang.org/api/kotlin-gradle-plugin" id="-qc40jp_947" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Gradle plugins API reference</a> &ndash; Explore the API references for the Kotlin Gradle plugin and the Compose compiler Gradle plugin.</p></li></ul></section><section class="chapter"><h3 id="multiplatform-development" data-toc="multiplatform-development">Multiplatform development</h3><ul class="list _bullet" id="-qc40jp_948"><li class="list__item" id="-qc40jp_949"><p id="-qc40jp_955">New <a href="https://kotlinlang.org/docs/api-guidelines-build-for-multiplatform.html" id="-qc40jp_956" data-external="true" rel="noopener noreferrer" target="_blank">Building a Kotlin library for multiplatform</a> page &ndash; Learn how to design your Kotlin libraries for Kotlin Multiplatform.</p></li><li class="list__item" id="-qc40jp_950"><p id="-qc40jp_957">New <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" id="-qc40jp_958" data-external="true" rel="noopener noreferrer" target="_blank">Introduction to Kotlin Multiplatform</a> page &ndash; Learn about Kotlin Multiplatform's key concepts, dependencies, libraries, and more.</p></li><li class="list__item" id="-qc40jp_951"><p id="-qc40jp_959">Updated <a href="multiplatform.html" id="-qc40jp_960">Kotlin Multiplatform overview</a> page &ndash; Navigate through the essentials of Kotlin Multiplatform and popular use cases.</p></li><li class="list__item" id="-qc40jp_952"><p id="-qc40jp_961">New <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ios-integration-overview.html" id="-qc40jp_962" data-external="true" rel="noopener noreferrer" target="_blank">iOS integration</a> section &ndash; Learn how to integrate a Kotlin Multiplatform shared module into your iOS app.</p></li><li class="list__item" id="-qc40jp_953"><p id="-qc40jp_963">New <a href="native-definition-file.html" id="-qc40jp_964">Kotlin/Native's definition file</a> page &ndash; Learn how to create a definition file to consume C and Objective-C libraries.</p></li><li class="list__item" id="-qc40jp_954"><p id="-qc40jp_965"><a href="wasm-wasi.html" id="-qc40jp_966">Get started with WASI</a> &ndash; Learn how to run a simple Kotlin/Wasm application using WASI in various WebAssembly virtual machines.</p></li></ul></section><section class="chapter"><h3 id="tooling" data-toc="tooling">Tooling</h3><ul class="list _bullet" id="-qc40jp_967"><li class="list__item" id="-qc40jp_968"><p id="-qc40jp_969"><span id="-qc40jp_970">New Dokka migration guide</span> &ndash; Learn how to migrate to Dokka Gradle plugin v2.</p></li></ul></section></section><section class="chapter"><h2 id="compatibility-guide-for-kotlin-2-1-0" data-toc="compatibility-guide-for-kotlin-2-1-0">Compatibility guide for Kotlin 2.1.0</h2><p id="-qc40jp_971">Kotlin 2.1.0 is a feature release and can, therefore, bring changes that are incompatible with your code written for earlier versions of the language. Find the detailed list of these changes in the <a href="compatibility-guide-21.html" id="-qc40jp_972">Compatibility guide for Kotlin 2.1.0</a>.</p></section><section class="chapter"><h2 id="install-kotlin-2-1-0" data-toc="install-kotlin-2-1-0">Install Kotlin 2.1.0</h2><p id="-qc40jp_973">Starting from IntelliJ IDEA 2023.3 and Android Studio Iguana (2023.2.1) Canary 15, the Kotlin plugin is distributed as a bundled plugin included in your IDE. This means that you can't install the plugin from JetBrains Marketplace anymore.</p><p id="-qc40jp_974">To update to the new Kotlin version, <a href="releases.html#update-to-a-new-kotlin-version" id="-qc40jp_975">change the Kotlin version</a> to 2.1.0 in your build scripts.</p></section><div class="last-modified">01 August 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew2120.html" class="navigation-links__prev">What's new in Kotlin 2.1.20</a><a href="whatsnew2020.html" class="navigation-links__next">What's new in Kotlin 2.0.20</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>