<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-18T18:58:25.964762927"><link rel="canonical" href="https://kotlinlang.org/docs/native-memory-manager.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Kotlin/Native memory management | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"garbage-collector","level":0,"title":"Garbage collector","anchor":"#garbage-collector"},{"id":"enable-garbage-collection-manually","level":1,"title":"Enable garbage collection manually","anchor":"#enable-garbage-collection-manually"},{"id":"monitor-gc-performance","level":1,"title":"Monitor GC performance","anchor":"#monitor-gc-performance"},{"id":"optimize-gc-performance","level":1,"title":"Optimize GC performance","anchor":"#optimize-gc-performance"},{"id":"disable-garbage-collection","level":1,"title":"Disable garbage collection","anchor":"#disable-garbage-collection"},{"id":"memory-consumption","level":0,"title":"Memory consumption","anchor":"#memory-consumption"},{"id":"monitor-memory-consumption","level":1,"title":"Monitor memory consumption","anchor":"#monitor-memory-consumption"},{"id":"adjust-memory-consumption","level":1,"title":"Adjust memory consumption","anchor":"#adjust-memory-consumption"},{"id":"unit-tests-in-the-background","level":0,"title":"Unit tests in the background","anchor":"#unit-tests-in-the-background"},{"id":"what-s-next","level":0,"title":"What\u0027s next","anchor":"#what-s-next"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Kotlin/Native memory management | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/native-memory-manager.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Kotlin/Native memory management | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/native-memory-manager.html#webpage",
    "url": "https://kotlinlang.org/docs/native-memory-manager.html",
    "name": "Kotlin/Native memory management | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="native-memory-manager" data-main-title="Kotlin/Native memory management" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///Native///Memory manager" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/native/native-memory-manager.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="native-memory-manager" id="native-memory-manager.md">Kotlin/Native memory management</h1><p id="xzz74o_2">Kotlin/Native uses a modern memory manager that is similar to the JVM, Go, and other mainstream technologies, including the following features:</p><ul class="list _bullet" id="xzz74o_3"><li class="list__item" id="xzz74o_8"><p id="xzz74o_10">Objects are stored in a shared heap and can be accessed from any thread.</p></li><li class="list__item" id="xzz74o_9"><p id="xzz74o_11">Tracing garbage collection is performed periodically to collect objects that are not reachable from the &quot;roots&quot;, like local and global variables.</p></li></ul><section class="chapter"><h2 id="garbage-collector" data-toc="garbage-collector">Garbage collector</h2><p id="xzz74o_12">Kotlin/Native's garbage collector (GC) algorithm is constantly evolving. Currently, it functions as a stop-the-world mark and concurrent sweep collector that does not separate the heap into generations.</p><p id="xzz74o_13">The GC is executed on a separate thread and started based on the memory pressure heuristics or by a timer. Alternatively, it can be <a href="#enable-garbage-collection-manually" id="xzz74o_22">called manually</a>.</p><p id="xzz74o_14">The GC processes the mark queue on several threads in parallel, including application threads, the GC thread, and optional marker threads. Application threads and at least one GC thread participate in the marking process. By default, application threads must be paused when the GC is marking objects in the heap.</p><aside class="prompt" data-type="tip" data-title="" id="xzz74o_15"><p id="xzz74o_23">You can disable the parallelization of the mark phase with the <code class="code" id="xzz74o_24">kotlin.native.binary.gcMarkSingleThreaded=true</code> compiler option. However, this may increase the garbage collector's pause time on large heaps.</p></aside><p id="xzz74o_16">When the marking phase is completed, the GC processes weak references and nullifies reference points to an unmarked object. By default, weak references are processed concurrently to decrease the GC pause time.</p><p id="xzz74o_17">See how to <a href="#monitor-gc-performance" id="xzz74o_25">monitor</a> and <a href="#optimize-gc-performance" id="xzz74o_26">optimize</a> garbage collection.</p><section class="chapter"><h3 id="enable-garbage-collection-manually" data-toc="enable-garbage-collection-manually">Enable garbage collection manually</h3><p id="xzz74o_27">To force-start the garbage collector, call <code class="code" id="xzz74o_28">kotlin.native.internal.GC.collect()</code>. This method triggers a new collection and waits for its completion.</p></section><section class="chapter"><h3 id="monitor-gc-performance" data-toc="monitor-gc-performance">Monitor GC performance</h3><p id="xzz74o_29">To monitor the GC performance, you can look through its logs and diagnose issues. To enable logging, set the following compiler option in your Gradle build script:</p><div class="code-block" data-lang="none">
-Xruntime-logs=gc=info
</div><p id="xzz74o_31">Currently, the logs are only printed to <code class="code" id="xzz74o_35">stderr</code>.</p><p id="xzz74o_32">On Apple platforms, you can take advantage of the Xcode Instruments toolkit to debug iOS app performance. The garbage collector reports pauses with signposts available in Instruments. Signposts enable custom logging within your app, allowing you to check if a GC pause corresponds to an application freeze.</p><p id="xzz74o_33">To track GC-related pauses in your app:</p><ol class="list _decimal" id="xzz74o_34" type="1"><li class="list__item" id="xzz74o_36"><p id="xzz74o_41">To enable the feature, set the following compiler option in your <code class="code" id="xzz74o_43">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.enableSafepointSignposts=true
</div></li><li class="list__item" id="xzz74o_37"><p id="xzz74o_44">Open Xcode, go to <span class="control" id="xzz74o_45">Product</span> | <span class="control" id="xzz74o_46">Profile</span> or press <kbd class="keystroke" id="xzz74o_47" data-bypass="true"><span class="keystroke__value">Cmd + I</span></kbd>. This action compiles your app and launches Instruments.</p></li><li class="list__item" id="xzz74o_38"><p id="xzz74o_48">In the template selection, select <span class="control" id="xzz74o_49">os_signpost</span>.</p></li><li class="list__item" id="xzz74o_39"><p id="xzz74o_50">Configure it by specifying <code class="code" id="xzz74o_51">org.kotlinlang.native.runtime</code> as <span class="control" id="xzz74o_52">subsystem</span> and <code class="code" id="xzz74o_53">safepoint</code> as <span class="control" id="xzz74o_54">category</span>.</p></li><li class="list__item" id="xzz74o_40"><p id="xzz74o_55">Click the red record button to run your app and start recording signpost events:</p><figure id="xzz74o_56"><img alt="Tracking GC pauses as signposts" src="images/native-gc-signposts.png" title="Tracking GC pauses as signposts" width="700" height="571"></figure><p id="xzz74o_57">Here, each blue blob on the lowest graph represents a separate signpost event, which is a GC pause.</p></li></ol></section><section class="chapter"><h3 id="optimize-gc-performance" data-toc="optimize-gc-performance">Optimize GC performance</h3><p id="xzz74o_58">To improve GC performance, you can enable concurrent marking to decrease the GC pause time. This allows the marking phase of garbage collection to run simultaneously with application threads.</p><p id="xzz74o_59">The feature is currently <a href="components-stability.html#stability-levels-explained" id="xzz74o_61">Experimental</a>. To enable it, set the following compiler option in your <code class="code" id="xzz74o_62">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.gc=cms
</div></section><section class="chapter"><h3 id="disable-garbage-collection" data-toc="disable-garbage-collection">Disable garbage collection</h3><p id="xzz74o_63">It's recommended to keep the GC enabled. However, you can disable it in certain cases, such as for testing purposes or if you encounter issues and have a short-lived program. To do so, set the following binary option in your <code class="code" id="xzz74o_66">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.gc=noop
</div><aside class="prompt" data-type="warning" data-title="" id="xzz74o_65"><p id="xzz74o_67">With this option enabled, the GC doesn't collect Kotlin objects, so memory consumption will keep rising as long as the program runs. Be careful not to exhaust the system memory.</p></aside></section></section><section class="chapter"><h2 id="memory-consumption" data-toc="memory-consumption">Memory consumption</h2><p id="xzz74o_68">Kotlin/Native uses its own <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/runtime/src/alloc/custom/README.md" id="xzz74o_74" data-external="true" rel="noopener noreferrer" target="_blank">memory allocator</a>. It divides system memory into pages, allowing independent sweeping in consecutive order. Each allocation becomes a memory block within a page, and the page keeps track of block sizes. Different page types are optimized for various allocation sizes. The consecutive arrangement of memory blocks ensures efficient iteration through all allocated blocks.</p><p id="xzz74o_69">When a thread allocates memory, it searches for a suitable page based on the allocation size. Threads maintain a set of pages for different size categories. Typically, the current page for a given size can accommodate the allocation. If not, the thread requests a different page from the shared allocation space. This page may already be available, require sweeping, or have to be created first.</p><p id="xzz74o_70">The Kotlin/Native memory allocator comes with protection against sudden spikes in memory allocations. It prevents situations where the mutator starts to allocate a lot of garbage quickly and the GC thread cannot keep up with it, making the memory usage grow endlessly. In this case, the GC forces a stop-the-world phase until the iteration is completed.</p><p id="xzz74o_71">You can monitor memory consumption yourself, check for memory leaks, and adjust memory consumption.</p><section class="chapter"><h3 id="monitor-memory-consumption" data-toc="monitor-memory-consumption">Monitor memory consumption</h3><p id="xzz74o_75">To debug memory issues, you can check memory manager metrics. In addition, it's possible to track Kotlin's memory consumption on Apple platforms.</p><section class="chapter"><h4 id="check-for-memory-leaks" data-toc="check-for-memory-leaks">Check for memory leaks</h4><p id="xzz74o_78">To access the memory manager metrics, call <code class="code" id="xzz74o_81">kotlin.native.internal.GC.lastGCInfo()</code>. This method returns statistics for the last run of the garbage collector. The statistics can be useful for:</p><ul class="list _bullet" id="xzz74o_79"><li class="list__item" id="xzz74o_82"><p id="xzz74o_84">Debugging memory leaks when using global variables</p></li><li class="list__item" id="xzz74o_83"><p id="xzz74o_85">Checking for leaks when running tests</p></li></ul><div class="code-block" data-lang="kotlin">
import kotlin.native.internal.*
import kotlin.test.*

class Resource

val global = mutableListOf&lt;Resource&gt;()

@OptIn(ExperimentalStdlibApi::class)
fun getUsage(): Long {
    GC.collect()
    return GC.lastGCInfo!!.memoryUsageAfter[&quot;heap&quot;]!!.totalObjectsSizeBytes
}

fun run() {
    global.add(Resource())
    // The test will fail if you remove the next line
    global.clear()
}

@Test
fun test() {
    val before = getUsage()
    // A separate function is used to ensure that all temporary objects are cleared
    run()
    val after = getUsage()
    assertEquals(before, after)
}
</div></section><section class="chapter"><h4 id="track-memory-consumption-on-apple-platforms" data-toc="track-memory-consumption-on-apple-platforms">Track memory consumption on Apple platforms</h4><p id="xzz74o_86">When debugging memory issues on Apple platforms, you can see how much memory is reserved by Kotlin code. Kotlin's share is tagged with an identifier and can be tracked through tools like VM Tracker in Xcode Instruments.</p><p id="xzz74o_87">The feature is available only for the default Kotlin/Native memory allocator when <span class="emphasis" id="xzz74o_89">all</span> the following conditions are met:</p><ul class="list _bullet" id="xzz74o_88"><li class="list__item" id="xzz74o_90"><p id="xzz74o_93"><span class="control" id="xzz74o_95">Tagging enabled</span>. The memory should be tagged with a valid identifier. Apple recommends numbers between 240 and 255; the default value is 246.</p><p id="xzz74o_94">If you set up the <code class="code" id="xzz74o_96">kotlin.native.binary.mmapTag=0</code> Gradle property, tagging is disabled.</p></li><li class="list__item" id="xzz74o_91"><p id="xzz74o_97"><span class="control" id="xzz74o_99">Allocation with mmap</span>. The allocator should use the <code class="code" id="xzz74o_100">mmap</code> system call to map files into memory.</p><p id="xzz74o_98">If you set up the <code class="code" id="xzz74o_101">kotlin.native.binary.disableMmap=true</code> Gradle property, the default allocator uses <code class="code" id="xzz74o_102">malloc</code> instead of <code class="code" id="xzz74o_103">mmap</code>.</p></li><li class="list__item" id="xzz74o_92"><p id="xzz74o_104"><span class="control" id="xzz74o_106">Paging enabled</span>. Paging of allocations (buffering) should be enabled.</p><p id="xzz74o_105">If you set up the <a href="#disable-allocator-paging" id="xzz74o_107"><code class="code" id="xzz74o_108">kotlin.native.binary.pagedAllocator=false</code></a> Gradle property, the memory is reserved on a per-object basis instead.</p></li></ul></section></section><section class="chapter"><h3 id="adjust-memory-consumption" data-toc="adjust-memory-consumption">Adjust memory consumption</h3><p id="xzz74o_109">If you experience unexpectedly high memory consumption, try the following solutions:</p><section class="chapter"><h4 id="update-kotlin" data-toc="update-kotlin">Update Kotlin</h4><p id="xzz74o_113">Update Kotlin to the latest version. We're constantly improving the memory manager, so even a simple compiler update might improve memory consumption.</p></section><section class="chapter"><h4 id="disable-allocator-paging" data-toc="disable-allocator-paging" data-label-id="experimental-opt-in">Disable allocator paging</h4><p id="xzz74o_115">You can disable paging of allocations (buffering) so that the memory allocator reserves memory on a per-object basis. In some cases, it may help you satisfy strict memory limitations or reduce memory consumption on the application's startup.</p><p id="xzz74o_116">To do that, set the following option in your <code class="code" id="xzz74o_119">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.pagedAllocator=false
</div><aside class="prompt" data-type="note" data-title="" id="xzz74o_118"><p id="xzz74o_120">With allocator paging disabled, <a href="#track-memory-consumption-on-apple-platforms" id="xzz74o_121">tracking memory consumption on Apple platforms</a> is not possible.</p></aside></section><section class="chapter"><h4 id="enable-support-for-latin-1-strings" data-toc="enable-support-for-latin-1-strings" data-label-id="experimental-opt-in">Enable support for Latin-1 strings</h4><p id="xzz74o_123">By default, strings in Kotlin are stored using UTF-16 encoding, where each character is represented by two bytes. In some cases, it leads to strings taking up twice as much space in the binary compared to the source code and reading data taking up twice as much memory.</p><p id="xzz74o_124">To reduce the application's binary size and adjust memory consumption, you can enable support for Latin-1-encoded strings. The <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" id="xzz74o_130" data-external="true" rel="noopener noreferrer" target="_blank">Latin-1 (ISO 8859-1)</a> encoding represents each of the first 256 Unicode characters by just one byte.</p><p id="xzz74o_125">To enable it, set the following option in your <code class="code" id="xzz74o_131">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.latin1Strings=true
</div><p id="xzz74o_127">With the Latin-1 support, strings are stored in Latin-1 encoding as long as all the characters fall within its range. Otherwise, the default UTF-16 encoding is used.</p><aside class="prompt" data-type="note" data-title="" id="xzz74o_128"><p id="xzz74o_132">While the feature is Experimental, the cinterop extension functions <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/pin.html" id="xzz74o_133" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="xzz74o_136">String.pin</code></a>, <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" id="xzz74o_134" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="xzz74o_137">String.usePinned</code></a>, and <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" id="xzz74o_135" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="xzz74o_138">String.refTo</code></a> become less efficient. Each call to them may trigger an automatic string conversion to UTF-16.</p></aside><p id="xzz74o_129">If none of these options helped, create an issue in <a href="https://kotl.in/issue" id="xzz74o_139" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section></section><section class="chapter"><h2 id="unit-tests-in-the-background" data-toc="unit-tests-in-the-background">Unit tests in the background</h2><p id="xzz74o_140">In unit tests, nothing processes the main thread queue, so don't use <code class="code" id="xzz74o_144">Dispatchers.Main</code> unless it was mocked. Mocking it can be done by calling <code class="code" id="xzz74o_145">Dispatchers.setMain</code> from <code class="code" id="xzz74o_146">kotlinx-coroutines-test</code>.</p><p id="xzz74o_141">If you don't rely on <code class="code" id="xzz74o_147">kotlinx.coroutines</code> or if <code class="code" id="xzz74o_148">Dispatchers.setMain</code> doesn't work for you for some reason, try the following workaround for implementing the test launcher:</p><div class="code-collapse" data-lang="kotlin" data-is-expanded="false" data-synopsis="package testlauncher">
package testlauncher

import platform.CoreFoundation.*
import kotlin.native.concurrent.*
import kotlin.native.internal.test.*
import kotlin.system.*

fun mainBackground(args: Array&lt;String&gt;) {
    val worker = Worker.start(name = &quot;main-background&quot;)
    worker.execute(TransferMode.SAFE, { args.freeze() }) {
        val result = testLauncherEntryPoint(it)
        exitProcess(result)
    }
    CFRunLoopRun()
    error(&quot;CFRunLoopRun should never return&quot;)
}
</div><p id="xzz74o_143">Then, compile the test binary with the <code class="code" id="xzz74o_149">-e testlauncher.mainBackground</code> compiler option.</p></section><section class="chapter"><h2 id="what-s-next" data-toc="what-s-next">What's next</h2><ul class="list _bullet" id="xzz74o_150"><li class="list__item" id="xzz74o_151"><p id="xzz74o_153"><a href="native-migration-guide.html" id="xzz74o_154">Migrate from the legacy memory manager</a></p></li><li class="list__item" id="xzz74o_152"><p id="xzz74o_155"><a href="native-arc-integration.html" id="xzz74o_156">Check the specifics of integration with Swift/Objective-C ARC</a></p></li></ul></section><div class="last-modified">18 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="native-platform-libs.html" class="navigation-links__prev">Platform libraries</a><a href="native-arc-integration.html" class="navigation-links__next">Integration with Swift/Objective-C ARC</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>