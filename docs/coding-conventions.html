<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-17T17:49:57.422732965"><link rel="canonical" href="https://kotlinlang.org/docs/coding-conventions.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Coding conventions | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"configure-style-in-ide","level":0,"title":"Configure style in IDE","anchor":"#configure-style-in-ide"},{"id":"apply-the-style-guide","level":1,"title":"Apply the style guide","anchor":"#apply-the-style-guide"},{"id":"verify-that-your-code-follows-the-style-guide","level":1,"title":"Verify that your code follows the style guide","anchor":"#verify-that-your-code-follows-the-style-guide"},{"id":"source-code-organization","level":0,"title":"Source code organization","anchor":"#source-code-organization"},{"id":"directory-structure","level":1,"title":"Directory structure","anchor":"#directory-structure"},{"id":"source-file-names","level":1,"title":"Source file names","anchor":"#source-file-names"},{"id":"source-file-organization","level":1,"title":"Source file organization","anchor":"#source-file-organization"},{"id":"class-layout","level":1,"title":"Class layout","anchor":"#class-layout"},{"id":"interface-implementation-layout","level":1,"title":"Interface implementation layout","anchor":"#interface-implementation-layout"},{"id":"overload-layout","level":1,"title":"Overload layout","anchor":"#overload-layout"},{"id":"naming-rules","level":0,"title":"Naming rules","anchor":"#naming-rules"},{"id":"function-names","level":1,"title":"Function names","anchor":"#function-names"},{"id":"names-for-test-methods","level":1,"title":"Names for test methods","anchor":"#names-for-test-methods"},{"id":"property-names","level":1,"title":"Property names","anchor":"#property-names"},{"id":"names-for-backing-properties","level":1,"title":"Names for backing properties","anchor":"#names-for-backing-properties"},{"id":"choose-good-names","level":1,"title":"Choose good names","anchor":"#choose-good-names"},{"id":"formatting","level":0,"title":"Formatting","anchor":"#formatting"},{"id":"indentation","level":1,"title":"Indentation","anchor":"#indentation"},{"id":"horizontal-whitespace","level":1,"title":"Horizontal whitespace","anchor":"#horizontal-whitespace"},{"id":"colon","level":1,"title":"Colon","anchor":"#colon"},{"id":"class-headers","level":1,"title":"Class headers","anchor":"#class-headers"},{"id":"modifiers-order","level":1,"title":"Modifiers order","anchor":"#modifiers-order"},{"id":"annotations","level":1,"title":"Annotations","anchor":"#annotations"},{"id":"file-annotations","level":1,"title":"File annotations","anchor":"#file-annotations"},{"id":"functions","level":1,"title":"Functions","anchor":"#functions"},{"id":"expression-bodies","level":1,"title":"Expression bodies","anchor":"#expression-bodies"},{"id":"properties","level":1,"title":"Properties","anchor":"#properties"},{"id":"control-flow-statements","level":1,"title":"Control flow statements","anchor":"#control-flow-statements"},{"id":"method-calls","level":1,"title":"Method calls","anchor":"#method-calls"},{"id":"wrap-chained-calls","level":1,"title":"Wrap chained calls","anchor":"#wrap-chained-calls"},{"id":"lambdas","level":1,"title":"Lambdas","anchor":"#lambdas"},{"id":"trailing-commas","level":1,"title":"Trailing commas","anchor":"#trailing-commas"},{"id":"documentation-comments","level":0,"title":"Documentation comments","anchor":"#documentation-comments"},{"id":"avoid-redundant-constructs","level":0,"title":"Avoid redundant constructs","anchor":"#avoid-redundant-constructs"},{"id":"unit-return-type","level":1,"title":"Unit return type","anchor":"#unit-return-type"},{"id":"semicolons","level":1,"title":"Semicolons","anchor":"#semicolons"},{"id":"string-templates","level":1,"title":"String templates","anchor":"#string-templates"},{"id":"idiomatic-use-of-language-features","level":0,"title":"Idiomatic use of language features","anchor":"#idiomatic-use-of-language-features"},{"id":"immutability","level":1,"title":"Immutability","anchor":"#immutability"},{"id":"default-parameter-values","level":1,"title":"Default parameter values","anchor":"#default-parameter-values"},{"id":"type-aliases","level":1,"title":"Type aliases","anchor":"#type-aliases"},{"id":"lambda-parameters","level":1,"title":"Lambda parameters","anchor":"#lambda-parameters"},{"id":"returns-in-a-lambda","level":1,"title":"Returns in a lambda","anchor":"#returns-in-a-lambda"},{"id":"named-arguments","level":1,"title":"Named arguments","anchor":"#named-arguments"},{"id":"conditional-statements","level":1,"title":"Conditional statements","anchor":"#conditional-statements"},{"id":"if-versus-when","level":1,"title":"if versus when","anchor":"#if-versus-when"},{"id":"guard-conditions-in-when-expression","level":1,"title":"Guard conditions in when expression","anchor":"#guard-conditions-in-when-expression"},{"id":"nullable-boolean-values-in-conditions","level":1,"title":"Nullable Boolean values in conditions","anchor":"#nullable-boolean-values-in-conditions"},{"id":"loops","level":1,"title":"Loops","anchor":"#loops"},{"id":"loops-on-ranges","level":1,"title":"Loops on ranges","anchor":"#loops-on-ranges"},{"id":"strings","level":1,"title":"Strings","anchor":"#strings"},{"id":"functions-vs-properties","level":1,"title":"Functions vs properties","anchor":"#functions-vs-properties"},{"id":"extension-functions","level":1,"title":"Extension functions","anchor":"#extension-functions"},{"id":"infix-functions","level":1,"title":"Infix functions","anchor":"#infix-functions"},{"id":"factory-functions","level":1,"title":"Factory functions","anchor":"#factory-functions"},{"id":"platform-types","level":1,"title":"Platform types","anchor":"#platform-types"},{"id":"scope-functions-apply-with-run-also-let","level":1,"title":"Scope functions apply/with/run/also/let","anchor":"#scope-functions-apply-with-run-also-let"},{"id":"coding-conventions-for-libraries","level":0,"title":"Coding conventions for libraries","anchor":"#coding-conventions-for-libraries"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Coding conventions | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/coding-conventions.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Coding conventions | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/coding-conventions.html#webpage",
    "url": "https://kotlinlang.org/docs/coding-conventions.html",
    "name": "Coding conventions | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="coding-conventions" data-main-title="Coding conventions" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Basics" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/coding-conventions.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="coding-conventions" id="coding-conventions.md">Coding conventions</h1><p id="-q3d1qe_2">Commonly known and easy-to-follow coding conventions are vital for any programming language. Here we provide guidelines on the code style and code organization for projects that use Kotlin.</p><section class="chapter"><h2 id="configure-style-in-ide" data-toc="configure-style-in-ide">Configure style in IDE</h2><p id="-q3d1qe_11">Two most popular IDEs for Kotlin - <a href="https://www.jetbrains.com/idea/" id="-q3d1qe_14" data-external="true" rel="noopener noreferrer" target="_blank">IntelliJ IDEA</a> and <a href="https://developer.android.com/studio/" id="-q3d1qe_15" data-external="true" rel="noopener noreferrer" target="_blank">Android Studio</a> provide powerful support for code styling. You can configure them to automatically format your code in consistence with the given code style.</p><section class="chapter"><h3 id="apply-the-style-guide" data-toc="apply-the-style-guide">Apply the style guide</h3><ol class="list _decimal" id="-q3d1qe_16" type="1"><li class="list__item" id="-q3d1qe_17"><p id="-q3d1qe_20">Go to <span class="control" id="-q3d1qe_21">Settings/Preferences | Editor | Code Style | Kotlin</span>.</p></li><li class="list__item" id="-q3d1qe_18"><p id="-q3d1qe_22">Click <span class="control" id="-q3d1qe_23">Set from...</span>.</p></li><li class="list__item" id="-q3d1qe_19"><p id="-q3d1qe_24">Select <span class="control" id="-q3d1qe_25">Kotlin style guide</span>.</p></li></ol></section><section class="chapter"><h3 id="verify-that-your-code-follows-the-style-guide" data-toc="verify-that-your-code-follows-the-style-guide">Verify that your code follows the style guide</h3><ol class="list _decimal" id="-q3d1qe_26" type="1"><li class="list__item" id="-q3d1qe_27"><p id="-q3d1qe_29">Go to <span class="control" id="-q3d1qe_30">Settings/Preferences | Editor | Inspections | General</span>.</p></li><li class="list__item" id="-q3d1qe_28"><p id="-q3d1qe_31">Switch on <span class="control" id="-q3d1qe_32">Incorrect formatting</span> inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</p></li></ol></section></section><section class="chapter"><h2 id="source-code-organization" data-toc="source-code-organization">Source code organization</h2><section class="chapter"><h3 id="directory-structure" data-toc="directory-structure">Directory structure</h3><p id="-q3d1qe_39">In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the <code class="code" id="-q3d1qe_41">org.example.kotlin</code> package and its subpackages, files with the <code class="code" id="-q3d1qe_42">org.example.kotlin</code> package should be placed directly under the source root, and files in <code class="code" id="-q3d1qe_43">org.example.kotlin.network.socket</code> should be in the <code class="code" id="-q3d1qe_44">network/socket</code> subdirectory of the source root.</p><aside class="prompt" data-type="note" data-title="" id="-q3d1qe_40"><p id="-q3d1qe_45">On JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure: each file should be stored in the directory corresponding to each package statement.</p></aside></section><section class="chapter"><h3 id="source-file-names" data-toc="source-file-names">Source file names</h3><p id="-q3d1qe_46">If a Kotlin file contains a single class or interface (potentially with related top-level declarations), its name should be the same as the name of the class, with the <code class="code" id="-q3d1qe_49">.kt</code> extension appended. It applies to all types of classes and interfaces. If a file contains multiple classes, or only top-level declarations, choose a name describing what the file contains, and name the file accordingly. Use <a href="https://en.wikipedia.org/wiki/Camel_case" id="-q3d1qe_50" data-external="true" rel="noopener noreferrer" target="_blank">upper camel case</a>, where the first letter of each word is capitalized. For example, <code class="code" id="-q3d1qe_51">ProcessDeclarations.kt</code>.</p><p id="-q3d1qe_47">The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as <code class="code" id="-q3d1qe_52">Util</code> in file names.</p><section class="chapter"><h4 id="multiplatform-projects" data-toc="multiplatform-projects">Multiplatform projects</h4><p id="-q3d1qe_53">In multiplatform projects, files with top-level declarations in platform-specific source sets should have a suffix associated with the name of the source set. For example:</p><ul class="list _bullet" id="-q3d1qe_54"><li class="list__item" id="-q3d1qe_57"><p id="-q3d1qe_60"><span class="control" id="-q3d1qe_61">jvm</span>Main/kotlin/Platform. <span class="control" id="-q3d1qe_62">jvm</span> .kt</p></li><li class="list__item" id="-q3d1qe_58"><p id="-q3d1qe_63"><span class="control" id="-q3d1qe_64">android</span>Main/kotlin/Platform. <span class="control" id="-q3d1qe_65">android</span> .kt</p></li><li class="list__item" id="-q3d1qe_59"><p id="-q3d1qe_66"><span class="control" id="-q3d1qe_67">ios</span>Main/kotlin/Platform. <span class="control" id="-q3d1qe_68">ios</span> .kt</p></li></ul><p id="-q3d1qe_55">As for the common source set, files with top-level declarations should not have a suffix. For example, <code class="code" id="-q3d1qe_69">commonMain/kotlin/Platform.kt</code>.</p><section class="chapter"><div class="collapse"><div class="collapse__title"><h5 id="technical-details" data-toc="technical-details">Technical details</h5></div><div class="collapse__content"><p id="-q3d1qe_70">We recommend following this file naming scheme in multiplatform projects due to JVM limitations: it doesn't allow top-level members (functions, properties).</p><p id="-q3d1qe_71">To work around this, the Kotlin JVM compiler creates wrapper classes (so-called &quot;file facades&quot;) that contain top-level member declarations. File facades have an internal name derived from the file name.</p><p id="-q3d1qe_72">In turn, JVM doesn't allow several classes with the same fully qualified name (FQN). This might lead to situations when a Kotlin project cannot be compiled to JVM:</p><div class="code-block" data-lang="none">
root
|- commonMain/kotlin/myPackage/Platform.kt // contains 'fun count() { }'
|- jvmMain/kotlin/myPackage/Platform.kt // contains 'fun multiply() { }'
</div><p id="-q3d1qe_74">Here both <code class="code" id="-q3d1qe_77">Platform.kt</code> files are in the same package, so the Kotlin JVM compiler produces two file facades, both of which have FQN <code class="code" id="-q3d1qe_78">myPackage.PlatformKt</code>. This produces the &quot;Duplicate JVM classes&quot; error.</p><p id="-q3d1qe_75">The simplest way to avoid that is renaming one of the files according to the guideline above. This naming scheme helps avoid clashes while retaining code readability.</p><aside class="prompt" data-type="tip" data-title="" id="-q3d1qe_76"><p id="-q3d1qe_79">There are two scenarios where these recommendations may seem redundant, but we still advise to follow them:</p><ul class="list _bullet" id="-q3d1qe_80"><li class="list__item" id="-q3d1qe_81"><p id="-q3d1qe_83">Non-JVM platforms don't have issues with duplicating file facades. However, this naming scheme can help you keep file naming consistent.</p></li><li class="list__item" id="-q3d1qe_82"><p id="-q3d1qe_84">On JVM, if source files don't have top-level declarations, the file facades aren't generated, and you won't face naming clashes.</p><p id="-q3d1qe_85">However, this naming scheme can help you avoid situations when a simple refactoring or an addition could include a top-level function and result in the same &quot;Duplicate JVM classes&quot; error.</p></li></ul></aside></div></div></section></section></section><section class="chapter"><h3 id="source-file-organization" data-toc="source-file-organization">Source file organization</h3><p id="-q3d1qe_86">Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines).</p><p id="-q3d1qe_87">In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Avoid creating files just to hold all extensions of some class.</p></section><section class="chapter"><h3 id="class-layout" data-toc="class-layout">Class layout</h3><p id="-q3d1qe_88">The contents of a class should go in the following order:</p><ol class="list _decimal" id="-q3d1qe_89" type="1"><li class="list__item" id="-q3d1qe_92"><p id="-q3d1qe_96">Property declarations and initializer blocks</p></li><li class="list__item" id="-q3d1qe_93"><p id="-q3d1qe_97">Secondary constructors</p></li><li class="list__item" id="-q3d1qe_94"><p id="-q3d1qe_98">Method declarations</p></li><li class="list__item" id="-q3d1qe_95"><p id="-q3d1qe_99">Companion object</p></li></ol><p id="-q3d1qe_90">Do not sort the method declarations alphabetically or by visibility, and do not separate regular methods from extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can follow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it.</p><p id="-q3d1qe_91">Put nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't referenced inside the class, put them in the end, after the companion object.</p></section><section class="chapter"><h3 id="interface-implementation-layout" data-toc="interface-implementation-layout">Interface implementation layout</h3><p id="-q3d1qe_100">When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation).</p></section><section class="chapter"><h3 id="overload-layout" data-toc="overload-layout">Overload layout</h3><p id="-q3d1qe_101">Always put overloads next to each other in a class.</p></section></section><section class="chapter"><h2 id="naming-rules" data-toc="naming-rules">Naming rules</h2><p id="-q3d1qe_102">Package and class naming rules in Kotlin are quite simple:</p><ul class="list _bullet" id="-q3d1qe_103"><li class="list__item" id="-q3d1qe_110"><p id="-q3d1qe_112">Names of packages are always lowercase and do not use underscores (<code class="code" id="-q3d1qe_113">org.example.project</code>). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case (<code class="code" id="-q3d1qe_114">org.example.myProject</code>).</p></li><li class="list__item" id="-q3d1qe_111"><p id="-q3d1qe_115">Names of classes and objects use upper camel case:</p></li></ul><div class="code-block" data-lang="kotlin">
open class DeclarationProcessor { /*...*/ }

object EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }
</div><section class="chapter"><h3 id="function-names" data-toc="function-names">Function names</h3><p id="-q3d1qe_116">Names of functions, properties and local variables start with a lowercase letter and use camel case with no underscores:</p><div class="code-block" data-lang="kotlin">
fun processDeclarations() { /*...*/ }
var declarationCount = 1
</div><p id="-q3d1qe_118">Exception: factory functions used to create instances of classes can have the same name as the abstract return type:</p><div class="code-block" data-lang="kotlin">
interface Foo { /*...*/ }

class FooImpl : Foo { /*...*/ }

fun Foo(): Foo { return FooImpl() }
</div></section><section class="chapter"><h3 id="names-for-test-methods" data-toc="names-for-test-methods">Names for test methods</h3><p id="-q3d1qe_120">In tests (and <span class="control" id="-q3d1qe_122">only</span> in tests), you can use method names with spaces enclosed in backticks. Note that such method names are only supported by Android runtime from API level 30. Underscores in method names are also allowed in test code.</p><div class="code-block" data-lang="kotlin">
class MyTestCase {
     @Test fun `ensure everything works`() { /*...*/ }
     
     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }
}
</div></section><section class="chapter"><h3 id="property-names" data-toc="property-names">Property names</h3><p id="-q3d1qe_123">Names of constants (properties marked with <code class="code" id="-q3d1qe_130">const</code>, or top-level or object <code class="code" id="-q3d1qe_131">val</code> properties with no custom <code class="code" id="-q3d1qe_132">get</code> function that hold deeply immutable data) should use all uppercase, underscore-separated names following the <a href="https://en.wikipedia.org/wiki/Snake_case" id="-q3d1qe_133" data-external="true" rel="noopener noreferrer" target="_blank">screaming snake case</a> convention:</p><div class="code-block" data-lang="kotlin">
const val MAX_COUNT = 8
val USER_NAME_FIELD = &quot;UserName&quot;
</div><p id="-q3d1qe_125">Names of top-level or object properties which hold objects with behavior or mutable data should use camel case names:</p><div class="code-block" data-lang="kotlin">
val mutableCollection: MutableSet&lt;String&gt; = HashSet()
</div><p id="-q3d1qe_127">Names of properties holding references to singleton objects can use the same naming style as <code class="code" id="-q3d1qe_134">object</code> declarations:</p><div class="code-block" data-lang="kotlin">
val PersonComparator: Comparator&lt;Person&gt; = /*...*/
</div><p id="-q3d1qe_129">For enum constants, it's OK to use either all uppercase, underscore-separated (<a href="https://en.wikipedia.org/wiki/Snake_case" id="-q3d1qe_135" data-external="true" rel="noopener noreferrer" target="_blank">screaming snake case</a>) names (<code class="code" id="-q3d1qe_136">enum class Color { RED, GREEN }</code>) or upper camel case names, depending on the usage.</p></section><section class="chapter"><h3 id="names-for-backing-properties" data-toc="names-for-backing-properties">Names for backing properties</h3><p id="-q3d1qe_137">If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property:</p><div class="code-block" data-lang="kotlin">
class C {
    private val _elementList = mutableListOf&lt;Element&gt;()

    val elementList: List&lt;Element&gt;
         get() = _elementList
}
</div></section><section class="chapter"><h3 id="choose-good-names" data-toc="choose-good-names">Choose good names</h3><p id="-q3d1qe_139">The name of a class is usually a noun or a noun phrase explaining what the class <span class="emphasis" id="-q3d1qe_144">is</span>: <code class="code" id="-q3d1qe_145">List</code>, <code class="code" id="-q3d1qe_146">PersonReader</code>.</p><p id="-q3d1qe_140">The name of a method is usually a verb or a verb phrase saying what the method <span class="emphasis" id="-q3d1qe_147">does</span>: <code class="code" id="-q3d1qe_148">close</code>, <code class="code" id="-q3d1qe_149">readPersons</code>. The name should also suggest if the method is mutating the object or returning a new one. For instance <code class="code" id="-q3d1qe_150">sort</code> is sorting a collection in place, while <code class="code" id="-q3d1qe_151">sorted</code> is returning a sorted copy of the collection.</p><p id="-q3d1qe_141">The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (<code class="code" id="-q3d1qe_152">Manager</code>, <code class="code" id="-q3d1qe_153">Wrapper</code>) in names.</p><p id="-q3d1qe_142">When using an acronym as part of a declaration name, follow these rules:</p><ul class="list _bullet" id="-q3d1qe_143"><li class="list__item" id="-q3d1qe_154"><p id="-q3d1qe_156">For two-letter acronyms, use uppercase for both letters. For example, <code class="code" id="-q3d1qe_157">IOStream</code>.</p></li><li class="list__item" id="-q3d1qe_155"><p id="-q3d1qe_158">For acronyms longer than two letters, capitalize only the first letter. For example, <code class="code" id="-q3d1qe_159">XmlFormatter</code> or <code class="code" id="-q3d1qe_160">HttpInputStream</code>.</p></li></ul></section></section><section class="chapter"><h2 id="formatting" data-toc="formatting">Formatting</h2><section class="chapter"><h3 id="indentation" data-toc="indentation">Indentation</h3><p id="-q3d1qe_176">Use four spaces for indentation. Do not use tabs.</p><p id="-q3d1qe_177">For curly braces, put the opening brace at the end of the line where the construct begins, and the closing brace on a separate line aligned horizontally with the opening construct.</p><div class="code-block" data-lang="kotlin">
if (elements != null) {
    for (element in elements) {
        // ...
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="-q3d1qe_179"><p id="-q3d1qe_180">In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</p></aside></section><section class="chapter"><h3 id="horizontal-whitespace" data-toc="horizontal-whitespace">Horizontal whitespace</h3><ul class="list _bullet" id="-q3d1qe_181"><li class="list__item" id="-q3d1qe_185"><p id="-q3d1qe_189">Put spaces around binary operators (<code class="code" id="-q3d1qe_190">a + b</code>). Exception: don't put spaces around the &quot;range to&quot; operator (<code class="code" id="-q3d1qe_191">0..i</code>).</p></li><li class="list__item" id="-q3d1qe_186"><p id="-q3d1qe_192">Do not put spaces around unary operators (<code class="code" id="-q3d1qe_193">a++</code>).</p></li><li class="list__item" id="-q3d1qe_187"><p id="-q3d1qe_194">Put spaces between control flow keywords (<code class="code" id="-q3d1qe_195">if</code>, <code class="code" id="-q3d1qe_196">when</code>, <code class="code" id="-q3d1qe_197">for</code>, and <code class="code" id="-q3d1qe_198">while</code>) and the corresponding opening parenthesis.</p></li><li class="list__item" id="-q3d1qe_188"><p id="-q3d1qe_199">Do not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call.</p></li></ul><div class="code-block" data-lang="kotlin">
class A(val x: Int)

fun foo(x: Int) { ... }

fun bar() {
    foo(1)
}
</div><ul class="list _bullet" id="-q3d1qe_183"><li class="list__item" id="-q3d1qe_200"><p id="-q3d1qe_206">Never put a space after <code class="code" id="-q3d1qe_207">(</code>, <code class="code" id="-q3d1qe_208">[</code>, or before <code class="code" id="-q3d1qe_209">]</code>, <code class="code" id="-q3d1qe_210">)</code>.</p></li><li class="list__item" id="-q3d1qe_201"><p id="-q3d1qe_211">Never put a space around <code class="code" id="-q3d1qe_212">.</code> or <code class="code" id="-q3d1qe_213">?.</code>: <code class="code" id="-q3d1qe_214">foo.bar().filter { it &gt; 2 }.joinToString()</code>, <code class="code" id="-q3d1qe_215">foo?.bar()</code>.</p></li><li class="list__item" id="-q3d1qe_202"><p id="-q3d1qe_216">Put a space after <code class="code" id="-q3d1qe_217">//</code>: <code class="code" id="-q3d1qe_218">// This is a comment</code>.</p></li><li class="list__item" id="-q3d1qe_203"><p id="-q3d1qe_219">Do not put spaces around angle brackets used to specify type parameters: <code class="code" id="-q3d1qe_220">class Map&lt;K, V&gt; { ... }</code>.</p></li><li class="list__item" id="-q3d1qe_204"><p id="-q3d1qe_221">Do not put spaces around <code class="code" id="-q3d1qe_222">::</code>: <code class="code" id="-q3d1qe_223">Foo::class</code>, <code class="code" id="-q3d1qe_224">String::length</code>.</p></li><li class="list__item" id="-q3d1qe_205"><p id="-q3d1qe_225">Do not put a space before <code class="code" id="-q3d1qe_226">?</code> used to mark a nullable type: <code class="code" id="-q3d1qe_227">String?</code>.</p></li></ul><p id="-q3d1qe_184">As a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length should not affect the formatting of either the declaration or any of the usages.</p></section><section class="chapter"><h3 id="colon" data-toc="colon">Colon</h3><p id="-q3d1qe_228">Put a space before <code class="code" id="-q3d1qe_233">:</code> in the following scenarios:</p><ul class="list _bullet" id="-q3d1qe_229"><li class="list__item" id="-q3d1qe_234"><p id="-q3d1qe_237">When it's used to separate a type and a supertype.</p></li><li class="list__item" id="-q3d1qe_235"><p id="-q3d1qe_238">When delegating to a superclass constructor or a different constructor of the same class.</p></li><li class="list__item" id="-q3d1qe_236"><p id="-q3d1qe_239">After the <code class="code" id="-q3d1qe_240">object</code> keyword.</p></li></ul><p id="-q3d1qe_230">Don't put a space before <code class="code" id="-q3d1qe_241">:</code> when it separates a declaration and its type.</p><p id="-q3d1qe_231">Always put a space after <code class="code" id="-q3d1qe_242">:</code>.</p><div class="code-block" data-lang="kotlin">
abstract class Foo&lt;out T : Any&gt; : IFoo {
    abstract fun foo(a: Int): T
}

class FooImpl : Foo() {
    constructor(x: String) : this(x) { /*...*/ }
    
    val x = object : IFoo { /*...*/ } 
} 
</div></section><section class="chapter"><h3 id="class-headers" data-toc="class-headers">Class headers</h3><p id="-q3d1qe_243">Classes with a few primary constructor parameters can be written in a single line:</p><div class="code-block" data-lang="kotlin">
class Person(id: Int, name: String)
</div><p id="-q3d1qe_245">Classes with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation. Also, the closing parenthesis should be on a new line. If you use inheritance, the superclass constructor call, or the list of implemented interfaces should be located on the same line as the parenthesis:</p><div class="code-block" data-lang="kotlin">
class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name) { /*...*/ }
</div><p id="-q3d1qe_247">For multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line:</p><div class="code-block" data-lang="kotlin">
class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name),
    KotlinMaker { /*...*/ }
</div><p id="-q3d1qe_249">For classes with a long supertype list, put a line break after the colon and align all supertype names horizontally:</p><div class="code-block" data-lang="kotlin">
class MyFavouriteVeryLongClassHolder :
    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),
    SomeOtherInterface,
    AndAnotherOne {

    fun foo() { /*...*/ }
}
</div><p id="-q3d1qe_251">To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</p><div class="code-block" data-lang="kotlin">
class MyFavouriteVeryLongClassHolder :
    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),
    SomeOtherInterface,
    AndAnotherOne 
{
    fun foo() { /*...*/ }
}
</div><p id="-q3d1qe_253">Use regular indent (four spaces) for constructor parameters. This ensures that properties declared in the primary constructor have the same indentation as properties declared in the body of a class.</p></section><section class="chapter"><h3 id="modifiers-order" data-toc="modifiers-order">Modifiers order</h3><p id="-q3d1qe_254">If a declaration has multiple modifiers, always put them in the following order:</p><div class="code-block" data-lang="kotlin">
public / protected / private / internal
expect / actual
final / open / abstract / sealed / const
external
override
lateinit
tailrec
vararg
suspend
inner
enum / annotation / fun // as a modifier in `fun interface` 
companion
inline / value
infix
operator
data
</div><p id="-q3d1qe_256">Place all annotations before modifiers:</p><div class="code-block" data-lang="kotlin">
@Named(&quot;Foo&quot;)
private val foo: Foo
</div><p id="-q3d1qe_258">Unless you're working on a library, omit redundant modifiers (for example, <code class="code" id="-q3d1qe_259">public</code>).</p></section><section class="chapter"><h3 id="annotations" data-toc="annotations">Annotations</h3><p id="-q3d1qe_260">Place annotations on separate lines before the declaration to which they are attached, and with the same indentation:</p><div class="code-block" data-lang="kotlin">
@Target(AnnotationTarget.PROPERTY)
annotation class JsonExclude
</div><p id="-q3d1qe_262">Annotations without arguments may be placed on the same line:</p><div class="code-block" data-lang="kotlin">
@JsonExclude @JvmField
var x: String
</div><p id="-q3d1qe_264">A single annotation without arguments may be placed on the same line as the corresponding declaration:</p><div class="code-block" data-lang="kotlin">
@Test fun foo() { /*...*/ }
</div></section><section class="chapter"><h3 id="file-annotations" data-toc="file-annotations">File annotations</h3><p id="-q3d1qe_266">File annotations are placed after the file comment (if any), before the <code class="code" id="-q3d1qe_268">package</code> statement, and are separated from <code class="code" id="-q3d1qe_269">package</code> with a blank line (to emphasize the fact that they target the file and not the package).</p><div class="code-block" data-lang="kotlin">
/** License, copyright and whatever */
@file:JvmName(&quot;FooBar&quot;)

package foo.bar
</div></section><section class="chapter"><h3 id="functions" data-toc="functions">Functions</h3><p id="-q3d1qe_270">If the function signature doesn't fit on a single line, use the following syntax:</p><div class="code-block" data-lang="kotlin">
fun longMethodName(
    argument: ArgumentType = defaultValue,
    argument2: AnotherArgumentType,
): ReturnType {
    // body
}
</div><p id="-q3d1qe_272">Use regular indent (four spaces) for function parameters. It helps ensure consistency with constructor parameters.</p><p id="-q3d1qe_273">Prefer using an expression body for functions with the body consisting of a single expression.</p><div class="code-block" data-lang="kotlin">
fun foo(): Int {     // bad
    return 1 
}

fun foo() = 1        // good
</div></section><section class="chapter"><h3 id="expression-bodies" data-toc="expression-bodies">Expression bodies</h3><p id="-q3d1qe_275">If the function has an expression body whose first line doesn't fit on the same line as the declaration, put the <code class="code" id="-q3d1qe_277">=</code> sign on the first line and indent the expression body by four spaces.</p><div class="code-block" data-lang="kotlin">
fun f(x: String, y: String, z: String) =
    veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)
</div></section><section class="chapter"><h3 id="properties" data-toc="properties">Properties</h3><p id="-q3d1qe_278">For very simple read-only properties, consider one-line formatting:</p><div class="code-block" data-lang="kotlin">
val isEmpty: Boolean get() = size == 0
</div><p id="-q3d1qe_280">For more complex properties, always put <code class="code" id="-q3d1qe_284">get</code> and <code class="code" id="-q3d1qe_285">set</code> keywords on separate lines:</p><div class="code-block" data-lang="kotlin">
val foo: String
    get() { /*...*/ }
</div><p id="-q3d1qe_282">For properties with an initializer, if the initializer is long, add a line break after the <code class="code" id="-q3d1qe_286">=</code> sign and indent the initializer by four spaces:</p><div class="code-block" data-lang="kotlin">
private val defaultCharset: Charset? =
    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)
</div></section><section class="chapter"><h3 id="control-flow-statements" data-toc="control-flow-statements">Control flow statements</h3><p id="-q3d1qe_287">If the condition of an <code class="code" id="-q3d1qe_296">if</code> or <code class="code" id="-q3d1qe_297">when</code> statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to the statement start. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</p><div class="code-block" data-lang="kotlin">
if (!component.isSyncing &amp;&amp;
    !hasAnyKotlinRuntimeInScope(module)
) {
    return createKotlinNotConfiguredPanel(module)
}
</div><p id="-q3d1qe_289">This helps align the condition and statement bodies.</p><p id="-q3d1qe_290">Put the <code class="code" id="-q3d1qe_298">else</code>, <code class="code" id="-q3d1qe_299">catch</code>, <code class="code" id="-q3d1qe_300">finally</code> keywords, as well as the <code class="code" id="-q3d1qe_301">while</code> keyword of a <code class="code" id="-q3d1qe_302">do-while</code> loop, on the same line as the preceding curly brace:</p><div class="code-block" data-lang="kotlin">
if (condition) {
    // body
} else {
    // else part
}

try {
    // body
} finally {
    // cleanup
}
</div><p id="-q3d1qe_292">In a <code class="code" id="-q3d1qe_303">when</code> statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</p><div class="code-block" data-lang="kotlin">
private fun parsePropertyValue(propName: String, token: Token) {
    when (token) {
        is Token.ValueToken -&gt;
            callback.visitValue(propName, token.value)

        Token.LBRACE -&gt; { // ...
        }
    }
}
</div><p id="-q3d1qe_294">Put short branches on the same line as the condition, without braces.</p><div class="code-block" data-lang="kotlin">
when (foo) {
    true -&gt; bar() // good
    false -&gt; { baz() } // bad
}
</div></section><section class="chapter"><h3 id="method-calls" data-toc="method-calls">Method calls</h3><p id="-q3d1qe_304">In long argument lists, put a line break after the opening parenthesis. Indent arguments by four spaces. Group multiple closely related arguments on the same line.</p><div class="code-block" data-lang="kotlin">
drawSquare(
    x = 10, y = 10,
    width = 100, height = 100,
    fill = true
)
</div><p id="-q3d1qe_306">Put spaces around the <code class="code" id="-q3d1qe_307">=</code> sign separating the argument name and value.</p></section><section class="chapter"><h3 id="wrap-chained-calls" data-toc="wrap-chained-calls">Wrap chained calls</h3><p id="-q3d1qe_308">When wrapping chained calls, put the <code class="code" id="-q3d1qe_311">.</code> character or the <code class="code" id="-q3d1qe_312">?.</code> operator on the next line, with a single indent:</p><div class="code-block" data-lang="kotlin">
val anchor = owner
    ?.firstChild!!
    .siblings(forward = true)
    .dropWhile { it is PsiComment || it is PsiWhiteSpace }
</div><p id="-q3d1qe_310">The first call in the chain should usually have a line break before it, but it's OK to omit it if the code makes more sense that way.</p></section><section class="chapter"><h3 id="lambdas" data-toc="lambdas">Lambdas</h3><p id="-q3d1qe_313">In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, pass it outside parentheses whenever possible.</p><div class="code-block" data-lang="kotlin">
list.filter { it &gt; 10 }
</div><p id="-q3d1qe_315">If assigning a label for a lambda, do not put a space between the label and the opening curly brace:</p><div class="code-block" data-lang="kotlin">
fun foo() {
    ints.forEach lit@{
        // ...
    }
}
</div><p id="-q3d1qe_317">When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</p><div class="code-block" data-lang="kotlin">
appendCommaSeparated(properties) { prop -&gt;
    val propertyValue = prop.get(obj)  // ...
}
</div><p id="-q3d1qe_319">If the parameter list is too long to fit on a line, put the arrow on a separate line:</p><div class="code-block" data-lang="kotlin">
foo {
   context: Context,
   environment: Env
   -&gt;
   context.configureEnv(environment)
}
</div></section><section class="chapter"><h3 id="trailing-commas" data-toc="trailing-commas">Trailing commas</h3><p id="-q3d1qe_321">A trailing comma is a comma symbol after the last item in a series of elements:</p><div class="code-block" data-lang="kotlin">
class Person(
    val firstName: String,
    val lastName: String,
    val age: Int, // trailing comma
)
</div><p id="-q3d1qe_323">Using trailing commas has several benefits:</p><ul class="list _bullet" id="-q3d1qe_324"><li class="list__item" id="-q3d1qe_339"><p id="-q3d1qe_342">It makes version-control diffs cleaner &ndash; as all the focus is on the changed value.</p></li><li class="list__item" id="-q3d1qe_340"><p id="-q3d1qe_343">It makes it easy to add and reorder elements &ndash; there is no need to add or delete the comma if you manipulate elements.</p></li><li class="list__item" id="-q3d1qe_341"><p id="-q3d1qe_344">It simplifies code generation, for example, for object initializers. The last element can also have a comma.</p></li></ul><p id="-q3d1qe_325">Trailing commas are entirely optional &ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</p><p id="-q3d1qe_326">To enable trailing commas in the IntelliJ IDEA formatter, go to <span class="control" id="-q3d1qe_345">Settings/Preferences | Editor | Code Style | Kotlin</span>, open the <span class="control" id="-q3d1qe_346">Other</span> tab and select the <span class="control" id="-q3d1qe_347">Use trailing comma</span> option.</p><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="enumerations" data-toc="enumerations">Enumerations</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
enum class Direction {
    NORTH,
    SOUTH,
    WEST,
    EAST, // trailing comma
}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="value-arguments" data-toc="value-arguments">Value arguments</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
fun shift(x: Int, y: Int) { /*...*/ }
shift(
    25,
    20, // trailing comma
)
val colors = listOf(
    &quot;red&quot;,
    &quot;green&quot;,
    &quot;blue&quot;, // trailing comma
)
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="class-properties-and-parameters" data-toc="class-properties-and-parameters">Class properties and parameters</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
class Customer(
    val name: String,
    val lastName: String, // trailing comma
)
class Customer(
    val name: String,
    lastName: String, // trailing comma
)
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="function-value-parameters" data-toc="function-value-parameters">Function value parameters</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
fun powerOf(
    number: Int, 
    exponent: Int, // trailing comma
) { /*...*/ }
constructor(
    x: Comparable&lt;Number&gt;,
    y: Iterable&lt;Number&gt;, // trailing comma
) {}
fun print(
    vararg quantity: Int,
    description: String, // trailing comma
) {}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="parameters-with-optional-type-including-setters" data-toc="parameters-with-optional-type-including-setters">Parameters with optional type (including setters)</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
val sum: (Int, Int, Int) -&gt; Int = fun(
    x,
    y,
    z, // trailing comma
): Int {
    return x + y + x
}
println(sum(8, 8, 8))
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="indexing-suffix" data-toc="indexing-suffix">Indexing suffix</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
class Surface {
    operator fun get(x: Int, y: Int) = 2 * x + 4 * y - 10
}
fun getZValue(mySurface: Surface, xValue: Int, yValue: Int) =
    mySurface[
        xValue,
        yValue, // trailing comma
    ]
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="parameters-in-lambdas" data-toc="parameters-in-lambdas">Parameters in lambdas</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
fun main() {
    val x = {
            x: Comparable&lt;Number&gt;,
            y: Iterable&lt;Number&gt;, // trailing comma
        -&gt;
        println(&quot;1&quot;)
    }
    println(x)
}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="when-entry" data-toc="when-entry">when entry</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
fun isReferenceApplicable(myReference: KClass&lt;*&gt;) = when (myReference) {
    Comparable::class,
    Iterable::class,
    String::class, // trailing comma
        -&gt; true
    else -&gt; false
}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="collection-literals-in-annotations" data-toc="collection-literals-in-annotations">Collection literals (in annotations)</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
annotation class ApplicableFor(val services: Array&lt;String&gt;)
@ApplicableFor([
    &quot;serializer&quot;,
    &quot;balancer&quot;,
    &quot;database&quot;,
    &quot;inMemoryCache&quot;, // trailing comma
])
fun run() {}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="type-arguments" data-toc="type-arguments">Type arguments</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
fun &lt;T1, T2&gt; foo() {}
fun main() {
    foo&lt;
            Comparable&lt;Number&gt;,
            Iterable&lt;Number&gt;, // trailing comma
            &gt;()
}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="type-parameters" data-toc="type-parameters">Type parameters</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
class MyMap&lt;
        MyKey,
        MyValue, // trailing comma
        &gt; {}
</div></div></div></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="destructuring-declarations" data-toc="destructuring-declarations">Destructuring declarations</h4></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
data class Car(val manufacturer: String, val model: String, val year: Int)
val myCar = Car(&quot;Tesla&quot;, &quot;Y&quot;, 2019)
val (
    manufacturer,
    model,
    year, // trailing comma
) = myCar
val cars = listOf&lt;Car&gt;()
fun printMeanValue() {
    var meanValue: Int = 0
    for ((
        _,
        _,
        year, // trailing comma
    ) in cars) {
        meanValue += year
    }
    println(meanValue/cars.size)
}
printMeanValue()
</div></div></div></section></section></section><section class="chapter"><h2 id="documentation-comments" data-toc="documentation-comments">Documentation comments</h2><p id="-q3d1qe_360">For longer documentation comments, place the opening <code class="code" id="-q3d1qe_366">/**</code> on a separate line and begin each subsequent line with an asterisk:</p><div class="code-block" data-lang="kotlin">
/**
 * This is a documentation comment
 * on multiple lines.
 */
</div><p id="-q3d1qe_362">Short comments can be placed on a single line:</p><div class="code-block" data-lang="kotlin">
/** This is a short documentation comment. */
</div><p id="-q3d1qe_364">Generally, avoid using <code class="code" id="-q3d1qe_367">@param</code> and <code class="code" id="-q3d1qe_368">@return</code> tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use <code class="code" id="-q3d1qe_369">@param</code> and <code class="code" id="-q3d1qe_370">@return</code> only when a lengthy description is required which doesn't fit into the flow of the main text.</p><div class="code-block" data-lang="kotlin">
// Avoid doing this:

/**
 * Returns the absolute value of the given number.
 * @param number The number to return the absolute value for.
 * @return The absolute value.
 */
fun abs(number: Int): Int { /*...*/ }

// Do this instead:

/**
 * Returns the absolute value of the given [number].
 */
fun abs(number: Int): Int { /*...*/ }
</div></section><section class="chapter"><h2 id="avoid-redundant-constructs" data-toc="avoid-redundant-constructs">Avoid redundant constructs</h2><p id="-q3d1qe_371">In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</p><section class="chapter"><h3 id="unit-return-type" data-toc="unit-return-type">Unit return type</h3><p id="-q3d1qe_375">If a function returns Unit, the return type should be omitted:</p><div class="code-block" data-lang="kotlin">
fun foo() { // &quot;: Unit&quot; is omitted here

}
</div></section><section class="chapter"><h3 id="semicolons" data-toc="semicolons">Semicolons</h3><p id="-q3d1qe_377">Omit semicolons whenever possible.</p></section><section class="chapter"><h3 id="string-templates" data-toc="string-templates">String templates</h3><p id="-q3d1qe_378">Don't use curly braces when inserting a simple variable into a string template. Use curly braces only for longer expressions:</p><div class="code-block" data-lang="kotlin">
println(&quot;$name has ${children.size} children&quot;)
</div><p id="-q3d1qe_380">Use <a href="strings.html#multi-dollar-string-interpolation" id="-q3d1qe_382">multi-dollar string interpolation</a> to treat the dollar sign chars <code class="code" id="-q3d1qe_383">$</code> as string literals:</p><div class="code-block" data-lang="kotlin">
val KClass&lt;*&gt;.jsonSchema : String
get() = $$&quot;&quot;&quot;
    {
      &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
      &quot;$id&quot;: &quot;https://example.com/product.schema.json&quot;,
      &quot;$dynamicAnchor&quot;: &quot;meta&quot;,
      &quot;title&quot;: &quot;$${simpleName ?: qualifiedName ?: &quot;unknown&quot;}&quot;,
      &quot;type&quot;: &quot;object&quot;
    }
    &quot;&quot;&quot;
</div></section></section><section class="chapter"><h2 id="idiomatic-use-of-language-features" data-toc="idiomatic-use-of-language-features">Idiomatic use of language features</h2><section class="chapter"><h3 id="immutability" data-toc="immutability">Immutability</h3><p id="-q3d1qe_403">Prefer using immutable data to mutable. Always declare local variables and properties as <code class="code" id="-q3d1qe_406">val</code> rather than <code class="code" id="-q3d1qe_407">var</code> if they are not modified after initialization.</p><p id="-q3d1qe_404">Always use immutable collection interfaces (<code class="code" id="-q3d1qe_408">Collection</code>, <code class="code" id="-q3d1qe_409">List</code>, <code class="code" id="-q3d1qe_410">Set</code>, <code class="code" id="-q3d1qe_411">Map</code>) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible:</p><div class="code-block" data-lang="kotlin">
// Bad: use of a mutable collection type for value which will not be mutated
fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... }

// Good: immutable collection type used instead
fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... }

// Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type
val allowedValues = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

// Good: listOf() returns List&lt;T&gt;
val allowedValues = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</div></section><section class="chapter"><h3 id="default-parameter-values" data-toc="default-parameter-values">Default parameter values</h3><p id="-q3d1qe_412">Prefer declaring functions with default parameter values to declaring overloaded functions.</p><div class="code-block" data-lang="kotlin">
// Bad
fun foo() = foo(&quot;a&quot;)
fun foo(a: String) { /*...*/ }

// Good
fun foo(a: String = &quot;a&quot;) { /*...*/ }
</div></section><section class="chapter"><h3 id="type-aliases" data-toc="type-aliases">Type aliases</h3><p id="-q3d1qe_414">If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</p><div class="code-block" data-lang="kotlin">
typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unit
typealias PersonIndex = Map&lt;String, Person&gt;
</div><p id="-q3d1qe_416">If you use a private or internal type alias for avoiding name collision, prefer the <code class="code" id="-q3d1qe_417">import ... as ...</code> mentioned in <a href="packages.html" id="-q3d1qe_418">Packages and Imports</a>.</p></section><section class="chapter"><h3 id="lambda-parameters" data-toc="lambda-parameters">Lambda parameters</h3><p id="-q3d1qe_419">In lambdas which are short and not nested, it's recommended to use the <code class="code" id="-q3d1qe_420">it</code> convention instead of declaring the parameter explicitly. In nested lambdas with parameters, always declare parameters explicitly.</p></section><section class="chapter"><h3 id="returns-in-a-lambda" data-toc="returns-in-a-lambda">Returns in a lambda</h3><p id="-q3d1qe_421">Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that's not possible or not clear enough, consider converting the lambda into an anonymous function.</p><p id="-q3d1qe_422">Do not use a labeled return for the last statement in a lambda.</p></section><section class="chapter"><h3 id="named-arguments" data-toc="named-arguments">Named arguments</h3><p id="-q3d1qe_423">Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of <code class="code" id="-q3d1qe_425">Boolean</code> type, unless the meaning of all parameters is absolutely clear from context.</p><div class="code-block" data-lang="kotlin">
drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)
</div></section><section class="chapter"><h3 id="conditional-statements" data-toc="conditional-statements">Conditional statements</h3><p id="-q3d1qe_426">Prefer using the expression form of <code class="code" id="-q3d1qe_432">try</code>, <code class="code" id="-q3d1qe_433">if</code>, and <code class="code" id="-q3d1qe_434">when</code>.</p><div class="code-block" data-lang="kotlin">
return if (x) foo() else bar()
</div><div class="code-block" data-lang="kotlin">
return when(x) {
    0 -&gt; &quot;zero&quot;
    else -&gt; &quot;nonzero&quot;
}
</div><p id="-q3d1qe_429">The above is preferable to:</p><div class="code-block" data-lang="kotlin">
if (x)
    return foo()
else
    return bar()
</div><div class="code-block" data-lang="kotlin">
when(x) {
    0 -&gt; return &quot;zero&quot;
    else -&gt; return &quot;nonzero&quot;
}    
</div></section><section class="chapter"><h3 id="if-versus-when" data-toc="if-versus-when">if versus when</h3><p id="-q3d1qe_435">Prefer using <code class="code" id="-q3d1qe_440">if</code> for binary conditions instead of <code class="code" id="-q3d1qe_441">when</code>. For example, use this syntax with <code class="code" id="-q3d1qe_442">if</code>:</p><div class="code-block" data-lang="kotlin">
if (x == null) ... else ...
</div><p id="-q3d1qe_437">Instead of this one with <code class="code" id="-q3d1qe_443">when</code>:</p><div class="code-block" data-lang="kotlin">
when (x) {
    null -&gt; // ...
    else -&gt; // ...
}
</div><p id="-q3d1qe_439">Prefer using <code class="code" id="-q3d1qe_444">when</code> if there are three or more options.</p></section><section class="chapter"><h3 id="guard-conditions-in-when-expression" data-toc="guard-conditions-in-when-expression">Guard conditions in when expression</h3><p id="-q3d1qe_445">Use parentheses when combining multiple boolean expressions in <code class="code" id="-q3d1qe_449">when</code> expressions or statements with <a href="control-flow.html#guard-conditions-in-when-expressions" id="-q3d1qe_450">guard conditions</a>:</p><div class="code-block" data-lang="kotlin">
when (status) {
    is Status.Ok if (status.info.isEmpty() || status.info.id == null) -&gt; &quot;no information&quot;
}
</div><p id="-q3d1qe_447">Instead of:</p><div class="code-block" data-lang="kotlin">
when (status) {
    is Status.Ok if status.info.isEmpty() || status.info.id == null -&gt; &quot;no information&quot;
}
</div></section><section class="chapter"><h3 id="nullable-boolean-values-in-conditions" data-toc="nullable-boolean-values-in-conditions">Nullable Boolean values in conditions</h3><p id="-q3d1qe_451">If you need to use a nullable <code class="code" id="-q3d1qe_452">Boolean</code> in a conditional statement, use <code class="code" id="-q3d1qe_453">if (value == true)</code> or <code class="code" id="-q3d1qe_454">if (value == false)</code> checks.</p></section><section class="chapter"><h3 id="loops" data-toc="loops">Loops</h3><p id="-q3d1qe_455">Prefer using higher-order functions (<code class="code" id="-q3d1qe_457">filter</code>, <code class="code" id="-q3d1qe_458">map</code> etc.) to loops. Exception: <code class="code" id="-q3d1qe_459">forEach</code> (prefer using a regular <code class="code" id="-q3d1qe_460">for</code> loop instead, unless the receiver of <code class="code" id="-q3d1qe_461">forEach</code> is nullable or <code class="code" id="-q3d1qe_462">forEach</code> is used as part of a longer call chain).</p><p id="-q3d1qe_456">When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</p></section><section class="chapter"><h3 id="loops-on-ranges" data-toc="loops-on-ranges">Loops on ranges</h3><p id="-q3d1qe_463">Use the <code class="code" id="-q3d1qe_465">..&lt;</code> operator to loop over an open-ended range:</p><div class="code-block" data-lang="kotlin">
for (i in 0..n - 1) { /*...*/ }  // bad
for (i in 0..&lt;n) { /*...*/ }  // good
</div></section><section class="chapter"><h3 id="strings" data-toc="strings">Strings</h3><p id="-q3d1qe_466">Prefer string templates to string concatenation.</p><p id="-q3d1qe_467">Prefer multiline strings to embedding <code class="code" id="-q3d1qe_471">\n</code> escape sequences into regular string literals.</p><p id="-q3d1qe_468">To maintain indentation in multiline strings, use <code class="code" id="-q3d1qe_472">trimIndent</code> when the resulting string does not require any internal indentation, or <code class="code" id="-q3d1qe_473">trimMargin</code> when internal indentation is required:</p><div class="code-block" data-lang="kotlin" data-runnable="true">
fun main() {
//sampleStart
   println(&quot;&quot;&quot;
    Not
    trimmed
    text
    &quot;&quot;&quot;
   )

   println(&quot;&quot;&quot;
    Trimmed
    text
    &quot;&quot;&quot;.trimIndent()
   )

   println()

   val a = &quot;&quot;&quot;Trimmed to margin text:
          |if(a &gt; 1) {
          |    return a
          |}&quot;&quot;&quot;.trimMargin()

   println(a)
//sampleEnd
}
</div><p id="-q3d1qe_470">Learn the difference between <a href="java-to-kotlin-idioms-strings.html#use-multiline-strings" id="-q3d1qe_474">Java and Kotlin multiline strings</a>.</p></section><section class="chapter"><h3 id="functions-vs-properties" data-toc="functions-vs-properties">Functions vs properties</h3><p id="-q3d1qe_475">In some scenarios, functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</p><p id="-q3d1qe_476">Prefer a property over a function when the underlying algorithm:</p><ul class="list _bullet" id="-q3d1qe_477"><li class="list__item" id="-q3d1qe_478"><p id="-q3d1qe_481">Does not throw.</p></li><li class="list__item" id="-q3d1qe_479"><p id="-q3d1qe_482">Is cheap to calculate (or cached on the first run).</p></li><li class="list__item" id="-q3d1qe_480"><p id="-q3d1qe_483">Returns the same result over invocations if the object state hasn't changed.</p></li></ul></section><section class="chapter"><h3 id="extension-functions" data-toc="extension-functions">Extension functions</h3><p id="-q3d1qe_484">Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</p></section><section class="chapter"><h3 id="infix-functions" data-toc="infix-functions">Infix functions</h3><p id="-q3d1qe_485">Declare a function as <code class="code" id="-q3d1qe_487">infix</code> only when it works on two objects which play a similar role. Good examples: <code class="code" id="-q3d1qe_488">and</code>, <code class="code" id="-q3d1qe_489">to</code>, <code class="code" id="-q3d1qe_490">zip</code>. Bad example: <code class="code" id="-q3d1qe_491">add</code>.</p><p id="-q3d1qe_486">Do not declare a method as <code class="code" id="-q3d1qe_492">infix</code> if it mutates the receiver object.</p></section><section class="chapter"><h3 id="factory-functions" data-toc="factory-functions">Factory functions</h3><p id="-q3d1qe_493">If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name, making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</p><div class="code-block" data-lang="kotlin">
class Point(val x: Double, val y: Double) {
    companion object {
        fun fromPolar(angle: Double, radius: Double) = Point(...)
    }
}
</div><p id="-q3d1qe_495">If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor including parameters with default values, prefer to replace the overloaded constructors with factory functions.</p></section><section class="chapter"><h3 id="platform-types" data-toc="platform-types">Platform types</h3><p id="-q3d1qe_496">A public function/method returning an expression of a platform type must declare its Kotlin type explicitly:</p><div class="code-block" data-lang="kotlin">
fun apiCall(): String = MyJavaApi.getProperty(&quot;name&quot;)
</div><p id="-q3d1qe_498">Any property (package-level or class-level) initialized with an expression of a platform type must declare its Kotlin type explicitly:</p><div class="code-block" data-lang="kotlin">
class Person {
    val name: String = MyJavaApi.getProperty(&quot;name&quot;)
}
</div><p id="-q3d1qe_500">A local value initialized with an expression of a platform type may or may not have a type declaration:</p><div class="code-block" data-lang="kotlin">
fun main() {
    val name = MyJavaApi.getProperty(&quot;name&quot;)
    println(name)
}
</div></section><section class="chapter"><h3 id="scope-functions-apply-with-run-also-let" data-toc="scope-functions-apply-with-run-also-let">Scope functions apply/with/run/also/let</h3><p id="-q3d1qe_502">Kotlin provides a set of functions to execute a block of code in the context of a given object: <code class="code" id="-q3d1qe_503">let</code>, <code class="code" id="-q3d1qe_504">run</code>, <code class="code" id="-q3d1qe_505">with</code>, <code class="code" id="-q3d1qe_506">apply</code>, and <code class="code" id="-q3d1qe_507">also</code>. For the guidance on choosing the right scope function for your case, refer to <a href="scope-functions.html" id="-q3d1qe_508">Scope Functions</a>.</p></section></section><section class="chapter"><h2 id="coding-conventions-for-libraries" data-toc="coding-conventions-for-libraries">Coding conventions for libraries</h2><p id="-q3d1qe_509">When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</p><ul class="list _bullet" id="-q3d1qe_510"><li class="list__item" id="-q3d1qe_512"><p id="-q3d1qe_515">Always explicitly specify member visibility (to avoid accidentally exposing declarations as public API).</p></li><li class="list__item" id="-q3d1qe_513"><p id="-q3d1qe_516">Always explicitly specify function return types and property types (to avoid accidentally changing the return type when the implementation changes).</p></li><li class="list__item" id="-q3d1qe_514"><p id="-q3d1qe_517">Provide <a href="kotlin-doc.html" id="-q3d1qe_518">KDoc</a> comments for all public members, except for overrides that do not require any new documentation (to support generating documentation for the library).</p></li></ul><p id="-q3d1qe_511">Learn more about best practices and ideas to consider when writing an API for your library in the <span id="-q3d1qe_519">Library authors' guidelines</span>.</p></section><div class="last-modified">17 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="idioms.html" class="navigation-links__prev">Idioms</a><a href="basic-types.html" class="navigation-links__next">Basic types</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>