<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-25T03:05:07.73827043"><link rel="canonical" href="https://kotlinlang.org/docs/interfaces.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Interfaces | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"implementing-interfaces","level":0,"title":"Implementing interfaces","anchor":"#implementing-interfaces"},{"id":"properties-in-interfaces","level":0,"title":"Properties in interfaces","anchor":"#properties-in-interfaces"},{"id":"interfaces-inheritance","level":0,"title":"Interfaces Inheritance","anchor":"#interfaces-inheritance"},{"id":"resolving-overriding-conflicts","level":0,"title":"Resolving overriding conflicts","anchor":"#resolving-overriding-conflicts"},{"id":"jvm-default-method-generation-for-interface-functions","level":0,"title":"JVM default method generation for interface functions","anchor":"#jvm-default-method-generation-for-interface-functions"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Interfaces | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/interfaces.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Interfaces | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/interfaces.html#webpage",
    "url": "https://kotlinlang.org/docs/interfaces.html",
    "name": "Interfaces | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="interfaces" data-main-title="Interfaces" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts///Classes and objects" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/interfaces.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="interfaces" id="interfaces.md">Interfaces</h1><p id="-f1v58z_2">Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties, but these need to be abstract or provide accessor implementations.</p><p id="-f1v58z_3">An interface is defined using the keyword <code class="code" id="-f1v58z_10">interface</code>:</p><div class="code-block" data-lang="kotlin">
interface MyInterface {
    fun bar()
    fun foo() {
      // optional body
    }
}
</div><section class="chapter"><h2 id="implementing-interfaces" data-toc="implementing-interfaces">Implementing interfaces</h2><p id="-f1v58z_11">A class or object can implement one or more interfaces:</p><div class="code-block" data-lang="kotlin">
class Child : MyInterface {
    override fun bar() {
        // body
    }
}
</div></section><section class="chapter"><h2 id="properties-in-interfaces" data-toc="properties-in-interfaces">Properties in interfaces</h2><p id="-f1v58z_13">You can declare properties in interfaces. A property declared in an interface can either be abstract or provide implementations for accessors. Properties declared in interfaces can't have backing fields, and therefore accessors declared in interfaces can't reference them:</p><div class="code-block" data-lang="kotlin">
interface MyInterface {
    val prop: Int // abstract

    val propertyWithImplementation: String
        get() = &quot;foo&quot;

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}
</div></section><section class="chapter"><h2 id="interfaces-inheritance" data-toc="interfaces-inheritance">Interfaces Inheritance</h2><p id="-f1v58z_15">An interface can derive from other interfaces, meaning it can both provide implementations for their members and declare new functions and properties. Quite naturally, classes implementing such an interface are only required to define the missing implementations:</p><div class="code-block" data-lang="kotlin">
interface Named {
    val name: String
}

interface Person : Named {
    val firstName: String
    val lastName: String
    
    override val name: String get() = &quot;$firstName $lastName&quot;
}

data class Employee(
    // implementing 'name' is not required
    override val firstName: String,
    override val lastName: String,
    val position: Position
) : Person
</div></section><section class="chapter"><h2 id="resolving-overriding-conflicts" data-toc="resolving-overriding-conflicts">Resolving overriding conflicts</h2><p id="-f1v58z_17">When you declare many types in your supertype list, you may inherit more than one implementation of the same method:</p><div class="code-block" data-lang="kotlin">
interface A {
    fun foo() { print(&quot;A&quot;) }
    fun bar()
}

interface B {
    fun foo() { print(&quot;B&quot;) }
    fun bar() { print(&quot;bar&quot;) }
}

class C : A {
    override fun bar() { print(&quot;bar&quot;) }
}

class D : A, B {
    override fun foo() {
        super&lt;A&gt;.foo()
        super&lt;B&gt;.foo()
    }

    override fun bar() {
        super&lt;B&gt;.bar()
    }
}
</div><p id="-f1v58z_19">Interfaces <span class="emphasis" id="-f1v58z_21">A</span> and <span class="emphasis" id="-f1v58z_22">B</span> both declare functions <span class="emphasis" id="-f1v58z_23">foo()</span> and <span class="emphasis" id="-f1v58z_24">bar()</span>. Both of them implement <span class="emphasis" id="-f1v58z_25">foo()</span>, but only <span class="emphasis" id="-f1v58z_26">B</span> implements <span class="emphasis" id="-f1v58z_27">bar()</span> (<span class="emphasis" id="-f1v58z_28">bar()</span> is not marked as abstract in <span class="emphasis" id="-f1v58z_29">A</span>, because this is the default for interfaces if the function has no body). Now, if you derive a concrete class <span class="emphasis" id="-f1v58z_30">C</span> from <span class="emphasis" id="-f1v58z_31">A</span>, you have to override <span class="emphasis" id="-f1v58z_32">bar()</span> and provide an implementation.</p><p id="-f1v58z_20">However, if you derive <span class="emphasis" id="-f1v58z_33">D</span> from <span class="emphasis" id="-f1v58z_34">A</span> and <span class="emphasis" id="-f1v58z_35">B</span>, you need to implement all the methods that you have inherited from multiple interfaces, and you need to specify how exactly <span class="emphasis" id="-f1v58z_36">D</span> should implement them. This rule applies both to methods for which you've inherited a single implementation (<span class="emphasis" id="-f1v58z_37">bar()</span>) and to those for which you've inherited multiple implementations (<span class="emphasis" id="-f1v58z_38">foo()</span>).</p></section><section class="chapter"><h2 id="jvm-default-method-generation-for-interface-functions" data-toc="jvm-default-method-generation-for-interface-functions">JVM default method generation for interface functions</h2><p id="-f1v58z_39">On the JVM, functions declared in interfaces are compiled to default methods. You can control this behavior using the <code class="code" id="-f1v58z_43">-jvm-default</code> compiler option with the following values:</p><ul class="list _bullet" id="-f1v58z_40"><li class="list__item" id="-f1v58z_44"><p id="-f1v58z_47"><code class="code" id="-f1v58z_48">enable</code> (default): generates default implementations in interfaces and includes bridge functions in subclasses and <code class="code" id="-f1v58z_49">DefaultImpls</code> classes. Use this mode to maintain binary compatibility with older Kotlin versions.</p></li><li class="list__item" id="-f1v58z_45"><p id="-f1v58z_50"><code class="code" id="-f1v58z_51">no-compatibility</code>: generates only default implementations in interfaces. This mode skips compatibility bridges and <code class="code" id="-f1v58z_52">DefaultImpls</code> classes, making it suitable for new Kotlin code.</p></li><li class="list__item" id="-f1v58z_46"><p id="-f1v58z_53"><code class="code" id="-f1v58z_54">disable</code>: skips default methods and generates only compatibility bridges and <code class="code" id="-f1v58z_55">DefaultImpls</code> classes.</p></li></ul><p id="-f1v58z_41">To configure the <code class="code" id="-f1v58z_56">-jvm-default</code> compiler option, set the <code class="code" id="-f1v58z_57">jvmDefault</code> property in your Gradle Kotlin DSL:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        jvmDefault = JvmDefaultMode.NO_COMPATIBILITY
    }
}
</div></section><div class="last-modified">25 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="properties.html" class="navigation-links__prev">Properties</a><a href="fun-interfaces.html" class="navigation-links__next">Functional (SAM) interfaces</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>