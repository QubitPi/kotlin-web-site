<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-08-01T15:59:01.584693263"><link rel="canonical" href="https://kotlinlang.org/docs/whatsnew-eap.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>What's new in Kotlin 2.2.20-Beta2 | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"ide-support","level":0,"title":"IDE support","anchor":"#ide-support"},{"id":"language","level":0,"title":"Language","anchor":"#language"},{"id":"improved-overload-resolution-for-lambdas-with-suspend-function-types","level":1,"title":"Improved overload resolution for lambdas with suspend function types","anchor":"#improved-overload-resolution-for-lambdas-with-suspend-function-types"},{"id":"support-for-return-statements-in-expression-bodies-with-explicit-return-types","level":1,"title":"Support for return statements in expression bodies with explicit return types","anchor":"#support-for-return-statements-in-expression-bodies-with-explicit-return-types"},{"id":"kotlin-jvm-support-invokedynamic-with-when-expressions","level":0,"title":"Kotlin/JVM: support invokedynamic with when expressions","anchor":"#kotlin-jvm-support-invokedynamic-with-when-expressions"},{"id":"kotlin-multiplatform","level":0,"title":"Kotlin Multiplatform","anchor":"#kotlin-multiplatform"},{"id":"swift-export-available-by-default","level":1,"title":"Swift export available by default","anchor":"#swift-export-available-by-default"},{"id":"shared-source-set-for-js-and-wasmjs-targets","level":1,"title":"Shared source set for js and wasmJs targets","anchor":"#shared-source-set-for-js-and-wasmjs-targets"},{"id":"stable-cross-platform-compilation-for-kotlin-libraries","level":1,"title":"Stable cross-platform compilation for Kotlin libraries","anchor":"#stable-cross-platform-compilation-for-kotlin-libraries"},{"id":"new-approach-for-declaring-common-dependencies","level":1,"title":"New approach for declaring common dependencies","anchor":"#new-approach-for-declaring-common-dependencies"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"support-for-stack-canaries-in-binaries","level":1,"title":"Support for stack canaries in binaries","anchor":"#support-for-stack-canaries-in-binaries"},{"id":"smaller-binary-size-for-ios-targets","level":1,"title":"Smaller binary size for iOS targets","anchor":"#smaller-binary-size-for-ios-targets"},{"id":"improved-debugger-object-summaries","level":1,"title":"Improved debugger object summaries","anchor":"#improved-debugger-object-summaries"},{"id":"kotlin-wasm","level":0,"title":"Kotlin/Wasm","anchor":"#kotlin-wasm"},{"id":"separated-npm-dependencies","level":1,"title":"Separated npm dependencies","anchor":"#separated-npm-dependencies"},{"id":"improved-exception-handling-in-kotlin-wasm-and-javascript-interop","level":1,"title":"Improved exception handling in Kotlin/Wasm and JavaScript interop","anchor":"#improved-exception-handling-in-kotlin-wasm-and-javascript-interop"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"usage-of-bigint-type-to-represent-kotlin-s-long-type","level":1,"title":"Usage of BigInt type to represent Kotlin\u0027s Long type","anchor":"#usage-of-bigint-type-to-represent-kotlin-s-long-type"},{"id":"new-dsl-function-for-cleaner-arguments","level":1,"title":"New DSL function for cleaner arguments","anchor":"#new-dsl-function-for-cleaner-arguments"},{"id":"gradle-new-compiler-performance-metrics-in-build-reports-for-kotlin-native-tasks","level":0,"title":"Gradle: new compiler performance metrics in build reports for Kotlin/Native tasks","anchor":"#gradle-new-compiler-performance-metrics-in-build-reports-for-kotlin-native-tasks"},{"id":"maven-support-for-the-kotlin-daemon-in-the-kotlin-maven-plugin","level":0,"title":"Maven: support for the Kotlin daemon in the kotlin-maven-plugin","anchor":"#maven-support-for-the-kotlin-daemon-in-the-kotlin-maven-plugin"},{"id":"standard-library-support-for-identifying-interface-types-through-reflection-in-kotlin-js","level":0,"title":"Standard library: support for identifying interface types through reflection in Kotlin/JS","anchor":"#standard-library-support-for-identifying-interface-types-through-reflection-in-kotlin-js"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 2.2.20-Beta2 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/whatsnew-eap.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="What's new in Kotlin 2.2.20-Beta2 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/whatsnew-eap.html#webpage",
    "url": "https://kotlinlang.org/docs/whatsnew-eap.html",
    "name": "What's new in Kotlin 2.2.20-Beta2 | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="whatsnew-eap" data-main-title="What's new in Kotlin 2.2.20-Beta2" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/whatsnew/whatsnew-eap.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew-eap" id="whatsnew-eap.md">What's new in Kotlin 2.2.20-Beta2</h1><p id="qgapf_2"><span class="emphasis" id="qgapf_16"><a href="eap.html#build-details" id="qgapf_17">Released: July 29, 2025</a></span></p><aside class="prompt" data-type="note" data-title="" id="qgapf_3"><p id="qgapf_18">This document doesn't cover all of the features of the Early Access Preview (EAP) release, but it highlights some major improvements.</p><p id="qgapf_19">See the full list of changes in the <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.2.20-Beta2" id="qgapf_20" data-external="true" rel="noopener noreferrer" target="_blank">GitHub changelog</a>.</p></aside><p id="qgapf_4">The Kotlin 2.2.20-Beta2 release is out! Here are some details of this EAP release:</p><ul class="list _bullet" id="qgapf_5"><li class="list__item" id="qgapf_21"><p id="qgapf_26">Kotlin Multiplatform: <a href="#swift-export-available-by-default" id="qgapf_27">Swift export available by default</a>, <a href="#shared-source-set-for-js-and-wasmjs-targets" id="qgapf_28">shared source set for <code class="code" id="qgapf_31">js</code> and <code class="code" id="qgapf_32">wasmJs</code> targets</a>, <a href="#stable-cross-platform-compilation-for-kotlin-libraries" id="qgapf_29">stable cross-platform compilation for Kotlin libraries</a>, and a <a href="#new-approach-for-declaring-common-dependencies" id="qgapf_30">new approach for declaring common dependencies</a>.</p></li><li class="list__item" id="qgapf_22"><p id="qgapf_33">Language: <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types" id="qgapf_34">improved overload resolution when passing lambdas to overloads with suspend function types</a>.</p></li><li class="list__item" id="qgapf_23"><p id="qgapf_35">Kotlin/Native: <a href="#support-for-stack-canaries-in-binaries" id="qgapf_36">support for stack canaries in binaries</a> and <a href="#smaller-binary-size-for-ios-targets" id="qgapf_37">smaller binary size for iOS targets</a>.</p></li><li class="list__item" id="qgapf_24"><p id="qgapf_38">Kotlin/Wasm: <a href="#improved-exception-handling-in-kotlin-wasm-and-javascript-interop" id="qgapf_39">improved exception handling in Kotlin/Wasm and JavaScript interop</a>.</p></li><li class="list__item" id="qgapf_25"><p id="qgapf_40">Kotlin/JS: <a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type" id="qgapf_41"><code class="code" id="qgapf_42">Long</code> values compiled into JavaScript <code class="code" id="qgapf_43">BigInt</code></a>.</p></li></ul><section class="chapter"><h2 id="ide-support" data-toc="ide-support">IDE support</h2><p id="qgapf_44">The Kotlin plugins that support 2.2.20-Beta2 are bundled in the latest versions of IntelliJ IDEA and Android Studio. You don't need to update the Kotlin plugin in your IDE. All you need to do is <a href="configure-build-for-eap.html" id="qgapf_46">change the Kotlin version</a> to 2.2.20-Beta2 in your build scripts.</p><p id="qgapf_45">See <a href="releases.html#update-to-a-new-kotlin-version" id="qgapf_47">Update to a new release</a> for details.</p></section><section class="chapter"><h2 id="language" data-toc="language">Language</h2><p id="qgapf_48">In Kotlin 2.2.20-Beta2, you can try out upcoming language features planned for Kotlin 2.3.0, including <a href="#improved-overload-resolution-for-lambdas-with-suspend-function-types" id="qgapf_51">improved overload resolution when passing lambdas to overloads with suspend function types</a> and <a href="#support-for-return-statements-in-expression-bodies-with-explicit-return-types" id="qgapf_52">support for return statements in expression bodies with explicit return types</a>.</p><section class="chapter"><h3 id="improved-overload-resolution-for-lambdas-with-suspend-function-types" data-toc="improved-overload-resolution-for-lambdas-with-suspend-function-types">Improved overload resolution for lambdas with suspend function types</h3><p id="qgapf_53">Previously, overloading a function with both a regular function type and a <code class="code" id="qgapf_62">suspend</code> function type caused an ambiguity error when passing a lambda. You could work around this error with an explicit type cast, but the compiler incorrectly reported a <code class="code" id="qgapf_63">No cast needed</code> warning:</p><div class="code-block" data-lang="kotlin">
// Defines two overloads
fun transform(block: () -&gt; Int) {}
fun transform(block: suspend () -&gt; Int) {}

fun test() {
    // Fails with overload resolution ambiguity
    transform({ 42 })

    // Uses an explicit cast, but compiler incorrectly reports a &quot;No cast needed&quot; warning
    transform({ 42 } as () -&gt; Int)
}
</div><p id="qgapf_55">With this change, when you define both a regular and a <code class="code" id="qgapf_64">suspend</code> function type overload, a lambda without a cast resolves to the regular overload. Use the <code class="code" id="qgapf_65">suspend</code> keyword to resolve to the suspend overload explicitly:</p><div class="code-block" data-lang="kotlin">
// Resolves to transform(() -&gt; Int)
transform({ 42 })

// Resolves to transform(suspend () -&gt; Int)
transform(suspend { 42 })
</div><p id="qgapf_57">This behavior will be enabled by default in Kotlin 2.3.0. To test it now, set your language version to <code class="code" id="qgapf_66">2.3</code> using the following compiler option:</p><div class="code-block" data-lang="kotlin">
-language-version 2.3
</div><p id="qgapf_59">Or configure it in your <code class="code" id="qgapf_67">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        languageVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)
    }
}
</div><p id="qgapf_61">We would appreciate your feedback in our issue tracker, <a href="https://youtrack.jetbrains.com/issue/KT-23610" id="qgapf_68" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h3 id="support-for-return-statements-in-expression-bodies-with-explicit-return-types" data-toc="support-for-return-statements-in-expression-bodies-with-explicit-return-types">Support for return statements in expression bodies with explicit return types</h3><p id="qgapf_69">Previously, using <code class="code" id="qgapf_80">return</code> in an expression body caused a compiler error because it could cause the function's return type to be inferred as <code class="code" id="qgapf_81">Nothing</code>.</p><div class="code-block" data-lang="kotlin">
fun example() = return 42
// Error: Returns are prohibited for functions with an expression body
</div><p id="qgapf_71">With this change, you can now use <code class="code" id="qgapf_82">return</code> in expression bodies as long as the return type is written explicitly:</p><div class="code-block" data-lang="kotlin">
// Specifies the return type explicitly
fun getDisplayNameOrDefault(userId: String?): String = getDisplayName(userId ?: return &quot;default&quot;)

// Fails because it doesn't specify the return type explicitly
fun getDisplayNameOrDefault(userId: String?) = getDisplayName(userId ?: return &quot;default&quot;)
</div><p id="qgapf_73">Similarly, <code class="code" id="qgapf_83">return</code> statements inside lambdas and nested expressions in functions with expression bodies used to compile unintentionally. Kotlin now supports these cases as long as the return type is specified explicitly. Cases without an explicit return type will be deprecated in Kotlin 2.3.0:</p><div class="code-block" data-lang="kotlin">
// Return type isn't explicitly specified, and the return statement is inside a lambda
// which will be deprecated
fun returnInsideLambda() = run { return 42 }

// Return type isn't explicitly specified, and the return statement is inside the initializer
// of a local variable, which will be deprecated
fun returnInsideIf() = when {
    else -&gt; {
        val result = if (someCondition()) return &quot;&quot; else &quot;value&quot;
        result
    }
}
</div><p id="qgapf_75">This behavior will be enabled by default in Kotlin 2.3.0. To test it now, set your language version to <code class="code" id="qgapf_84">2.3</code> using the following compiler option:</p><div class="code-block" data-lang="kotlin">
-language-version 2.3
</div><p id="qgapf_77">Or configure it in your <code class="code" id="qgapf_85">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        languageVersion.set(org.jetbrains.kotlin.gradle.dsl.KotlinVersion.KOTLIN_2_3)
    }
}
</div><p id="qgapf_79">We would appreciate your feedback in our issue tracker, <a href="https://youtrack.jetbrains.com/issue/KT-76926" id="qgapf_86" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section><section class="chapter"><h2 id="kotlin-jvm-support-invokedynamic-with-when-expressions" data-toc="kotlin-jvm-support-invokedynamic-with-when-expressions" data-label-id="experimental-opt-in">Kotlin/JVM: support invokedynamic with when expressions</h2><p id="qgapf_88">In Kotlin 2.2.20-Beta2, you can now compile <code class="code" id="qgapf_99">when</code> expressions with <code class="code" id="qgapf_100">invokedynamic</code>. Previously, <code class="code" id="qgapf_101">when</code> expressions with multiple type checks compiled to a long chain of <code class="code" id="qgapf_102">instanceof</code> checks in the bytecode.</p><p id="qgapf_89">Now you can use <code class="code" id="qgapf_103">invokedynamic</code> with <code class="code" id="qgapf_104">when</code> expressions to generate smaller bytecode, similar to the bytecode produced by Java <code class="code" id="qgapf_105">switch</code> statements, when the following conditions are met:</p><ul class="list _bullet" id="qgapf_90"><li class="list__item" id="qgapf_106"><p id="qgapf_111">All conditions except for <code class="code" id="qgapf_112">else</code> are <code class="code" id="qgapf_113">is</code> or <code class="code" id="qgapf_114">null</code> checks.</p></li><li class="list__item" id="qgapf_107"><p id="qgapf_115">The expression doesn't contain <a href="control-flow.html#guard-conditions-in-when-expressions" id="qgapf_116">guard conditions (<code class="code" id="qgapf_117">if</code>)</a>.</p></li><li class="list__item" id="qgapf_108"><p id="qgapf_118">The conditions don't include types that can't be type-checked directly, such as mutable Kotlin collections (<code class="code" id="qgapf_119">MutableList</code>) or function types (<code class="code" id="qgapf_120">kotlin.Function1</code>, <code class="code" id="qgapf_121">kotlin.Function2</code>, and so on).</p></li><li class="list__item" id="qgapf_109"><p id="qgapf_122">There are at least two conditions besides <code class="code" id="qgapf_123">else</code>.</p></li><li class="list__item" id="qgapf_110"><p id="qgapf_124">All branches check the same subject of the <code class="code" id="qgapf_125">when</code> expression.</p></li></ul><p id="qgapf_91">For example:</p><div class="code-block" data-lang="kotlin">
open class Example

class A : Example()
class B : Example()
class C : Example()

fun test(e: Example) = when (e) {
    // Uses invokedynamic with SwitchBootstraps.typeSwitch
    is A -&gt; 1
    is B -&gt; 2
    is C -&gt; 3
    else -&gt; 0
}
</div><p id="qgapf_93">With the new feature enabled, the <code class="code" id="qgapf_126">when</code> expression in this example compiles to a single <code class="code" id="qgapf_127">invokedynamic</code> type switch instead of multiple <code class="code" id="qgapf_128">instanceof</code> checks.</p><p id="qgapf_94">To enable this feature, compile your Kotlin code with JVM target 21 or above and add the following compiler option:</p><div class="code-block" data-lang="bash">
-Xwhen-expressions=indy
</div><p id="qgapf_96">Or add it to the <code class="code" id="qgapf_129">compilerOptions {}</code> block of your <code class="code" id="qgapf_130">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
kotlin {
    compilerOptions {
        freeCompilerArgs.add(&quot;-Xwhen-expressions=indy&quot;)
    }
}
</div><p id="qgapf_98">This feature is <a href="components-stability.html#stability-levels-explained" id="qgapf_131">Experimental</a>. If you have any feedback or questions, share them in <a href="https://youtrack.jetbrains.com/issue/KT-65688" id="qgapf_132" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><section class="chapter"><h2 id="kotlin-multiplatform" data-toc="kotlin-multiplatform">Kotlin Multiplatform</h2><p id="qgapf_133">Kotlin 2.2.20-Beta2 introduces significant changes for Kotlin Multiplatform: Swift export is available by default, there's a new shared source set, and you can try a new approach to managing common dependencies.</p><section class="chapter"><h3 id="swift-export-available-by-default" data-toc="swift-export-available-by-default" data-label-id="experimental-general">Swift export available by default</h3><p id="qgapf_139">Kotlin 2.2.20-Beta2 introduces experimental support for Swift export. It allows you to export Kotlin sources directly and call Kotlin code from Swift idiomatically, eliminating the need for Objective-C headers.</p><p id="qgapf_140">This should significantly improve multiplatform development for Apple targets. For example, if you have a Kotlin module with top-level functions, Swift export enables clean, module-specific imports, removing the confusing Objective-C underscores and mangled names.</p><p id="qgapf_141">The key features are:</p><ul class="list _bullet" id="qgapf_142"><li class="list__item" id="qgapf_145"><p id="qgapf_152"><span class="control" id="qgapf_153">Multi-module support</span>. Each Kotlin module is exported as a separate Swift module, simplifying function calls.</p></li><li class="list__item" id="qgapf_146"><p id="qgapf_154"><span class="control" id="qgapf_155">Package support</span>. Kotlin packages are explicitly preserved during export, avoiding naming conflicts in the generated Swift code.</p></li><li class="list__item" id="qgapf_147"><p id="qgapf_156"><span class="control" id="qgapf_157">Type aliases</span>. Kotlin type aliases are exported and preserved in Swift, improving readability.</p></li><li class="list__item" id="qgapf_148"><p id="qgapf_158"><span class="control" id="qgapf_159">Enhanced nullability for primitives</span>. Unlike Objective-C interop, which required boxing types like <code class="code" id="qgapf_160">Int?</code> into wrapper classes like <code class="code" id="qgapf_161">KotlinInt</code> to preserve nullability, Swift export converts nullability information directly.</p></li><li class="list__item" id="qgapf_149"><p id="qgapf_162"><span class="control" id="qgapf_163">Overloads</span>. You can call Kotlin's overloaded functions in Swift without ambiguity.</p></li><li class="list__item" id="qgapf_150"><p id="qgapf_164"><span class="control" id="qgapf_165">Flattened package structure</span>. You can translate Kotlin packages into Swift enums, removing the package prefix from generated Swift code.</p></li><li class="list__item" id="qgapf_151"><p id="qgapf_166"><span class="control" id="qgapf_167">Module name customization</span>. You can customize the resulting Swift module names in the Gradle configuration of your Kotlin project.</p></li></ul><section class="chapter"><h4 id="how-to-enable-swift-export" data-toc="how-to-enable-swift-export">How to enable Swift export</h4><p id="qgapf_168">The feature is currently <a href="components-stability.html#stability-levels-explained" id="qgapf_177">Experimental</a> and works only in projects that use <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-direct-integration.html" id="qgapf_178" data-external="true" rel="noopener noreferrer" target="_blank">direct integration</a> to connect the iOS framework to the Xcode project. This is a standard configuration for Kotlin Multiplatform projects created with Kotlin Multiplatform plugin in IntelliJ IDEA or through the <a href="https://kmp.jetbrains.com/" id="qgapf_179" data-external="true" rel="noopener noreferrer" target="_blank">web wizard</a>.</p><p id="qgapf_169">To try out Swift export, configure your Xcode project:</p><ol class="list _decimal" id="qgapf_170" type="1"><li class="list__item" id="qgapf_180"><p id="qgapf_183">In Xcode, open the project settings.</p></li><li class="list__item" id="qgapf_181"><p id="qgapf_184">On the <span class="control" id="qgapf_185">Build Phases</span> tab, locate the <span class="control" id="qgapf_186">Run Script</span> phase with the <code class="code" id="qgapf_187">embedAndSignAppleFrameworkForXcode</code> task.</p></li><li class="list__item" id="qgapf_182"><p id="qgapf_188">Adjust the script to feature the <code class="code" id="qgapf_189">embedSwiftExportForXcode</code> task instead in the run script phase:</p></li></ol><div class="code-block" data-lang="bash">
./gradlew :&lt;Shared module name&gt;:embedSwiftExportForXcode
</div><figure id="qgapf_172"><img alt="Add the Swift export script" src="images/xcode-swift-export-run-script-phase.png" title="Add the Swift export script" width="700" height="369"></figure><ol class="list _decimal" id="qgapf_173" type="1" start="4"><li class="list__item" id="qgapf_190"><p id="qgapf_191">Build the project. Swift modules are generated in the build output directory.</p></li></ol><p id="qgapf_174">The feature is available by default. If you have already enabled it in previous releases, you can now remove <code class="code" id="qgapf_192">kotlin.experimental.swift-export.enabled</code> from your <code class="code" id="qgapf_193">gradle.properties</code> file.</p><aside class="prompt" data-type="tip" data-title="" id="qgapf_175"><p id="qgapf_194">To save time, clone our <a href="https://github.com/Kotlin/swift-export-sample" id="qgapf_195" data-external="true" rel="noopener noreferrer" target="_blank">public sample</a> with Swift export already set up.</p></aside><p id="qgapf_176">For more information about Swift export, see its <a href="https://github.com/JetBrains/kotlin/tree/master/docs/swift-export#readme" id="qgapf_196" data-external="true" rel="noopener noreferrer" target="_blank">README</a>.</p></section><section class="chapter"><h4 id="leave-feedback" data-toc="leave-feedback">Leave feedback</h4><p id="qgapf_197">We're planning to expand and gradually stabilize Swift export support in future Kotlin releases. After Kotlin 2.2.20 we'll focus on improving interoperability between Kotlin and Swift, particularly around coroutines and flows.</p><p id="qgapf_198">Support for Swift export is a significant change for Kotlin Multiplatform. We would appreciate your feedback:</p><ul class="list _bullet" id="qgapf_199"><li class="list__item" id="qgapf_200"><p id="qgapf_202">Contact the development team directly in Kotlin Slack &ndash; <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*ju6cbn*_ga*MTA3MTk5NDkzMC4xNjQ2MDY3MDU4*_ga_9J976DJZ68*MTY1ODMzNzA3OS4xMDAuMS4xNjU4MzQwODEwLjYw" id="qgapf_203" data-external="true" rel="noopener noreferrer" target="_blank">get an invite</a> and join the <a href="https://kotlinlang.slack.com/archives/C073GUW6WN9" id="qgapf_204" data-external="true" rel="noopener noreferrer" target="_blank">#swift-export</a> channel.</p></li><li class="list__item" id="qgapf_201"><p id="qgapf_205">Report any problems you face with Swift export in <a href="https://kotl.in/issue" id="qgapf_206" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></li></ul></section></section><section class="chapter"><h3 id="shared-source-set-for-js-and-wasmjs-targets" data-toc="shared-source-set-for-js-and-wasmjs-targets">Shared source set for js and wasmJs targets</h3><p id="qgapf_207">Previously, Kotlin Multiplatform didn't include a shared source set for JavaScript (<code class="code" id="qgapf_218">js</code>) and WebAssembly (<code class="code" id="qgapf_219">wasmJs</code>) web targets by default. To share code between <code class="code" id="qgapf_220">js</code> and <code class="code" id="qgapf_221">wasmJs</code>, you had to manually configure a custom source set or write code in two places, one version for <code class="code" id="qgapf_222">js</code> and another for <code class="code" id="qgapf_223">wasmJs</code>. For example:</p><div class="code-block" data-lang="kotlin">
// commonMain
expect suspend fun readCopiedText(): String

// jsMain
external interface Navigator { val clipboard: Clipboard }
// Different interop in JS and Wasm
external interface Clipboard { fun readText(): Promise&lt;String&gt; } 
external val navigator: Navigator

suspend fun readCopiedText(): String {
  // Different interop in JS and Wasm
    return navigator.clipboard.readText().await() 
}

// wasmJsMain
external interface Navigator { val clipboard: Clipboard }
external interface Clipboard { fun readText(): Promise&lt;JsString&gt; }
external val navigator: Navigator

suspend fun readCopiedText(): String {
    return navigator.clipboard.readText().await().toString() 
}
</div><p id="qgapf_209">Starting with this release, the Kotlin Gradle plugin adds a new shared source set for web (comprising <code class="code" id="qgapf_224">webMain</code> and <code class="code" id="qgapf_225">webTest</code>) when using the default hierarchy template.</p><p id="qgapf_210">With this change, the <code class="code" id="qgapf_226">web</code> source set becomes a parent of both <code class="code" id="qgapf_227">js</code> and <code class="code" id="qgapf_228">wasmJs</code> source sets. The updated source set hierarchy looks like this:</p><figure id="qgapf_211"><img alt="An example of using the default hierarchy template with web" src="images/default-hierarchy-example-with-web.svg" title="An example of using the default hierarchy template with web" width="750" height="300"></figure><p id="qgapf_212">The new source set allows you to write one piece of code for both the <code class="code" id="qgapf_229">js</code> and <code class="code" id="qgapf_230">wasmJs</code> targets. You can put your shared code in <code class="code" id="qgapf_231">webMain</code> and it automatically works for both targets:</p><div class="code-block" data-lang="kotlin">
// commonMain
expect suspend fun readCopiedText(): String

// webMain
external interface Navigator { val clipboard: Clipboard }
external interface Clipboard { fun readText(): Promise&lt;JsString&gt; }
external val navigator: Navigator

suspend fun readCopiedText(): String {
    return navigator.clipboard.readText().await().toString()
}
</div><p id="qgapf_214">This update simplifies code sharing between the <code class="code" id="qgapf_232">js</code> and <code class="code" id="qgapf_233">wasmJs</code> targets. It is particularly useful in two cases:</p><ul class="list _bullet" id="qgapf_215"><li class="list__item" id="qgapf_234"><p id="qgapf_236">For library authors who want to add support for both <code class="code" id="qgapf_237">js</code> and <code class="code" id="qgapf_238">wasmJs</code> targets, without duplicating code.</p></li><li class="list__item" id="qgapf_235"><p id="qgapf_239">For developers building Compose Multiplatform applications that target the Web, enabling cross-compilation to both <code class="code" id="qgapf_240">js</code> and <code class="code" id="qgapf_241">wasmJs</code> targets for wider browser compatibility. Given this fallback mode, when you create a website, it will work on all browsers out of the box: modern browsers use <code class="code" id="qgapf_242">wasmJs</code>, and older browsers use <code class="code" id="qgapf_243">js</code>.</p></li></ul><p id="qgapf_216">To try this feature, use the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-hierarchy.html#default-hierarchy-template" id="qgapf_244" data-external="true" rel="noopener noreferrer" target="_blank">default hierarchy template</a> in the <code class="code" id="qgapf_245">kotlin {}</code> block of your <code class="code" id="qgapf_246">build.gradle(.kts)</code> file.</p><p id="qgapf_217">Before using the default hierarchy, consider carefully any potential conflicts if you have projects with a custom shared source set or if you renamed the <code class="code" id="qgapf_247">js(&quot;web&quot;)</code> target. To resolve these conflicts, rename the conflicting source set or target, or don't use the default hierarchy.</p></section><section class="chapter"><h3 id="stable-cross-platform-compilation-for-kotlin-libraries" data-toc="stable-cross-platform-compilation-for-kotlin-libraries">Stable cross-platform compilation for Kotlin libraries</h3><p id="qgapf_248">Kotlin 2.2.20-Beta2 completes an important <a href="https://youtrack.jetbrains.com/issue/KT-71290" id="qgapf_254" data-external="true" rel="noopener noreferrer" target="_blank">roadmap item</a>, stabilizing cross-platform compilation for Kotlin libraries.</p><p id="qgapf_249">You can now use any host to produce <code class="code" id="qgapf_255">.klib</code> artifacts for publishing Kotlin libraries. This significantly streamlines the publishing process, particularly for Apple targets that previously required a Mac machine.</p><p id="qgapf_250">The feature is available by default. If you have already enabled cross-compilation with <code class="code" id="qgapf_256">kotlin.native.enableKlibsCrossCompilation=true</code>, you can now remove it from your <code class="code" id="qgapf_257">gradle.properties</code> file.</p><p id="qgapf_251">Unfortunately, a few limitations are still present. You still need to use a Mac machine if:</p><ul class="list _bullet" id="qgapf_252"><li class="list__item" id="qgapf_258"><p id="qgapf_261">Your library has a <a href="native-c-interop.html" id="qgapf_262">cinterop dependency</a>.</p></li><li class="list__item" id="qgapf_259"><p id="qgapf_263">You have a <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-overview.html" id="qgapf_264" data-external="true" rel="noopener noreferrer" target="_blank">CocoaPods integration</a> set up in your project.</p></li><li class="list__item" id="qgapf_260"><p id="qgapf_265">You need to build or test <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-build-native-binaries.html" id="qgapf_266" data-external="true" rel="noopener noreferrer" target="_blank">final binaries</a> for Apple targets.</p></li></ul><p id="qgapf_253">For more information about the publication of multiplatform libraries, see our <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-lib-setup.html" id="qgapf_267" data-external="true" rel="noopener noreferrer" target="_blank">documentation</a>.</p></section><section class="chapter"><h3 id="new-approach-for-declaring-common-dependencies" data-toc="new-approach-for-declaring-common-dependencies" data-label-id="experimental-opt-in">New approach for declaring common dependencies</h3><p id="qgapf_269">To simplify setting up multiplatform projects with Gradle, Kotlin 2.2.20-Beta2 now lets you declare common dependencies in the <code class="code" id="qgapf_273">kotlin {}</code> block by using a top-level <code class="code" id="qgapf_274">dependencies {}</code> block. These dependencies behave as if they were declared in the <code class="code" id="qgapf_275">commonMain</code> source set. This feature works similarly to the dependencies block that you use for Kotlin/JVM and Android-only projects, and it's now <a href="components-stability.html#stability-levels-explained" id="qgapf_276">Experimental</a> in Kotlin Multiplatform. Declaring common dependencies at the project level reduces repetitive configuration across source sets and helps streamline your build setup. You can still add platform-specific dependencies in each source set as needed.</p><p id="qgapf_270">To try this feature, opt in by adding the <code class="code" id="qgapf_277">@OptIn(ExperimentalKotlinGradlePluginApi::class)</code> annotation before the top-level <code class="code" id="qgapf_278">dependencies {}</code> block. For example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    @OptIn(ExperimentalKotlinGradlePluginApi::class)
    dependencies {
        implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2&quot;)
    }
}
</div><p id="qgapf_272">We would appreciate your feedback on this feature in <a href="https://youtrack.jetbrains.com/issue/KT-76446" id="qgapf_279" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="qgapf_280">Kotlin 2.2.20-Beta2 brings improvements for Kotlin/Native binaries and debugging.</p><section class="chapter"><h3 id="support-for-stack-canaries-in-binaries" data-toc="support-for-stack-canaries-in-binaries">Support for stack canaries in binaries</h3><p id="qgapf_284">Starting with 2.2.20-Beta2, Kotlin adds support for stack canaries in the resulting Kotlin/Native binaries. As part of stack protection, this security feature protects against stack smashing, mitigating some common application vulnerabilities. Already available in Swift and Objective-C, it's now supported in Kotlin as well.</p><section class="chapter"><h4 id="how-to-enable-stack-canaries" data-toc="how-to-enable-stack-canaries">How to enable stack canaries</h4><p id="qgapf_286">The implementation of stack protection in Kotlin/Native follows the behavior of the stack protector in <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fstack-protector" id="qgapf_292" data-external="true" rel="noopener noreferrer" target="_blank">Clang</a>.</p><p id="qgapf_287">To enable stack canaries, add the following property to your <code class="code" id="qgapf_293">gradle.properties</code> file:</p><div class="code-block" data-lang="none">
kotlin.native.binary.stackProtector=yes
</div><p id="qgapf_289">The property enables the feature for all the Kotlin functions that are vulnerable to stack smashing. Alternative modes are:</p><ul class="list _bullet" id="qgapf_290"><li class="list__item" id="qgapf_294"><p id="qgapf_296"><code class="code" id="qgapf_297">kotlin.native.binary.stackProtector=strong</code>, which uses a stronger heuristic for the functions vulnerable to stack smashing.</p></li><li class="list__item" id="qgapf_295"><p id="qgapf_298"><code class="code" id="qgapf_299">kotlin.native.binary.stackProtector=all</code>, which enables stack protectors for all functions.</p></li></ul><p id="qgapf_291">Note that in some cases, stack protection might come with a performance cost.</p></section></section><section class="chapter"><h3 id="smaller-binary-size-for-ios-targets" data-toc="smaller-binary-size-for-ios-targets" data-label-id="experimental-general">Smaller binary size for iOS targets</h3><p id="qgapf_301">Kotlin 2.2.20-Beta2 introduces the <code class="code" id="qgapf_304">smallBinary</code> option that can help you decrease the binary size for iOS targets. The new option effectively sets <code class="code" id="qgapf_305">-Oz</code> as the default optimization argument for the compiler during the LLVM compilation phase.</p><p id="qgapf_302">With the <code class="code" id="qgapf_306">smallBinary</code> option enabled, you can make release binaries smaller and improve build time. However, it might affect runtime performance in some cases.</p><section class="chapter"><h4 id="how-to-enable-smaller-binary-size" data-toc="how-to-enable-smaller-binary-size">How to enable smaller binary size</h4><p id="qgapf_307">The new feature is currently <a href="components-stability.html#stability-levels-explained" id="qgapf_312">Experimental</a>. To try it out in your project, use the <code class="code" id="qgapf_313">-Xbinary=smallBinary=true</code> compiler option or update your <code class="code" id="qgapf_314">gradle.properties</code> file with:</p><div class="code-block" data-lang="none">
kotlin.native.binary.smallBinary=true
</div><p id="qgapf_309">For a specific binary, set the <code class="code" id="qgapf_315">binaryOption(&quot;smallBinary&quot;, &quot;true&quot;)</code> in your <code class="code" id="qgapf_316">build.gradle(.kts)</code> file. For example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64(),
    ).forEach {
        it.binaries.framework {
            binaryOption(&quot;smallBinary&quot;, &quot;true&quot;)
        }
    }
}
</div><p id="qgapf_311">The Kotlin team is grateful to <a href="https://github.com/troelsbjerre" id="qgapf_317" data-external="true" rel="noopener noreferrer" target="_blank">Troels Lund</a> for his help in implementing this feature.</p></section></section><section class="chapter"><h3 id="improved-debugger-object-summaries" data-toc="improved-debugger-object-summaries">Improved debugger object summaries</h3><p id="qgapf_318">Kotlin/Native now generates clearer object summaries for debugger tools like LLDB and GDB. This improves the readability of the produced debug information and streamlines your debugging experience.</p><p id="qgapf_319">Previously, if you inspected an object such as:</p><div class="code-block" data-lang="kotlin">
class Point(val x: Int, val y: Int)
val point = Point(1, 2)
</div><p id="qgapf_321">You'd see limited information, including a pointer to the memory address:</p><div class="code-block" data-lang="none">
(lldb) v point
(ObjHeader *) point = [x: ..., y: ...]
(lldb) v point-&gt;x
(int32_t *) x = 0x0000000100274048
</div><p id="qgapf_323">With Kotlin 2.2.20-Beta2, the debugger shows richer details, including the actual values:</p><div class="code-block" data-lang="none">
(lldb) v point
(ObjHeader *) point = Point(x=1, y=2)
(lldb) v point-&gt;x
(int32_t) point-&gt;x = 1
</div><p id="qgapf_325">The Kotlin team is grateful to <a href="https://github.com/nikita-nazarov" id="qgapf_327" data-external="true" rel="noopener noreferrer" target="_blank">Nikita Nazarov</a> for his help in implementing this feature.</p><p id="qgapf_326">For more information on debugging in Kotlin/Native, see the <a href="native-debugging.html" id="qgapf_328">documentation</a>.</p></section></section><section class="chapter"><h2 id="kotlin-wasm" data-toc="kotlin-wasm">Kotlin/Wasm</h2><p id="qgapf_329">Kotlin/Wasm receives some quality of life improvements, including separated npm dependencies and improved exception handling for JavaScript interop.</p><section class="chapter"><h3 id="separated-npm-dependencies" data-toc="separated-npm-dependencies">Separated npm dependencies</h3><p id="qgapf_332">Previously, in your Kotlin/Wasm projects, all <a href="https://www.npmjs.com/" id="qgapf_339" data-external="true" rel="noopener noreferrer" target="_blank">npm</a> dependencies were installed together in your project folder. It included both your own dependencies and Kotlin tooling dependencies. These dependencies were also recorded together in your project's lock files (<code class="code" id="qgapf_340">package-lock.json</code> or <code class="code" id="qgapf_341">yarn.lock</code>).</p><p id="qgapf_333">As a result, whenever Kotlin tooling dependencies were updated, you had to update your lock files even if you didn't add or change anything.</p><p id="qgapf_334">Starting from Kotlin 2.2.20-Beta2, the Kotlin tooling npm dependencies are installed outside your project. Now, the tooling and the user dependencies have separate directories:</p><ul class="list _bullet" id="qgapf_335"><li class="list__item" id="qgapf_342"><p id="qgapf_344"><span class="control" id="qgapf_346">Tooling dependencies' directory:</span></p><p id="qgapf_345"><code class="code" id="qgapf_347">&lt;kotlin-user-home&gt;/kotlin-npm-tooling/&lt;yarn|npm&gt;/hash/node_modules</code></p></li><li class="list__item" id="qgapf_343"><p id="qgapf_348"><span class="control" id="qgapf_350">User dependencies' directory:</span></p><p id="qgapf_349"><code class="code" id="qgapf_351">build/wasm/node_modules</code></p></li></ul><p id="qgapf_336">Also, the lock files inside the project directory contain only user-defined dependencies.</p><p id="qgapf_337">This improvement keeps your lock files focused only on your own dependencies, helps maintain a cleaner project, and reduces unnecessary changes to your files.</p><p id="qgapf_338">This change is enabled by default for the <code class="code" id="qgapf_352">wasm-js</code> target. The change is not yet implemented for the <code class="code" id="qgapf_353">js</code> target. While there are plans to implement it in future releases, the behavior of the npm dependencies remains the same for the <code class="code" id="qgapf_354">js</code> target in Kotlin 2.2.20-Beta2.</p></section><section class="chapter"><h3 id="improved-exception-handling-in-kotlin-wasm-and-javascript-interop" data-toc="improved-exception-handling-in-kotlin-wasm-and-javascript-interop">Improved exception handling in Kotlin/Wasm and JavaScript interop</h3><p id="qgapf_355">Previously, Kotlin had difficulty understanding exceptions (errors) thrown in JavaScript (JS) and crossing over to Kotlin/Wasm code.</p><p id="qgapf_356">In some cases, the issue also occurred in the reverse direction, when an exception was thrown or passed through the Wasm code to JS and wrapped into <code class="code" id="qgapf_362">WebAssembly.Exception</code> without any details. These Kotlin exception handling issues made debugging difficult.</p><p id="qgapf_357">Starting from Kotlin 2.2.20-Beta2, the developer experience with exceptions improves in both directions:</p><ul class="list _bullet" id="qgapf_358"><li class="list__item" id="qgapf_363"><p id="qgapf_365">When exceptions are thrown from JavaScript: you can see more information on Kotlin's side. When such an exception propagates through Kotlin back to JS, it's no longer wrapped into WebAssembly.</p></li><li class="list__item" id="qgapf_364"><p id="qgapf_366">When exceptions are thrown from Kotlin: they can now be caught on JavaScript's side as JS errors.</p></li></ul><p id="qgapf_359">The new exception handling works automatically in modern browsers that support the <a href="https://webassembly.github.io/exception-handling/js-api/#dom-webassembly-jstag" id="qgapf_367" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="qgapf_368">WebAssembly.JSTag</code></a> feature:</p><ul class="list _bullet" id="qgapf_360"><li class="list__item" id="qgapf_369"><p id="qgapf_372">Chrome 115+</p></li><li class="list__item" id="qgapf_370"><p id="qgapf_373">Firefox 129+</p></li><li class="list__item" id="qgapf_371"><p id="qgapf_374">Safari 18.4+</p></li></ul><p id="qgapf_361">In older browsers, the exception handling behavior remains unchanged.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="qgapf_375">Kotlin 2.2.20-Beta2 supports using the <code class="code" id="qgapf_378">BigInt</code> type to represent Kotlin's <code class="code" id="qgapf_379">Long</code> type, enabling <code class="code" id="qgapf_380">Long</code> in exported declarations. Additionally, this release adds a DSL function to clean up Node.js arguments.</p><section class="chapter"><h3 id="usage-of-bigint-type-to-represent-kotlin-s-long-type" data-toc="usage-of-bigint-type-to-represent-kotlin-s-long-type" data-label-id="experimental-opt-in">Usage of BigInt type to represent Kotlin's Long type</h3><p id="qgapf_382">Before the ES2020 standard, JavaScript (JS) did not support a primitive type for precise integers larger than 53 bits.</p><p id="qgapf_383">For this reason, Kotlin/JS used to represent <code class="code" id="qgapf_390">Long</code> values (which are 64-bit wide) as JavaScript objects containing two <code class="code" id="qgapf_391">number</code> properties. This custom implementation made interoperability between Kotlin and JavaScript more complex.</p><p id="qgapf_384">Starting with Kotlin 2.2.20-Beta2, Kotlin/JS now uses JavaScript's built-in <code class="code" id="qgapf_392">BigInt</code> type to represent Kotlin's <code class="code" id="qgapf_393">Long</code> values when compiling to modern JavaScript (ES2020).</p><p id="qgapf_385">This change enables <a href="#usage-of-long-in-exported-declarations" id="qgapf_394">exporting the <code class="code" id="qgapf_395">Long</code> type to JavaScript</a>, a feature also introduced in 2.2.20-Beta2. As a result, this change simplifies the interoperability between Kotlin and JavaScript.</p><p id="qgapf_386">To enable it, add the following compiler option to your <code class="code" id="qgapf_396">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    js {
        ...
        compilerOptions {
            freeCompilerArgs.add(&quot;-Xes-long-as-bigint&quot;)
        }
    }
}
</div><p id="qgapf_388">This feature is still <a href="components-stability.html#stability-levels-explained" id="qgapf_397">Experimental</a>. Please report any problems in our issue tracker, <a href="https://youtrack.jetbrains.com/issue/KT-57128" id="qgapf_398" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p><section class="chapter"><h4 id="usage-of-long-in-exported-declarations" data-toc="usage-of-long-in-exported-declarations">Usage of Long in exported declarations</h4><p id="qgapf_399">Because Kotlin/JS used a custom <code class="code" id="qgapf_403">Long</code> representation, it was difficult to provide a straightforward way to interact with Kotlin's <code class="code" id="qgapf_404">Long</code> from JavaScript. As a result, you couldn't export Kotlin code that used the <code class="code" id="qgapf_405">Long</code> type to JavaScript. This issue affected any code using <code class="code" id="qgapf_406">Long</code>, such as function parameters, class properties, or constructors.</p><p id="qgapf_400">Now that Kotlin's <code class="code" id="qgapf_407">Long</code> type can be compiled to JavaScript's <code class="code" id="qgapf_408">BigInt</code> type, Kotlin/JS supports exporting <code class="code" id="qgapf_409">Long</code> values to JavaScript, simplifying the interoperability between Kotlin and JavaScript code.</p><p id="qgapf_401">To enable this feature:</p><ol class="list _decimal" id="qgapf_402" type="1"><li class="list__item" id="qgapf_410"><p id="qgapf_412">Allow exporting <code class="code" id="qgapf_414">Long</code> in Kotlin/JS. Add the following compiler argument to the <code class="code" id="qgapf_415">freeCompilerArgs</code> attribute in your <code class="code" id="qgapf_416">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
// build.gradle.kts
kotlin {
    js {
        ...
        compilerOptions {                   
            freeCompilerArgs.add(&quot;-XXLanguage:+JsAllowLongInExportedDeclarations&quot;)
        }
    }
}
</div></li><li class="list__item" id="qgapf_411"><p id="qgapf_417">Enable the <code class="code" id="qgapf_418">BigInt</code> type. See how to enable it in <a href="#usage-of-bigint-type-to-represent-kotlin-s-long-type" id="qgapf_419">Usage of <code class="code" id="qgapf_420">BigInt</code> type to represent Kotlin's <code class="code" id="qgapf_421">Long</code> type</a>.</p></li></ol></section></section><section class="chapter"><h3 id="new-dsl-function-for-cleaner-arguments" data-toc="new-dsl-function-for-cleaner-arguments">New DSL function for cleaner arguments</h3><p id="qgapf_422">When running a Kotlin/JS application with Node.js, the arguments passed to your program (<code class="code" id="qgapf_433">args</code>) used to include:</p><ul class="list _bullet" id="qgapf_423"><li class="list__item" id="qgapf_434"><p id="qgapf_437">The path to the executable <code class="code" id="qgapf_438">Node</code>.</p></li><li class="list__item" id="qgapf_435"><p id="qgapf_439">The path to your script.</p></li><li class="list__item" id="qgapf_436"><p id="qgapf_440">The actual command-line arguments you provided.</p></li></ul><p id="qgapf_424">However, the expected behavior for <code class="code" id="qgapf_441">args</code> was to include only the command-line arguments. To achieve this, you had to manually skip the first two arguments using the <code class="code" id="qgapf_442">drop()</code> function inside your <code class="code" id="qgapf_443">build.gradle(.kts)</code> file or in your Kotlin code:</p><div class="code-block" data-lang="kotlin">
fun main(args: Array&lt;String&gt;) {
    println(args.drop(2).joinToString(&quot;, &quot;))
}
</div><p id="qgapf_426">This workaround was repetitive, error-prone, and didn't work well when sharing code between platforms.</p><p id="qgapf_427">To fix this issue, Kotlin 2.2.20-Beta2 introduces a new DSL function called <code class="code" id="qgapf_444">passCliArgumentsToMainFunction()</code>.</p><p id="qgapf_428">With this function, the arguments only include the command-line arguments and exclude the <code class="code" id="qgapf_445">Node</code> and script paths:</p><div class="code-block" data-lang="kotlin">
fun main(args: Array&lt;String&gt;) {
    // No need for drop() and only your custom arguments are included 
    println(args.joinToString(&quot;, &quot;))
}
</div><p id="qgapf_430">This change reduces boilerplate code, avoids mistakes caused by manually dropping arguments, and improves cross-platform compatibility.</p><p id="qgapf_431">To enable this feature, add the following DSL function inside your <code class="code" id="qgapf_446">build.gradle(.kts)</code> file:</p><div class="code-block" data-lang="kotlin">
kotlin {
    js {
        nodejs {
            passCliArgumentsToMainFunction()
        }
    }
}
</div></section></section><section class="chapter"><h2 id="gradle-new-compiler-performance-metrics-in-build-reports-for-kotlin-native-tasks" data-toc="gradle-new-compiler-performance-metrics-in-build-reports-for-kotlin-native-tasks">Gradle: new compiler performance metrics in build reports for Kotlin/Native tasks</h2><p id="qgapf_447">In Kotlin 1.7.0, we introduced <a href="gradle-compilation-and-caches.html#build-reports" id="qgapf_450">build reports</a> to help track compiler performance. Since then, we've added more metrics to make these reports even more detailed and useful for investigating performance issues.</p><p id="qgapf_448">In Kotlin 2.2.20-Beta2, build reports now include compiler performance metrics for Kotlin/Native tasks.</p><p id="qgapf_449">To learn more about build reports and how to configure them, see <a href="gradle-compilation-and-caches.html#enabling-build-reports" id="qgapf_451">Enabling build reports</a>.</p></section><section class="chapter"><h2 id="maven-support-for-the-kotlin-daemon-in-the-kotlin-maven-plugin" data-toc="maven-support-for-the-kotlin-daemon-in-the-kotlin-maven-plugin">Maven: support for the Kotlin daemon in the kotlin-maven-plugin</h2><p id="qgapf_452">With the introduction of the <a href="whatsnew22.html#new-experimental-build-tools-api" id="qgapf_457">build tools API in Kotlin 2.2.0</a>, Kotlin 2.2.20-Beta2 goes one step further by adding support for the Kotlin daemon in the <code class="code" id="qgapf_458">kotlin-maven-plugin</code>. When using the Kotlin daemon, the Kotlin compiler runs in a separate isolated process, which prevents other Maven plugins from overriding system properties. You can see an example in this <a href="https://youtrack.jetbrains.com/issue/KT-43894/Maven-Windows-error-RuntimeException-Could-not-find-installation-home-path" id="qgapf_459" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack issue</a>.</p><p id="qgapf_453">Starting with Kotlin 2.2.20-Beta2, the Kotlin daemon is used by default. This gives you the added benefit of <a href="maven.html#enable-incremental-compilation" id="qgapf_460">incremental compilation</a>, which can help speed up your build times. If you want to revert to the previous behavior, opt out by setting the following property in your <code class="code" id="qgapf_461">pom.xml</code> file to <code class="code" id="qgapf_462">false</code>:</p><div class="code-block" data-lang="markup">
&lt;properties&gt;
    &lt;kotlin.compiler.daemon&gt;false&lt;/kotlin.compiler.daemon&gt;
&lt;/properties&gt;
</div><p id="qgapf_455">Kotlin 2.2.20-Beta2 also introduces a new <code class="code" id="qgapf_463">jvmArgs</code> property, which you can use to customize the default JVM arguments for the Kotlin daemon. For example, to override the <code class="code" id="qgapf_464">-Xmx</code> and <code class="code" id="qgapf_465">-Xms</code> options, add the following to your <code class="code" id="qgapf_466">pom.xml</code> file:</p><div class="code-block" data-lang="markup">
&lt;properties&gt;
    &lt;kotlin.compiler.daemon.jvmArgs&gt;Xmx1500m,Xms500m&lt;/kotlin.compiler.daemon.jvmArgs&gt;
&lt;/properties&gt;
</div></section><section class="chapter"><h2 id="standard-library-support-for-identifying-interface-types-through-reflection-in-kotlin-js" data-toc="standard-library-support-for-identifying-interface-types-through-reflection-in-kotlin-js" data-label-id="experimental-opt-in">Standard library: support for identifying interface types through reflection in Kotlin/JS</h2><p id="qgapf_468">Kotlin 2.2.20-Beta2 adds the experimental <code class="code" id="qgapf_473">KClass.isInterface</code> property to the Kotlin/JS standard library.</p><p id="qgapf_469">With this property, you can now check whether a class reference represents a Kotlin interface. This brings Kotlin/JS closer to parity with Kotlin/JVM, where you can use <code class="code" id="qgapf_474">KClass.java.isInterface</code> to check if a class represents an interface.</p><p id="qgapf_470">To opt in, use the <code class="code" id="qgapf_475">@OptIn(ExperimentalStdlibApi::class)</code> annotation:</p><div class="code-block" data-lang="kotlin">
@OptIn(ExperimentalStdlibApi::class)
fun inspect(klass: KClass&lt;*&gt;) {
    // Prints true for interfaces
    println(klass.isInterface)
}
</div><p id="qgapf_472">We would appreciate your feedback in our issue tracker, <a href="https://youtrack.jetbrains.com/issue/KT-78581" id="qgapf_476" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></section><div class="last-modified">01 August 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew22.html" class="navigation-links__prev">What's new in Kotlin 2.2.0</a><a href="whatsnew2120.html" class="navigation-links__next">What's new in Kotlin 2.1.20</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>