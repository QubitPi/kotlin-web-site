<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-21T03:45:37.071434789"><link rel="canonical" href="https://kotlinlang.org/docs/type-safe-builders.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Type-safe builders | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"how-it-works","level":0,"title":"How it works","anchor":"#how-it-works"},{"id":"scope-control-dslmarker","level":0,"title":"Scope control: @DslMarker","anchor":"#scope-control-dslmarker"},{"id":"full-definition-of-the-com-example-html-package","level":1,"title":"Full definition of the com.example.html package","anchor":"#full-definition-of-the-com-example-html-package"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Type-safe builders | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/type-safe-builders.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Type-safe builders | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/type-safe-builders.html#webpage",
    "url": "https://kotlinlang.org/docs/type-safe-builders.html",
    "name": "Type-safe builders | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="type-safe-builders" data-main-title="Type-safe builders" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Concepts///Functions///Builders" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/type-safe-builders.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="type-safe-builders" id="type-safe-builders.md">Type-safe builders</h1><p id="-tbtmf8_2">By using well-named functions as builders in combination with <a href="lambdas.html#function-literals-with-receiver" id="-tbtmf8_10">function literals with receiver</a> it is possible to create type-safe, statically-typed builders in Kotlin.</p><p id="-tbtmf8_3">Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Sample use cases for the builders are:</p><ul class="list _bullet" id="-tbtmf8_4"><li class="list__item" id="-tbtmf8_11"><p id="-tbtmf8_13">Generating markup with Kotlin code, such as <a href="https://github.com/Kotlin/kotlinx.html" id="-tbtmf8_14" data-external="true" rel="noopener noreferrer" target="_blank">HTML</a> or XML</p></li><li class="list__item" id="-tbtmf8_12"><p id="-tbtmf8_15">Configuring routes for a web server: <a href="https://ktor.io/docs/routing.html" id="-tbtmf8_16" data-external="true" rel="noopener noreferrer" target="_blank">Ktor</a></p></li></ul><p id="-tbtmf8_5">Consider the following code:</p><div class="code-block" data-lang="kotlin">
import com.example.html.* // see declarations below

fun result() =
    html {
        head {
            title {+&quot;XML encoding with Kotlin&quot;}
        }
        body {
            h1 {+&quot;XML encoding with Kotlin&quot;}
            p  {+&quot;this format can be used as an alternative markup to XML&quot;}

            // an element with attributes and text content
            a(href = &quot;https://kotlinlang.org&quot;) {+&quot;Kotlin&quot;}

            // mixed content
            p {
                +&quot;This is some&quot;
                b {+&quot;mixed&quot;}
                +&quot;text. For more see the&quot;
                a(href = &quot;https://kotlinlang.org&quot;) {+&quot;Kotlin&quot;}
                +&quot;project&quot;
            }
            p {+&quot;some text&quot;}

            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
</div><p id="-tbtmf8_7">This is completely legitimate Kotlin code. You can <a href="https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder" id="-tbtmf8_17" data-external="true" rel="noopener noreferrer" target="_blank">play with this code online (modify it and run in the browser) here</a>.</p><section class="chapter"><h2 id="how-it-works" data-toc="how-it-works">How it works</h2><p id="-tbtmf8_18">Assume that you need to implement a type-safe builder in Kotlin. First of all, define the model you want to build. In this case you need to model HTML tags. It is easily done with a bunch of classes. For example, <code class="code" id="-tbtmf8_43">HTML</code> is a class that describes the <code class="code" id="-tbtmf8_44">&lt;html&gt;</code> tag defining children like <code class="code" id="-tbtmf8_45">&lt;head&gt;</code> and <code class="code" id="-tbtmf8_46">&lt;body&gt;</code>. (See its declaration <a href="#full-definition-of-the-com-example-html-package" id="-tbtmf8_47">below</a>.)</p><p id="-tbtmf8_19">Now, let's recall why you can say something like this in the code:</p><div class="code-block" data-lang="kotlin">
html {
 // ...
}
</div><p id="-tbtmf8_21"><code class="code" id="-tbtmf8_48">html</code> is actually a function call that takes a <a href="lambdas.html" id="-tbtmf8_49">lambda expression</a> as an argument. This function is defined as follows:</p><div class="code-block" data-lang="kotlin">
fun html(init: HTML.() -&gt; Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
</div><p id="-tbtmf8_23">This function takes one parameter named <code class="code" id="-tbtmf8_50">init</code>, which is itself a function. The type of the function is <code class="code" id="-tbtmf8_51">HTML.() -&gt; Unit</code>, which is a <span class="emphasis" id="-tbtmf8_52">function type with receiver</span>. This means that you need to pass an instance of type <code class="code" id="-tbtmf8_53">HTML</code> (a <span class="emphasis" id="-tbtmf8_54">receiver</span>) to the function, and you can call members of that instance inside the function.</p><p id="-tbtmf8_24">The receiver can be accessed through the <code class="code" id="-tbtmf8_55">this</code> keyword:</p><div class="code-block" data-lang="kotlin">
html {
    this.head { ... }
    this.body { ... }
}
</div><p id="-tbtmf8_26">(<code class="code" id="-tbtmf8_56">head</code> and <code class="code" id="-tbtmf8_57">body</code> are member functions of <code class="code" id="-tbtmf8_58">HTML</code>.)</p><p id="-tbtmf8_27">Now, <code class="code" id="-tbtmf8_59">this</code> can be omitted, as usual, and you get something that looks very much like a builder already:</p><div class="code-block" data-lang="kotlin">
html {
    head { ... }
    body { ... }
}
</div><p id="-tbtmf8_29">So, what does this call do? Let's look at the body of <code class="code" id="-tbtmf8_60">html</code> function as defined above. It creates a new instance of <code class="code" id="-tbtmf8_61">HTML</code>, then it initializes it by calling the function that is passed as an argument (in this example this boils down to calling <code class="code" id="-tbtmf8_62">head</code> and <code class="code" id="-tbtmf8_63">body</code> on the <code class="code" id="-tbtmf8_64">HTML</code> instance), and then it returns this instance. This is exactly what a builder should do.</p><p id="-tbtmf8_30">The <code class="code" id="-tbtmf8_65">head</code> and <code class="code" id="-tbtmf8_66">body</code> functions in the <code class="code" id="-tbtmf8_67">HTML</code> class are defined similarly to <code class="code" id="-tbtmf8_68">html</code>. The only difference is that they add the built instances to the <code class="code" id="-tbtmf8_69">children</code> collection of the enclosing <code class="code" id="-tbtmf8_70">HTML</code> instance:</p><div class="code-block" data-lang="kotlin">
fun head(init: Head.() -&gt; Unit): Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -&gt; Unit): Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
</div><p id="-tbtmf8_32">Actually these two functions do just the same thing, so you can have a generic version, <code class="code" id="-tbtmf8_71">initTag</code>:</p><div class="code-block" data-lang="kotlin">
protected fun &lt;T : Element&gt; initTag(tag: T, init: T.() -&gt; Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
</div><p id="-tbtmf8_34">So, now your functions are very simple:</p><div class="code-block" data-lang="kotlin">
fun head(init: Head.() -&gt; Unit) = initTag(Head(), init)

fun body(init: Body.() -&gt; Unit) = initTag(Body(), init)
</div><p id="-tbtmf8_36">And you can use them to build <code class="code" id="-tbtmf8_72">&lt;head&gt;</code> and <code class="code" id="-tbtmf8_73">&lt;body&gt;</code> tags.</p><p id="-tbtmf8_37">One other thing to be discussed here is how you add text to tag bodies. In the example above you say something like:</p><div class="code-block" data-lang="kotlin">
html {
    head {
        title {+&quot;XML encoding with Kotlin&quot;}
    }
    // ...
}
</div><p id="-tbtmf8_39">So basically, you just put a string inside a tag body, but there is this little <code class="code" id="-tbtmf8_74">+</code> in front of it, so it is a function call that invokes a prefix <code class="code" id="-tbtmf8_75">unaryPlus()</code> operation. That operation is actually defined by an extension function <code class="code" id="-tbtmf8_76">unaryPlus()</code> that is a member of the <code class="code" id="-tbtmf8_77">TagWithText</code> abstract class (a parent of <code class="code" id="-tbtmf8_78">Title</code>):</p><div class="code-block" data-lang="kotlin">
operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
</div><p id="-tbtmf8_41">So, what the prefix <code class="code" id="-tbtmf8_79">+</code> does here is wrapping a string into an instance of <code class="code" id="-tbtmf8_80">TextElement</code> and adding it to the <code class="code" id="-tbtmf8_81">children</code> collection, so that it becomes a proper part of the tag tree.</p><p id="-tbtmf8_42">All this is defined in a package <code class="code" id="-tbtmf8_82">com.example.html</code> that is imported at the top of the builder example above. In the last section you can read through the full definition of this package.</p></section><section class="chapter"><h2 id="scope-control-dslmarker" data-toc="scope-control-dslmarker">Scope control: @DslMarker</h2><p id="-tbtmf8_83">When using DSLs, one might have come across the problem that too many functions can be called in the context. You can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag <code class="code" id="-tbtmf8_106">head</code> inside another <code class="code" id="-tbtmf8_107">head</code>:</p><div class="code-block" data-lang="kotlin">
html {
    head {
        head {} // should be forbidden
    }
    // ...
}
</div><p id="-tbtmf8_85">In this example only members of the nearest implicit receiver <code class="code" id="-tbtmf8_108">this@head</code> must be available; <code class="code" id="-tbtmf8_109">head()</code> is a member of the outer receiver <code class="code" id="-tbtmf8_110">this@html</code>, so it must be illegal to call it.</p><p id="-tbtmf8_86">To address this problem, there is a special mechanism to control receiver scope.</p><p id="-tbtmf8_87">To make the compiler start controlling scopes you only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders you declare an annotation <code class="code" id="-tbtmf8_111">@HTMLTagMarker</code>:</p><div class="code-block" data-lang="kotlin">
@DslMarker
annotation class HtmlTagMarker
</div><p id="-tbtmf8_89">An annotation class is called a DSL marker if it is annotated with the <code class="code" id="-tbtmf8_112">@DslMarker</code> annotation.</p><p id="-tbtmf8_90">In our DSL all the tag classes extend the same superclass <code class="code" id="-tbtmf8_113">Tag</code>. It's enough to annotate only the superclass with <code class="code" id="-tbtmf8_114">@HtmlTagMarker</code> and after that the Kotlin compiler will treat all the inherited classes as annotated:</p><div class="code-block" data-lang="kotlin">
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
</div><p id="-tbtmf8_92">You don't have to annotate the <code class="code" id="-tbtmf8_115">HTML</code> or <code class="code" id="-tbtmf8_116">Head</code> classes with <code class="code" id="-tbtmf8_117">@HtmlTagMarker</code> because their superclass is already annotated:</p><div class="code-block" data-lang="kotlin">
class HTML() : Tag(&quot;html&quot;) { ... }

class Head() : Tag(&quot;head&quot;) { ... }
</div><p id="-tbtmf8_94">After you've added this annotation, the Kotlin compiler knows which implicit receivers are part of the same DSL and allows to call members of the nearest receivers only:</p><div class="code-block" data-lang="kotlin">
html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}
</div><p id="-tbtmf8_96">Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:</p><div class="code-block" data-lang="kotlin">
html {
    head {
        this@html.head { } // possible
    }
    // ...
}
</div><p id="-tbtmf8_98">You can also apply the <code class="code" id="-tbtmf8_118">@DslMarker</code> annotation directly to <a href="lambdas.html#function-types" id="-tbtmf8_119">function types</a>. Simply annotate the <code class="code" id="-tbtmf8_120">@DslMarker</code> annotation with <code class="code" id="-tbtmf8_121">@Target(AnnotationTarget.TYPE)</code>:</p><div class="code-block" data-lang="kotlin">
@Target(AnnotationTarget.TYPE)
@DslMarker
annotation class HtmlTagMarker
</div><p id="-tbtmf8_100">As a result, the <code class="code" id="-tbtmf8_122">@DslMarker</code> annotation can be applied to function types, most commonly to lambdas with receivers. For example:</p><div class="code-block" data-lang="kotlin">
fun html(init: @HtmlTagMarker HTML.() -&gt; Unit): HTML { ... }

fun HTML.head(init: @HtmlTagMarker Head.() -&gt; Unit): Head { ... }

fun Head.title(init: @HtmlTagMarker Title.() -&gt; Unit): Title { ... }
</div><p id="-tbtmf8_102">When you call these functions, the <code class="code" id="-tbtmf8_123">@DslMarker</code> annotation restricts access to outer receivers in the body of a lambda marked with it unless you specify them explicitly:</p><div class="code-block" data-lang="kotlin">
html {
    head {
        title {
            // Access to title, head or other functions of outer receivers is restricted here.
        }
    }
}
</div><p id="-tbtmf8_104">Only the nearest receiver's members and extensions are accessible within a lambda, preventing unintended interactions between nested scopes.</p><section class="chapter"><h3 id="full-definition-of-the-com-example-html-package" data-toc="full-definition-of-the-com-example-html-package">Full definition of the com.example.html package</h3><p id="-tbtmf8_124">This is how the package <code class="code" id="-tbtmf8_126">com.example.html</code> is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of <a href="extensions.html" id="-tbtmf8_127">extension functions</a> and <a href="lambdas.html#function-literals-with-receiver" id="-tbtmf8_128">lambdas with receiver</a>.</p><div class="code-block" data-lang="kotlin">
package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append(&quot;$indent$text\n&quot;)
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf&lt;Element&gt;()
    val attributes = hashMapOf&lt;String, String&gt;()

    protected fun &lt;T : Element&gt; initTag(tag: T, init: T.() -&gt; Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append(&quot;$indent&lt;$name${renderAttributes()}&gt;\n&quot;)
        for (c in children) {
            c.render(builder, indent + &quot;  &quot;)
        }
        builder.append(&quot;$indent&lt;/$name&gt;\n&quot;)
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(&quot; $attr=\&quot;$value\&quot;&quot;)
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, &quot;&quot;)
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText(&quot;html&quot;) {
    fun head(init: Head.() -&gt; Unit) = initTag(Head(), init)

    fun body(init: Body.() -&gt; Unit) = initTag(Body(), init)
}

class Head : TagWithText(&quot;head&quot;) {
    fun title(init: Title.() -&gt; Unit) = initTag(Title(), init)
}

class Title : TagWithText(&quot;title&quot;)

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -&gt; Unit) = initTag(B(), init)
    fun p(init: P.() -&gt; Unit) = initTag(P(), init)
    fun h1(init: H1.() -&gt; Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -&gt; Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag(&quot;body&quot;)
class B : BodyTag(&quot;b&quot;)
class P : BodyTag(&quot;p&quot;)
class H1 : BodyTag(&quot;h1&quot;)

class A : BodyTag(&quot;a&quot;) {
    var href: String
        get() = attributes[&quot;href&quot;]!!
        set(value) {
            attributes[&quot;href&quot;] = value
        }
}

fun html(init: HTML.() -&gt; Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
</div></section></section><div class="last-modified">21 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="operator-overloading.html" class="navigation-links__prev">Operator overloading</a><a href="using-builders-with-builder-inference.html" class="navigation-links__next">Using builders with builder type inference</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>