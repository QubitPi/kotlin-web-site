<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-09T15:33:18.352751263"><link rel="canonical" href="https://kotlinlang.org/docs/native-c-interop.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Interoperability with C | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"setting-up-your-project","level":0,"title":"Setting up your project","anchor":"#setting-up-your-project"},{"id":"bindings","level":0,"title":"Bindings","anchor":"#bindings"},{"id":"basic-interop-types","level":1,"title":"Basic interop types","anchor":"#basic-interop-types"},{"id":"memory-allocation","level":1,"title":"Memory allocation","anchor":"#memory-allocation"},{"id":"pass-pointers-to-bindings","level":1,"title":"Pass pointers to bindings","anchor":"#pass-pointers-to-bindings"},{"id":"strings","level":1,"title":"Strings","anchor":"#strings"},{"id":"scope-local-pointers","level":1,"title":"Scope-local pointers","anchor":"#scope-local-pointers"},{"id":"pass-and-receive-structs-by-value","level":1,"title":"Pass and receive structs by value","anchor":"#pass-and-receive-structs-by-value"},{"id":"callbacks","level":1,"title":"Callbacks","anchor":"#callbacks"},{"id":"macros","level":1,"title":"Macros","anchor":"#macros"},{"id":"portability","level":1,"title":"Portability","anchor":"#portability"},{"id":"object-pinning","level":1,"title":"Object pinning","anchor":"#object-pinning"},{"id":"forward-declarations","level":1,"title":"Forward declarations","anchor":"#forward-declarations"},{"id":"what-s-next","level":0,"title":"What\u0027s next","anchor":"#what-s-next"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="Interoperability with C | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/native-c-interop.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Interoperability with C | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/native-c-interop.html#webpage",
    "url": "https://kotlinlang.org/docs/native-c-interop.html",
    "name": "Interoperability with C | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="native-c-interop" data-main-title="Interoperability with C" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Platforms///Native///C interop" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/native/native-c-interop.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="native-c-interop" id="native-c-interop.md">Interoperability with C</h1><aside class="prompt" data-type="note" data-title="" id="-hfexwj_2"><p id="-hfexwj_9">The C libraries import is in <a href="native-c-interop-stability.html" id="-hfexwj_11">Beta</a>. All Kotlin declarations generated by the cinterop tool from C libraries should have the <code class="code" id="-hfexwj_12">@ExperimentalForeignApi</code> annotation.</p><p id="-hfexwj_10">Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX) require opt-in only for some APIs.</p></aside><p id="-hfexwj_3">This document covers general aspects of Kotlin's interoperability with C. Kotlin/Native comes with a cinterop tool, which you can use to quickly generate everything you need to interact with an external C library.</p><p id="-hfexwj_4">The tool analyzes C headers and produces a straightforward mapping of C types, functions, and strings into Kotlin. The generated stubs then can be imported into an IDE to enable code completion and navigation.</p><aside class="prompt" data-type="tip" data-title="" id="-hfexwj_5"><p id="-hfexwj_13">Kotlin also provides interoperability with Objective-C. Objective-C libraries are imported through the cinterop tool as well. For more details, see <a href="native-objc-interop.html" id="-hfexwj_14">Swift/Objective-C interop</a>.</p></aside><section class="chapter"><h2 id="setting-up-your-project" data-toc="setting-up-your-project">Setting up your project</h2><p id="-hfexwj_15">Here's a general workflow when working with a project that needs to consume a C library:</p><ol class="list _decimal" id="-hfexwj_16" type="1"><li class="list__item" id="-hfexwj_19"><p id="-hfexwj_22">Create and configure a <a href="native-definition-file.html" id="-hfexwj_23">definition file</a>. It describes what the cinterop tool should include into Kotlin <a href="#bindings" id="-hfexwj_24">bindings</a>.</p></li><li class="list__item" id="-hfexwj_20"><p id="-hfexwj_25">Configure your Gradle build file to include cinterop in the build process.</p></li><li class="list__item" id="-hfexwj_21"><p id="-hfexwj_26">Compile and run the project to produce the final executable.</p></li></ol><aside class="prompt" data-type="note" data-title="" id="-hfexwj_17"><p id="-hfexwj_27">For a hands-on experience, complete the <a href="native-app-with-c-and-libcurl.html" id="-hfexwj_28">Create an app using C interop</a> tutorial.</p></aside><p id="-hfexwj_18">In many cases, there's no need to configure custom interoperability with a C library. Instead, you can use APIs available on the platform standardized bindings called <a href="native-platform-libs.html" id="-hfexwj_29">platform libraries</a>. For example, POSIX on Linux/macOS platforms, Win32 on the Windows platform, or Apple frameworks on macOS/iOS are available this way.</p></section><section class="chapter"><h2 id="bindings" data-toc="bindings">Bindings</h2><section class="chapter"><h3 id="basic-interop-types" data-toc="basic-interop-types">Basic interop types</h3><p id="-hfexwj_41">All the supported C types have corresponding representations in Kotlin:</p><ul class="list _bullet" id="-hfexwj_42"><li class="list__item" id="-hfexwj_46"><p id="-hfexwj_51">Signed, unsigned integral, and floating point types are mapped to their Kotlin counterpart with the same width.</p></li><li class="list__item" id="-hfexwj_47"><p id="-hfexwj_52">Pointers and arrays are mapped to <code class="code" id="-hfexwj_53">CPointer&lt;T&gt;?</code>.</p></li><li class="list__item" id="-hfexwj_48"><p id="-hfexwj_54">Enums can be mapped to either Kotlin enum or integral values, depending on heuristics and the <a href="native-definition-file.html#configure-enums-generation" id="-hfexwj_55">definition file settings</a>.</p></li><li class="list__item" id="-hfexwj_49"><p id="-hfexwj_56">Structs and unions are mapped to types having fields available via the dot notation, i.e. <code class="code" id="-hfexwj_57">someStructInstance.field1</code>.</p></li><li class="list__item" id="-hfexwj_50"><p id="-hfexwj_58"><code class="code" id="-hfexwj_59">typedef</code> are represented as <code class="code" id="-hfexwj_60">typealias</code>.</p></li></ul><p id="-hfexwj_43">Also, any C type has the Kotlin type representing the lvalue of this type, i.e., the value located in memory rather than a simple immutable self-contained value. Think C++ references as a similar concept. For structs (and <code class="code" id="-hfexwj_61">typedef</code>s to structs), this representation is the main one and has the same name as the struct itself. For Kotlin enums, it's named <code class="code" id="-hfexwj_62">${type}.Var</code>; for <code class="code" id="-hfexwj_63">CPointer&lt;T&gt;</code>, it's <code class="code" id="-hfexwj_64">CPointerVar&lt;T&gt;</code>; and for most other types, it's <code class="code" id="-hfexwj_65">${type}Var</code>.</p><p id="-hfexwj_44">For types that have both representations, the one with the lvalue has a mutable <code class="code" id="-hfexwj_66">.value</code> property for accessing the value.</p><section class="chapter"><h4 id="pointer-types" data-toc="pointer-types">Pointer types</h4><p id="-hfexwj_67">The type argument <code class="code" id="-hfexwj_82">T</code> of <code class="code" id="-hfexwj_83">CPointer&lt;T&gt;</code> must be one of the lvalue types described above. For example, the C type <code class="code" id="-hfexwj_84">struct S*</code> is mapped to <code class="code" id="-hfexwj_85">CPointer&lt;S&gt;</code>, <code class="code" id="-hfexwj_86">int8_t*</code> is mapped to <code class="code" id="-hfexwj_87">CPointer&lt;int_8tVar&gt;</code>, and <code class="code" id="-hfexwj_88">char**</code> is mapped to <code class="code" id="-hfexwj_89">CPointer&lt;CPointerVar&lt;ByteVar&gt;&gt;</code>.</p><p id="-hfexwj_68">C null pointer is represented as Kotlin's <code class="code" id="-hfexwj_90">null</code>, and the pointer type <code class="code" id="-hfexwj_91">CPointer&lt;T&gt;</code> is not nullable, but the <code class="code" id="-hfexwj_92">CPointer&lt;T&gt;?</code> is. The values of this type support all the Kotlin operations related to handling <code class="code" id="-hfexwj_93">null</code>, for example, <code class="code" id="-hfexwj_94">?:</code>, <code class="code" id="-hfexwj_95">?.</code>, <code class="code" id="-hfexwj_96">!!</code>, and so on:</p><div class="code-block" data-lang="kotlin">
val path = getenv(&quot;PATH&quot;)?.toKString() ?: &quot;&quot;
</div><p id="-hfexwj_70">Since the arrays are also mapped to <code class="code" id="-hfexwj_97">CPointer&lt;T&gt;</code>, it supports the <code class="code" id="-hfexwj_98">[]</code> operator for accessing values by index:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
fun shift(ptr: CPointer&lt;ByteVar&gt;, length: Int) {
    for (index in 0 .. length - 2) {
        ptr[index] = ptr[index + 1]
    }
}
</div><p id="-hfexwj_72">The <code class="code" id="-hfexwj_99">.pointed</code> property for <code class="code" id="-hfexwj_100">CPointer&lt;T&gt;</code> returns the lvalue of type <code class="code" id="-hfexwj_101">T</code>, pointed by this pointer. The reverse operation is <code class="code" id="-hfexwj_102">.ptr</code>, it takes the lvalue and returns the pointer to it.</p><p id="-hfexwj_73"><code class="code" id="-hfexwj_103">void*</code> is mapped to <code class="code" id="-hfexwj_104">COpaquePointer</code> &ndash; the special pointer type which is the supertype for any other pointer type. So if the C function takes <code class="code" id="-hfexwj_105">void*</code>, the Kotlin binding accepts any <code class="code" id="-hfexwj_106">CPointer</code>.</p><p id="-hfexwj_74">Casting a pointer (including <code class="code" id="-hfexwj_107">COpaquePointer</code>) can be done with <code class="code" id="-hfexwj_108">.reinterpret&lt;T&gt;</code>, for example:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val intPtr = bytePtr.reinterpret&lt;IntVar&gt;()
</div><p id="-hfexwj_76">Or:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val intPtr: CPointer&lt;IntVar&gt; = bytePtr.reinterpret()
</div><p id="-hfexwj_78">As is with C, these <code class="code" id="-hfexwj_109">.reinterpret</code> casts are unsafe and can potentially lead to subtle memory problems in the application.</p><p id="-hfexwj_79">Also, there are unsafe casts between <code class="code" id="-hfexwj_110">CPointer&lt;T&gt;?</code> and <code class="code" id="-hfexwj_111">Long</code> available, provided by the <code class="code" id="-hfexwj_112">.toLong()</code> and <code class="code" id="-hfexwj_113">.toCPointer&lt;T&gt;()</code> extension methods:</p><div class="code-block" data-lang="kotlin">
val longValue = ptr.toLong()
val originalPtr = longValue.toCPointer&lt;T&gt;()
</div><aside class="prompt" data-type="tip" data-title="" id="-hfexwj_81"><p id="-hfexwj_114">If the type of the result is known from the context, you can omit the type argument thanks to the type inference.</p></aside></section></section><section class="chapter"><h3 id="memory-allocation" data-toc="memory-allocation">Memory allocation</h3><p id="-hfexwj_115">The native memory can be allocated using the <code class="code" id="-hfexwj_125">NativePlacement</code> interface, for example:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val byteVar = placement.alloc&lt;ByteVar&gt;()
</div><p id="-hfexwj_117">Or:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val bytePtr = placement.allocArray&lt;ByteVar&gt;(5)
</div><p id="-hfexwj_119">The most logical placement is in the object <code class="code" id="-hfexwj_126">nativeHeap</code>. It corresponds to allocating native memory with <code class="code" id="-hfexwj_127">malloc</code> and provides an additional <code class="code" id="-hfexwj_128">.free()</code> operation to free allocated memory:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
fun main() {
    val size: Long = 0
    val buffer = nativeHeap.allocArray&lt;ByteVar&gt;(size)
    nativeHeap.free(buffer)
}
</div><p id="-hfexwj_121"><code class="code" id="-hfexwj_129">nativeHeap</code> requires memory to be freed manually. However, it's often useful to allocate memory with a lifetime bound to the lexical scope. It's helpful if such memory is freed automatically.</p><p id="-hfexwj_122">To address this, you can use <code class="code" id="-hfexwj_130">memScoped { }</code>. Inside the braces, the temporary placement is available as an implicit receiver, so it's possible to allocate native memory with alloc and allocArray, and the allocated memory will be automatically freed after leaving the scope.</p><p id="-hfexwj_123">For example, a C function returning values through pointer parameters can be used like:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
val fileSize = memScoped {
    val statBuf = alloc&lt;stat&gt;()
    val error = stat(&quot;/&quot;, statBuf.ptr)
    statBuf.st_size
}
</div></section><section class="chapter"><h3 id="pass-pointers-to-bindings" data-toc="pass-pointers-to-bindings">Pass pointers to bindings</h3><p id="-hfexwj_131">Although C pointers are mapped to the <code class="code" id="-hfexwj_137">CPointer&lt;T&gt; type</code>, C function pointer-typed parameters are mapped to <code class="code" id="-hfexwj_138">CValuesRef&lt;T&gt;.</code> When passing a <code class="code" id="-hfexwj_139">CPointer&lt;T&gt;</code> as a value of such a parameter, it's passed to the C function as is. However, a sequence of values can be passed instead of a pointer. In this case, the sequence is passed &quot;by value&quot;, i.e., the C function receives the pointer to the temporary copy of that sequence, which is valid only until the function returns.</p><p id="-hfexwj_132">The <code class="code" id="-hfexwj_140">CValuesRef&lt;T&gt;</code> representation of pointer parameters is designed to support C array literals without explicit native memory allocation. To construct the immutable self-contained sequence of C values, the following methods are provided:</p><ul class="list _bullet" id="-hfexwj_133"><li class="list__item" id="-hfexwj_141"><p id="-hfexwj_144"><code class="code" id="-hfexwj_145">${type}Array.toCValues()</code>, where <code class="code" id="-hfexwj_146">type</code> is the Kotlin primitive type</p></li><li class="list__item" id="-hfexwj_142"><p id="-hfexwj_147"><code class="code" id="-hfexwj_148">Array&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code>, <code class="code" id="-hfexwj_149">List&lt;CPointer&lt;T&gt;?&gt;.toCValues()</code></p></li><li class="list__item" id="-hfexwj_143"><p id="-hfexwj_150"><code class="code" id="-hfexwj_151">cValuesOf(vararg elements: ${type})</code>, where <code class="code" id="-hfexwj_152">type</code> is a primitive or pointer</p></li></ul><p id="-hfexwj_134">For example:</p><div class="code-block" data-lang="c">
// C:
void foo(int* elements, int count);
...
int elements[] = {1, 2, 3};
foo(elements, 3);
</div><div class="code-block" data-lang="kotlin">
// Kotlin:

foo(cValuesOf(1, 2, 3), 3)
</div></section><section class="chapter"><h3 id="strings" data-toc="strings">Strings</h3><p id="-hfexwj_153">Unlike other pointers, the parameters of type <code class="code" id="-hfexwj_163">const char*</code> are represented as a Kotlin <code class="code" id="-hfexwj_164">String</code>. So it's possible to pass any Kotlin string to a binding expecting a C string.</p><p id="-hfexwj_154">There are also some tools available to convert between Kotlin and C strings manually:</p><ul class="list _bullet" id="-hfexwj_155"><li class="list__item" id="-hfexwj_165"><p id="-hfexwj_167"><code class="code" id="-hfexwj_168">fun CPointer&lt;ByteVar&gt;.toKString(): String</code></p></li><li class="list__item" id="-hfexwj_166"><p id="-hfexwj_169"><code class="code" id="-hfexwj_170">val String.cstr: CValuesRef&lt;ByteVar&gt;</code>.</p></li></ul><p id="-hfexwj_156">To get the pointer, <code class="code" id="-hfexwj_171">.cstr</code> should be allocated in native memory, for example:</p><div class="code-block" data-lang="kotlin">
val cString = kotlinString.cstr.getPointer(nativeHeap)
</div><p id="-hfexwj_158">In all cases, the C string is supposed to be encoded as UTF-8.</p><p id="-hfexwj_159">To skip automatic conversion and ensure raw pointers are used in the bindings, add the <a href="native-definition-file.html#set-up-string-conversion" id="-hfexwj_172"><code class="code" id="-hfexwj_174">noStringConversion</code> property</a> to the <code class="code" id="-hfexwj_173">.def</code> file:</p><div class="code-block" data-lang="c">
noStringConversion = LoadCursorA LoadCursorW
</div><p id="-hfexwj_161">This way, any value of type <code class="code" id="-hfexwj_175">CPointer&lt;ByteVar&gt;</code> can be passed as an argument of <code class="code" id="-hfexwj_176">const char*</code> type. If a Kotlin string should be passed, code like this could be used:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
memScoped {
    LoadCursorA(null, &quot;cursor.bmp&quot;.cstr.ptr)  // for ASCII or UTF-8 version
    LoadCursorW(null, &quot;cursor.bmp&quot;.wcstr.ptr) // for UTF-16 version
}
</div></section><section class="chapter"><h3 id="scope-local-pointers" data-toc="scope-local-pointers">Scope-local pointers</h3><p id="-hfexwj_177">It's possible to create a scope-stable pointer of C representation for the <code class="code" id="-hfexwj_180">CValues&lt;T&gt;</code> instance using the <code class="code" id="-hfexwj_181">CValues&lt;T&gt;.ptr</code> extension property, available under <code class="code" id="-hfexwj_182">memScoped {}</code>. It allows using APIs that require C pointers with a lifetime bound to a certain <code class="code" id="-hfexwj_183">MemScope</code>. For example:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
memScoped {
    items = arrayOfNulls&lt;CPointer&lt;ITEM&gt;?&gt;(6)
    arrayOf(&quot;one&quot;, &quot;two&quot;).forEachIndexed { index, value -&gt; items[index] = value.cstr.ptr }
    menu = new_menu(&quot;Menu&quot;.cstr.ptr, items.toCValues().ptr)
    // ...
}
</div><p id="-hfexwj_179">In this example, all values passed to the C API <code class="code" id="-hfexwj_184">new_menu()</code> have a lifetime of the innermost <code class="code" id="-hfexwj_185">memScope</code> it belongs to. Once the control flow leaves the <code class="code" id="-hfexwj_186">memScoped</code> scope, C pointers become invalid.</p></section><section class="chapter"><h3 id="pass-and-receive-structs-by-value" data-toc="pass-and-receive-structs-by-value">Pass and receive structs by value</h3><p id="-hfexwj_187">When a C function takes or returns a struct/union <code class="code" id="-hfexwj_190">T</code> by value, the corresponding argument type or return type is represented as <code class="code" id="-hfexwj_191">CValue&lt;T&gt;</code>.</p><p id="-hfexwj_188"><code class="code" id="-hfexwj_192">CValue&lt;T&gt;</code> is an opaque type, so the structure fields cannot be accessed with the appropriate Kotlin properties. This can be fine if an API uses structures as opaque handles. However, if field access is required, the following conversion methods are available:</p><ul class="list _bullet" id="-hfexwj_189"><li class="list__item" id="-hfexwj_193"><p id="-hfexwj_198"><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/read-value.html" id="-hfexwj_199" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_205">fun T.readValue(): CValue&lt;T&gt;</code></a> converts (the lvalue) <code class="code" id="-hfexwj_200">T</code> to a <code class="code" id="-hfexwj_201">CValue&lt;T&gt;</code>. So to construct the <code class="code" id="-hfexwj_202">CValue&lt;T&gt;</code>, <code class="code" id="-hfexwj_203">T</code> can be allocated, filled, and then converted to <code class="code" id="-hfexwj_204">CValue&lt;T&gt;</code>.</p></li><li class="list__item" id="-hfexwj_194"><p id="-hfexwj_206"><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-contents.html" id="-hfexwj_208" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_211">CValue&lt;T&gt;.useContents(block: T.() -&gt; R): R</code></a> temporarily stores the <code class="code" id="-hfexwj_209">CValue&lt;T&gt;</code> in memory, and then runs the passed lambda with this placed value <code class="code" id="-hfexwj_210">T</code> as receiver. So to read a single field, you can use the following code:</p><div class="code-block" data-lang="kotlin">
val fieldValue = structValue.useContents { field }
</div></li><li class="list__item" id="-hfexwj_195"><p id="-hfexwj_212"><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/c-value.html" id="-hfexwj_213" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_217">fun cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> applies the provided <code class="code" id="-hfexwj_214">initialize</code> function to allocate <code class="code" id="-hfexwj_215">T</code> in memory and converts the result into a <code class="code" id="-hfexwj_216">CValue&lt;T&gt;</code>.</p></li><li class="list__item" id="-hfexwj_196"><p id="-hfexwj_218"><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/copy.html" id="-hfexwj_219" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_223">fun CValue&lt;T&gt;.copy(modify: T.() -&gt; Unit): CValue&lt;T&gt;</code></a> creates a modified copy of an existing <code class="code" id="-hfexwj_220">CValue&lt;T&gt;</code>. The original value is placed in memory, altered using the <code class="code" id="-hfexwj_221">modify()</code> function, and then converted back into a new <code class="code" id="-hfexwj_222">CValue&lt;T&gt;</code>.</p></li><li class="list__item" id="-hfexwj_197"><p id="-hfexwj_224"><a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/place-to.html" id="-hfexwj_225" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_229">fun CValues&lt;T&gt;.placeTo(scope: AutofreeScope): CPointer&lt;T&gt;</code></a> places the <code class="code" id="-hfexwj_226">CValues&lt;T&gt;</code> into an <code class="code" id="-hfexwj_227">AutofreeScope</code>, returning a pointer to the allocated memory. The allocated memory is automatically freed when the <code class="code" id="-hfexwj_228">AutofreeScope</code> is disposed.</p></li></ul></section><section class="chapter"><h3 id="callbacks" data-toc="callbacks">Callbacks</h3><p id="-hfexwj_230">To convert a Kotlin function to a pointer to a C function, you can use <code class="code" id="-hfexwj_232">staticCFunction(::kotlinFunction)</code>. It's also possible to provide a lambda instead of a function reference. The function or lambda must not capture any values.</p><section class="chapter"><h4 id="pass-user-data-to-callbacks" data-toc="pass-user-data-to-callbacks">Pass user data to callbacks</h4><p id="-hfexwj_233">Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It's passed to some C function (or written to the struct) as <code class="code" id="-hfexwj_243">void*</code>, for example. However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with the <code class="code" id="-hfexwj_244">StableRef</code> class.</p><p id="-hfexwj_234">To wrap the reference:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val stableRef = StableRef.create(kotlinReference)
val voidPtr = stableRef.asCPointer()
</div><p id="-hfexwj_236">Here, the <code class="code" id="-hfexwj_245">voidPtr</code> is a <code class="code" id="-hfexwj_246">COpaquePointer</code> and can be passed to the C function.</p><p id="-hfexwj_237">To unwrap the reference:</p><div class="code-block" data-lang="kotlin">
@OptIn(ExperimentalForeignApi::class)
val stableRef = voidPtr.asStableRef&lt;KotlinClass&gt;()
val kotlinReference = stableRef.get()
</div><p id="-hfexwj_239">Here, <code class="code" id="-hfexwj_247">kotlinReference</code> is the original wrapped reference.</p><p id="-hfexwj_240">The created <code class="code" id="-hfexwj_248">StableRef</code> eventually be manually disposed using the <code class="code" id="-hfexwj_249">.dispose()</code> method to prevent memory leaks:</p><div class="code-block" data-lang="kotlin">
stableRef.dispose()
</div><p id="-hfexwj_242">After that it becomes invalid, so <code class="code" id="-hfexwj_250">voidPtr</code> can't be unwrapped anymore.</p></section></section><section class="chapter"><h3 id="macros" data-toc="macros">Macros</h3><p id="-hfexwj_251">Every C macro that expands to a constant is represented as a Kotlin property.</p><p id="-hfexwj_252">Macros without parameters are supported in cases when the compiler can infer the type:</p><div class="code-block" data-lang="c">
int foo(int);
#define FOO foo(42)
</div><p id="-hfexwj_254">In this case, <code class="code" id="-hfexwj_257">FOO</code> is available in Kotlin.</p><p id="-hfexwj_255">To support other macros, you can expose them manually by wrapping them with supported declarations. For example, function-like macro <code class="code" id="-hfexwj_258">FOO</code> can be exposed as a function <code class="code" id="-hfexwj_259">foo()</code> by <a href="native-definition-file.html#add-custom-declarations" id="-hfexwj_260">adding custom declaration</a> to the library:</p><div class="code-block" data-lang="c">
headers = library/base.h

---

static inline int foo(int arg) {
    return FOO(arg);
}
</div></section><section class="chapter"><h3 id="portability" data-toc="portability">Portability</h3><p id="-hfexwj_261">Sometimes the C libraries have function parameters or struct fields of a platform-dependent type, for example, <code class="code" id="-hfexwj_268">long</code> or <code class="code" id="-hfexwj_269">size_t</code>. Kotlin itself doesn't provide either implicit integer casts or C-style integer casts (for example, <code class="code" id="-hfexwj_270">(size_t) intValue</code>), so to make writing portable code in such cases easier, the <code class="code" id="-hfexwj_271">convert</code> method is provided:</p><div class="code-block" data-lang="kotlin">
fun ${type1}.convert&lt;${type2}&gt;(): ${type2}
</div><p id="-hfexwj_263">Here, each of <code class="code" id="-hfexwj_272">type1</code> and <code class="code" id="-hfexwj_273">type2</code> must be an integral type, either signed or unsigned.</p><p id="-hfexwj_264"><code class="code" id="-hfexwj_274">.convert&lt;${type}&gt;</code> has the same semantics as one of the <code class="code" id="-hfexwj_275">.toByte</code>, <code class="code" id="-hfexwj_276">.toShort</code>, <code class="code" id="-hfexwj_277">.toInt</code>, <code class="code" id="-hfexwj_278">.toLong</code>, <code class="code" id="-hfexwj_279">.toUByte</code>, <code class="code" id="-hfexwj_280">.toUShort</code>, <code class="code" id="-hfexwj_281">.toUInt</code> or <code class="code" id="-hfexwj_282">.toULong</code> methods, depending on <code class="code" id="-hfexwj_283">type</code>.</p><p id="-hfexwj_265">An example of using <code class="code" id="-hfexwj_284">convert</code>:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
fun zeroMemory(buffer: COpaquePointer, size: Int) {
    memset(buffer, 0, size.convert&lt;size_t&gt;())
}
</div><p id="-hfexwj_267">Also, the type parameter can be inferred automatically and so may be omitted in some cases.</p></section><section class="chapter"><h3 id="object-pinning" data-toc="object-pinning">Object pinning</h3><p id="-hfexwj_285">Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until they are unpinned, and pointers to such objects' inner data could be passed to C functions.</p><p id="-hfexwj_286">There's a couple of approaches you can take:</p><ul class="list _bullet" id="-hfexwj_287"><li class="list__item" id="-hfexwj_288"><p id="-hfexwj_290">Use the <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/use-pinned.html" id="-hfexwj_293" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_294">.usePinned()</code></a> extension function that pins an object, executes a block, and unpins it on normal and exception paths:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
fun readData(fd: Int) {
    val buffer = ByteArray(1024)
    buffer.usePinned { pinned -&gt;
        while (true) {
            val length = recv(fd, pinned.addressOf(0), buffer.size.convert(), 0).toInt()
            if (length &lt;= 0) {
                break
            }
            // Now `buffer` has raw data obtained from the `recv()` call.
        }
    }
}
</div><p id="-hfexwj_292">Here, <code class="code" id="-hfexwj_295">pinned</code> is an object of a special type <code class="code" id="-hfexwj_296">Pinned&lt;T&gt;</code>. It provides useful extensions like <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/address-of.html" id="-hfexwj_297" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_298">.addressOf()</code></a>, which allows getting the address of a pinned array body.</p></li><li class="list__item" id="-hfexwj_289"><p id="-hfexwj_299">Use the <a href="https://kotlinlang.org/api/core/kotlin-stdlib/kotlinx.cinterop/ref-to.html" id="-hfexwj_302" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="-hfexwj_303">.refTo()</code></a> extension function that has similar functionality under the hood but, in certain cases, may help you reduce boilerplate code:</p><div class="code-block" data-lang="kotlin">
import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
fun readData(fd: Int) { 
    val buffer = ByteArray(1024)
    while (true) {
        val length = recv(fd, buffer.refTo(0), buffer.size.convert(), 0).toInt()

        if (length &lt;= 0) {
            break
        }
        // Now `buffer` has raw data obtained from the `recv()` call.
    }
}
</div><p id="-hfexwj_301">Here, <code class="code" id="-hfexwj_304">buffer.refTo(0)</code> has the <code class="code" id="-hfexwj_305">CValuesRef</code> type that pins the array before entering the <code class="code" id="-hfexwj_306">recv()</code> function, passes the address of its zeroth element to the function, and unpins the array after exiting.</p></li></ul></section><section class="chapter"><h3 id="forward-declarations" data-toc="forward-declarations">Forward declarations</h3><p id="-hfexwj_307">To import forward declarations, use the <code class="code" id="-hfexwj_313">cnames</code> package. For example, to import a <code class="code" id="-hfexwj_314">cstructName</code> forward declaration declared in a C library with a <code class="code" id="-hfexwj_315">library.package</code>, use a special forward declaration package: <code class="code" id="-hfexwj_316">import cnames.structs.cstructName</code>.</p><p id="-hfexwj_308">Consider two cinterop libraries: one that has a forward declaration of a struct and another with an actual implementation in another package:</p><div class="code-block" data-lang="c">
// First C library
#include &lt;stdio.h&gt;

struct ForwardDeclaredStruct;

void consumeStruct(struct ForwardDeclaredStruct* s) {
    printf(&quot;Struct consumed\n&quot;);
}
</div><div class="code-block" data-lang="c">
// Second C library
// Header:
#include &lt;stdlib.h&gt;

struct ForwardDeclaredStruct {
    int data;
};

// Implementation:
struct ForwardDeclaredStruct* produceStruct() {
    struct ForwardDeclaredStruct* s = malloc(sizeof(struct ForwardDeclaredStruct));
    s-&gt;data = 42;
    return s;
}
</div><p id="-hfexwj_311">To transfer objects between the two libraries, use an explicit <code class="code" id="-hfexwj_317">as</code> cast in your Kotlin code:</p><div class="code-block" data-lang="kotlin">
// Kotlin code:
fun test() {
    consumeStruct(produceStruct() as CPointer&lt;cnames.structs.ForwardDeclaredStruct&gt;)
}
</div></section></section><section class="chapter"><h2 id="what-s-next" data-toc="what-s-next">What's next</h2><p id="-hfexwj_318">Learn how types, functions, and strings are mapped between Kotlin and C by completing the following tutorials:</p><ul class="list _bullet" id="-hfexwj_319"><li class="list__item" id="-hfexwj_320"><p id="-hfexwj_324"><a href="mapping-primitive-data-types-from-c.html" id="-hfexwj_325">Mapping primitive data types from C</a></p></li><li class="list__item" id="-hfexwj_321"><p id="-hfexwj_326"><a href="mapping-struct-union-types-from-c.html" id="-hfexwj_327">Mapping struct and union types from C</a></p></li><li class="list__item" id="-hfexwj_322"><p id="-hfexwj_328"><a href="mapping-function-pointers-from-c.html" id="-hfexwj_329">Mapping function pointers from C</a></p></li><li class="list__item" id="-hfexwj_323"><p id="-hfexwj_330"><a href="mapping-strings-from-c.html" id="-hfexwj_331">Mapping strings from C</a></p></li></ul></section><div class="last-modified">09 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="native-c-interop-stability.html" class="navigation-links__prev">Stability of C and Objective-C library import</a><a href="mapping-primitive-data-types-from-c.html" class="navigation-links__next">Mapping primitive data types from C &ndash; tutorial</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>